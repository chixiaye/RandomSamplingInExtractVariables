{
  "id" : 39,
  "expression" : "\"encoderOutputBuffer \"",
  "projectName" : "DrKLO@Telegram",
  "commitID" : "11fbfb1329df700b203e1852a71c4c11b5ab12f4",
  "filePath" : "/TMessagesProj/src/main/java/org/telegram/messenger/video/MediaCodecVideoConvertor.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "\"encoderOutputBuffer \"",
    "nodeType" : "StringLiteral",
    "nodePosition" : {
      "charLength" : 22,
      "startLineNumber" : 190,
      "startColumnNumber" : 63,
      "endLineNumber" : 190,
      "endColumnNumber" : 85
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 190,
        "startColumnNumber" : 63,
        "endLineNumber" : 190,
        "endColumnNumber" : 115
      },
      "nodeContext" : "\"encoderOutputBuffer \" + encoderStatus + \" was null\"",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ThrowStatement,expression]",
      "nodePosition" : {
        "charLength" : 74,
        "startLineNumber" : 190,
        "startColumnNumber" : 42,
        "endLineNumber" : 190,
        "endColumnNumber" : 116
      },
      "nodeContext" : "new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\")",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 190,
        "startColumnNumber" : 36,
        "endLineNumber" : 190,
        "endColumnNumber" : 117
      },
      "nodeContext" : "throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n",
      "nodeType" : "ThrowStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 153,
        "startLineNumber" : 189,
        "startColumnNumber" : 57,
        "endLineNumber" : 191,
        "endColumnNumber" : 33
      },
      "nodeContext" : "{\n  throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 178,
        "startLineNumber" : 189,
        "startColumnNumber" : 32,
        "endLineNumber" : 191,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (encodedData == null) {\n  throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 13,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 5181,
        "startLineNumber" : 182,
        "startColumnNumber" : 35,
        "endLineNumber" : 254,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  ByteBuffer encodedData;\n  if (Build.VERSION.SDK_INT < 21) {\n    encodedData=encoderOutputBuffers[encoderStatus];\n  }\n else {\n    encodedData=encoder.getOutputBuffer(encoderStatus);\n  }\n  if (encodedData == null) {\n    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n  }\n  if (info.size > 1) {\n    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        info.offset+=prependHeaderSize;\n        info.size-=prependHeaderSize;\n      }\n      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        if (info.size > 100) {\n          encodedData.position(info.offset);\n          byte[] temp=new byte[100];\n          encodedData.get(temp);\n          int nalCount=0;\n          for (int a=0; a < temp.length - 4; a++) {\n            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n              nalCount++;\n              if (nalCount > 1) {\n                info.offset+=a;\n                info.size-=a;\n                break;\n              }\n            }\n          }\n        }\n        firstEncode=false;\n      }\n      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n      if (availableSize != 0) {\n        if (callback != null) {\n          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n        }\n      }\n    }\n else     if (videoTrackIndex == -5) {\n      byte[] csd=new byte[info.size];\n      encodedData.limit(info.offset + info.size);\n      encodedData.position(info.offset);\n      encodedData.get(csd);\n      ByteBuffer sps=null;\n      ByteBuffer pps=null;\n      for (int a=info.size - 1; a >= 0; a--) {\n        if (a > 3) {\n          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n            sps=ByteBuffer.allocate(a - 3);\n            pps=ByteBuffer.allocate(info.size - (a - 3));\n            sps.put(csd,0,a - 3).position(0);\n            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n            break;\n          }\n        }\n else {\n          break;\n        }\n      }\n      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n      if (sps != null && pps != null) {\n        newFormat.setByteBuffer(\"csd-0\",sps);\n        newFormat.setByteBuffer(\"csd-1\",pps);\n      }\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    }\n  }\n  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n  encoder.releaseOutputBuffer(encoderStatus,false);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 466,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 5373,
        "startLineNumber" : 180,
        "startColumnNumber" : 35,
        "endLineNumber" : 254,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (encoderStatus < 0) {\n  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n}\n else {\n  ByteBuffer encodedData;\n  if (Build.VERSION.SDK_INT < 21) {\n    encodedData=encoderOutputBuffers[encoderStatus];\n  }\n else {\n    encodedData=encoder.getOutputBuffer(encoderStatus);\n  }\n  if (encodedData == null) {\n    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n  }\n  if (info.size > 1) {\n    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        info.offset+=prependHeaderSize;\n        info.size-=prependHeaderSize;\n      }\n      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        if (info.size > 100) {\n          encodedData.position(info.offset);\n          byte[] temp=new byte[100];\n          encodedData.get(temp);\n          int nalCount=0;\n          for (int a=0; a < temp.length - 4; a++) {\n            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n              nalCount++;\n              if (nalCount > 1) {\n                info.offset+=a;\n                info.size-=a;\n                break;\n              }\n            }\n          }\n        }\n        firstEncode=false;\n      }\n      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n      if (availableSize != 0) {\n        if (callback != null) {\n          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n        }\n      }\n    }\n else     if (videoTrackIndex == -5) {\n      byte[] csd=new byte[info.size];\n      encodedData.limit(info.offset + info.size);\n      encodedData.position(info.offset);\n      encodedData.get(csd);\n      ByteBuffer sps=null;\n      ByteBuffer pps=null;\n      for (int a=info.size - 1; a >= 0; a--) {\n        if (a > 3) {\n          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n            sps=ByteBuffer.allocate(a - 3);\n            pps=ByteBuffer.allocate(info.size - (a - 3));\n            sps.put(csd,0,a - 3).position(0);\n            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n            break;\n          }\n        }\n else {\n          break;\n        }\n      }\n      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n      if (sps != null && pps != null) {\n        newFormat.setByteBuffer(\"csd-0\",sps);\n        newFormat.setByteBuffer(\"csd-1\",pps);\n      }\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    }\n  }\n  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n  encoder.releaseOutputBuffer(encoderStatus,false);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 478,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 6457,
        "startLineNumber" : 167,
        "startColumnNumber" : 35,
        "endLineNumber" : 254,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n  MediaFormat newFormat=encoder.getOutputFormat();\n  if (BuildVars.LOGS_ENABLED) {\n    FileLog.d(\"photo encoder new format \" + newFormat);\n  }\n  if (videoTrackIndex == -5 && newFormat != null) {\n    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n      ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n      ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n      prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n    }\n  }\n}\n else if (encoderStatus < 0) {\n  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n}\n else {\n  ByteBuffer encodedData;\n  if (Build.VERSION.SDK_INT < 21) {\n    encodedData=encoderOutputBuffers[encoderStatus];\n  }\n else {\n    encodedData=encoder.getOutputBuffer(encoderStatus);\n  }\n  if (encodedData == null) {\n    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n  }\n  if (info.size > 1) {\n    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        info.offset+=prependHeaderSize;\n        info.size-=prependHeaderSize;\n      }\n      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        if (info.size > 100) {\n          encodedData.position(info.offset);\n          byte[] temp=new byte[100];\n          encodedData.get(temp);\n          int nalCount=0;\n          for (int a=0; a < temp.length - 4; a++) {\n            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n              nalCount++;\n              if (nalCount > 1) {\n                info.offset+=a;\n                info.size-=a;\n                break;\n              }\n            }\n          }\n        }\n        firstEncode=false;\n      }\n      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n      if (availableSize != 0) {\n        if (callback != null) {\n          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n        }\n      }\n    }\n else     if (videoTrackIndex == -5) {\n      byte[] csd=new byte[info.size];\n      encodedData.limit(info.offset + info.size);\n      encodedData.position(info.offset);\n      encodedData.get(csd);\n      ByteBuffer sps=null;\n      ByteBuffer pps=null;\n      for (int a=info.size - 1; a >= 0; a--) {\n        if (a > 3) {\n          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n            sps=ByteBuffer.allocate(a - 3);\n            pps=ByteBuffer.allocate(info.size - (a - 3));\n            sps.put(csd,0,a - 3).position(0);\n            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n            break;\n          }\n        }\n else {\n          break;\n        }\n      }\n      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n      if (sps != null && pps != null) {\n        newFormat.setByteBuffer(\"csd-0\",sps);\n        newFormat.setByteBuffer(\"csd-1\",pps);\n      }\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    }\n  }\n  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n  encoder.releaseOutputBuffer(encoderStatus,false);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 568,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 6742,
        "startLineNumber" : 163,
        "startColumnNumber" : 35,
        "endLineNumber" : 254,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n  if (Build.VERSION.SDK_INT < 21) {\n    encoderOutputBuffers=encoder.getOutputBuffers();\n  }\n}\n else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n  MediaFormat newFormat=encoder.getOutputFormat();\n  if (BuildVars.LOGS_ENABLED) {\n    FileLog.d(\"photo encoder new format \" + newFormat);\n  }\n  if (videoTrackIndex == -5 && newFormat != null) {\n    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n      ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n      ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n      prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n    }\n  }\n}\n else if (encoderStatus < 0) {\n  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n}\n else {\n  ByteBuffer encodedData;\n  if (Build.VERSION.SDK_INT < 21) {\n    encodedData=encoderOutputBuffers[encoderStatus];\n  }\n else {\n    encodedData=encoder.getOutputBuffer(encoderStatus);\n  }\n  if (encodedData == null) {\n    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n  }\n  if (info.size > 1) {\n    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        info.offset+=prependHeaderSize;\n        info.size-=prependHeaderSize;\n      }\n      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        if (info.size > 100) {\n          encodedData.position(info.offset);\n          byte[] temp=new byte[100];\n          encodedData.get(temp);\n          int nalCount=0;\n          for (int a=0; a < temp.length - 4; a++) {\n            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n              nalCount++;\n              if (nalCount > 1) {\n                info.offset+=a;\n                info.size-=a;\n                break;\n              }\n            }\n          }\n        }\n        firstEncode=false;\n      }\n      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n      if (availableSize != 0) {\n        if (callback != null) {\n          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n        }\n      }\n    }\n else     if (videoTrackIndex == -5) {\n      byte[] csd=new byte[info.size];\n      encodedData.limit(info.offset + info.size);\n      encodedData.position(info.offset);\n      encodedData.get(csd);\n      ByteBuffer sps=null;\n      ByteBuffer pps=null;\n      for (int a=info.size - 1; a >= 0; a--) {\n        if (a > 3) {\n          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n            sps=ByteBuffer.allocate(a - 3);\n            pps=ByteBuffer.allocate(info.size - (a - 3));\n            sps.put(csd,0,a - 3).position(0);\n            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n            break;\n          }\n        }\n else {\n          break;\n        }\n      }\n      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n      if (sps != null && pps != null) {\n        newFormat.setByteBuffer(\"csd-0\",sps);\n        newFormat.setByteBuffer(\"csd-1\",pps);\n      }\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    }\n  }\n  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n  encoder.releaseOutputBuffer(encoderStatus,false);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 590,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6897,
        "startLineNumber" : 161,
        "startColumnNumber" : 28,
        "endLineNumber" : 254,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n  encoderOutputAvailable=false;\n}\n else if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n  if (Build.VERSION.SDK_INT < 21) {\n    encoderOutputBuffers=encoder.getOutputBuffers();\n  }\n}\n else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n  MediaFormat newFormat=encoder.getOutputFormat();\n  if (BuildVars.LOGS_ENABLED) {\n    FileLog.d(\"photo encoder new format \" + newFormat);\n  }\n  if (videoTrackIndex == -5 && newFormat != null) {\n    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n      ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n      ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n      prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n    }\n  }\n}\n else if (encoderStatus < 0) {\n  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n}\n else {\n  ByteBuffer encodedData;\n  if (Build.VERSION.SDK_INT < 21) {\n    encodedData=encoderOutputBuffers[encoderStatus];\n  }\n else {\n    encodedData=encoder.getOutputBuffer(encoderStatus);\n  }\n  if (encodedData == null) {\n    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n  }\n  if (info.size > 1) {\n    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        info.offset+=prependHeaderSize;\n        info.size-=prependHeaderSize;\n      }\n      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        if (info.size > 100) {\n          encodedData.position(info.offset);\n          byte[] temp=new byte[100];\n          encodedData.get(temp);\n          int nalCount=0;\n          for (int a=0; a < temp.length - 4; a++) {\n            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n              nalCount++;\n              if (nalCount > 1) {\n                info.offset+=a;\n                info.size-=a;\n                break;\n              }\n            }\n          }\n        }\n        firstEncode=false;\n      }\n      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n      if (availableSize != 0) {\n        if (callback != null) {\n          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n        }\n      }\n    }\n else     if (videoTrackIndex == -5) {\n      byte[] csd=new byte[info.size];\n      encodedData.limit(info.offset + info.size);\n      encodedData.position(info.offset);\n      encodedData.get(csd);\n      ByteBuffer sps=null;\n      ByteBuffer pps=null;\n      for (int a=info.size - 1; a >= 0; a--) {\n        if (a > 3) {\n          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n            sps=ByteBuffer.allocate(a - 3);\n            pps=ByteBuffer.allocate(info.size - (a - 3));\n            sps.put(csd,0,a - 3).position(0);\n            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n            break;\n          }\n        }\n else {\n          break;\n        }\n      }\n      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n      if (sps != null && pps != null) {\n        newFormat.setByteBuffer(\"csd-0\",sps);\n        newFormat.setByteBuffer(\"csd-1\",pps);\n      }\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    }\n  }\n  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n  encoder.releaseOutputBuffer(encoderStatus,false);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 601,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 8070,
        "startLineNumber" : 158,
        "startColumnNumber" : 81,
        "endLineNumber" : 272,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  checkConversionCanceled();\n  int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n  if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n    encoderOutputAvailable=false;\n  }\n else   if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n    if (Build.VERSION.SDK_INT < 21) {\n      encoderOutputBuffers=encoder.getOutputBuffers();\n    }\n  }\n else   if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n    MediaFormat newFormat=encoder.getOutputFormat();\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"photo encoder new format \" + newFormat);\n    }\n    if (videoTrackIndex == -5 && newFormat != null) {\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n      if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n        ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n        ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n        prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n      }\n    }\n  }\n else   if (encoderStatus < 0) {\n    throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n  }\n else {\n    ByteBuffer encodedData;\n    if (Build.VERSION.SDK_INT < 21) {\n      encodedData=encoderOutputBuffers[encoderStatus];\n    }\n else {\n      encodedData=encoder.getOutputBuffer(encoderStatus);\n    }\n    if (encodedData == null) {\n      throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n    }\n    if (info.size > 1) {\n      if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n        if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n          info.offset+=prependHeaderSize;\n          info.size-=prependHeaderSize;\n        }\n        if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n          if (info.size > 100) {\n            encodedData.position(info.offset);\n            byte[] temp=new byte[100];\n            encodedData.get(temp);\n            int nalCount=0;\n            for (int a=0; a < temp.length - 4; a++) {\n              if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                nalCount++;\n                if (nalCount > 1) {\n                  info.offset+=a;\n                  info.size-=a;\n                  break;\n                }\n              }\n            }\n          }\n          firstEncode=false;\n        }\n        long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n        if (availableSize != 0) {\n          if (callback != null) {\n            callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n          }\n        }\n      }\n else       if (videoTrackIndex == -5) {\n        byte[] csd=new byte[info.size];\n        encodedData.limit(info.offset + info.size);\n        encodedData.position(info.offset);\n        encodedData.get(csd);\n        ByteBuffer sps=null;\n        ByteBuffer pps=null;\n        for (int a=info.size - 1; a >= 0; a--) {\n          if (a > 3) {\n            if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n              sps=ByteBuffer.allocate(a - 3);\n              pps=ByteBuffer.allocate(info.size - (a - 3));\n              sps.put(csd,0,a - 3).position(0);\n              pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n              break;\n            }\n          }\n else {\n            break;\n          }\n        }\n        MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n        if (sps != null && pps != null) {\n          newFormat.setByteBuffer(\"csd-0\",sps);\n          newFormat.setByteBuffer(\"csd-1\",pps);\n        }\n        videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n      }\n    }\n    outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n    encoder.releaseOutputBuffer(encoderStatus,false);\n  }\n  if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n    continue;\n  }\n  if (!decoderDone) {\n    outputSurface.drawImage();\n    long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n    inputSurface.setPresentationTime(presentationTime);\n    inputSurface.swapBuffers();\n    framesCount++;\n    if (framesCount >= duration / 1000.0f * 30) {\n      decoderDone=true;\n      decoderOutputAvailable=false;\n      encoder.signalEndOfInputStream();\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 682,
      "astHeight" : 24
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8127,
        "startLineNumber" : 158,
        "startColumnNumber" : 24,
        "endLineNumber" : 272,
        "endColumnNumber" : 25
      },
      "nodeContext" : "while (decoderOutputAvailable || encoderOutputAvailable) {\n  checkConversionCanceled();\n  int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n  if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n    encoderOutputAvailable=false;\n  }\n else   if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n    if (Build.VERSION.SDK_INT < 21) {\n      encoderOutputBuffers=encoder.getOutputBuffers();\n    }\n  }\n else   if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n    MediaFormat newFormat=encoder.getOutputFormat();\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"photo encoder new format \" + newFormat);\n    }\n    if (videoTrackIndex == -5 && newFormat != null) {\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n      if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n        ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n        ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n        prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n      }\n    }\n  }\n else   if (encoderStatus < 0) {\n    throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n  }\n else {\n    ByteBuffer encodedData;\n    if (Build.VERSION.SDK_INT < 21) {\n      encodedData=encoderOutputBuffers[encoderStatus];\n    }\n else {\n      encodedData=encoder.getOutputBuffer(encoderStatus);\n    }\n    if (encodedData == null) {\n      throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n    }\n    if (info.size > 1) {\n      if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n        if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n          info.offset+=prependHeaderSize;\n          info.size-=prependHeaderSize;\n        }\n        if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n          if (info.size > 100) {\n            encodedData.position(info.offset);\n            byte[] temp=new byte[100];\n            encodedData.get(temp);\n            int nalCount=0;\n            for (int a=0; a < temp.length - 4; a++) {\n              if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                nalCount++;\n                if (nalCount > 1) {\n                  info.offset+=a;\n                  info.size-=a;\n                  break;\n                }\n              }\n            }\n          }\n          firstEncode=false;\n        }\n        long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n        if (availableSize != 0) {\n          if (callback != null) {\n            callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n          }\n        }\n      }\n else       if (videoTrackIndex == -5) {\n        byte[] csd=new byte[info.size];\n        encodedData.limit(info.offset + info.size);\n        encodedData.position(info.offset);\n        encodedData.get(csd);\n        ByteBuffer sps=null;\n        ByteBuffer pps=null;\n        for (int a=info.size - 1; a >= 0; a--) {\n          if (a > 3) {\n            if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n              sps=ByteBuffer.allocate(a - 3);\n              pps=ByteBuffer.allocate(info.size - (a - 3));\n              sps.put(csd,0,a - 3).position(0);\n              pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n              break;\n            }\n          }\n else {\n            break;\n          }\n        }\n        MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n        if (sps != null && pps != null) {\n          newFormat.setByteBuffer(\"csd-0\",sps);\n          newFormat.setByteBuffer(\"csd-1\",pps);\n        }\n        videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n      }\n    }\n    outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n    encoder.releaseOutputBuffer(encoderStatus,false);\n  }\n  if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n    continue;\n  }\n  if (!decoderDone) {\n    outputSurface.drawImage();\n    long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n    inputSurface.setPresentationTime(presentationTime);\n    inputSurface.swapBuffers();\n    framesCount++;\n    if (framesCount >= duration / 1000.0f * 30) {\n      decoderDone=true;\n      decoderOutputAvailable=false;\n      encoder.signalEndOfInputStream();\n    }\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 686,
      "astHeight" : 25
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 8361,
        "startLineNumber" : 153,
        "startColumnNumber" : 40,
        "endLineNumber" : 273,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  checkConversionCanceled();\n  boolean decoderOutputAvailable=!decoderDone;\n  boolean encoderOutputAvailable=true;\n  while (decoderOutputAvailable || encoderOutputAvailable) {\n    checkConversionCanceled();\n    int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n    if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n      encoderOutputAvailable=false;\n    }\n else     if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n      if (Build.VERSION.SDK_INT < 21) {\n        encoderOutputBuffers=encoder.getOutputBuffers();\n      }\n    }\n else     if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n      MediaFormat newFormat=encoder.getOutputFormat();\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"photo encoder new format \" + newFormat);\n      }\n      if (videoTrackIndex == -5 && newFormat != null) {\n        videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n        if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n          ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n          ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n          prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n        }\n      }\n    }\n else     if (encoderStatus < 0) {\n      throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n    }\n else {\n      ByteBuffer encodedData;\n      if (Build.VERSION.SDK_INT < 21) {\n        encodedData=encoderOutputBuffers[encoderStatus];\n      }\n else {\n        encodedData=encoder.getOutputBuffer(encoderStatus);\n      }\n      if (encodedData == null) {\n        throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n      }\n      if (info.size > 1) {\n        if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n          if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n            info.offset+=prependHeaderSize;\n            info.size-=prependHeaderSize;\n          }\n          if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n            if (info.size > 100) {\n              encodedData.position(info.offset);\n              byte[] temp=new byte[100];\n              encodedData.get(temp);\n              int nalCount=0;\n              for (int a=0; a < temp.length - 4; a++) {\n                if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                  nalCount++;\n                  if (nalCount > 1) {\n                    info.offset+=a;\n                    info.size-=a;\n                    break;\n                  }\n                }\n              }\n            }\n            firstEncode=false;\n          }\n          long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n          if (availableSize != 0) {\n            if (callback != null) {\n              callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n            }\n          }\n        }\n else         if (videoTrackIndex == -5) {\n          byte[] csd=new byte[info.size];\n          encodedData.limit(info.offset + info.size);\n          encodedData.position(info.offset);\n          encodedData.get(csd);\n          ByteBuffer sps=null;\n          ByteBuffer pps=null;\n          for (int a=info.size - 1; a >= 0; a--) {\n            if (a > 3) {\n              if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                sps=ByteBuffer.allocate(a - 3);\n                pps=ByteBuffer.allocate(info.size - (a - 3));\n                sps.put(csd,0,a - 3).position(0);\n                pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                break;\n              }\n            }\n else {\n              break;\n            }\n          }\n          MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n          if (sps != null && pps != null) {\n            newFormat.setByteBuffer(\"csd-0\",sps);\n            newFormat.setByteBuffer(\"csd-1\",pps);\n          }\n          videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n        }\n      }\n      outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n      encoder.releaseOutputBuffer(encoderStatus,false);\n    }\n    if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n      continue;\n    }\n    if (!decoderDone) {\n      outputSurface.drawImage();\n      long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n      inputSurface.setPresentationTime(presentationTime);\n      inputSurface.swapBuffers();\n      framesCount++;\n      if (framesCount >= duration / 1000.0f * 30) {\n        decoderDone=true;\n        decoderOutputAvailable=false;\n        encoder.signalEndOfInputStream();\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 701,
      "astHeight" : 26
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 8381,
        "startLineNumber" : 153,
        "startColumnNumber" : 20,
        "endLineNumber" : 273,
        "endColumnNumber" : 21
      },
      "nodeContext" : "while (!outputDone) {\n  checkConversionCanceled();\n  boolean decoderOutputAvailable=!decoderDone;\n  boolean encoderOutputAvailable=true;\n  while (decoderOutputAvailable || encoderOutputAvailable) {\n    checkConversionCanceled();\n    int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n    if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n      encoderOutputAvailable=false;\n    }\n else     if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n      if (Build.VERSION.SDK_INT < 21) {\n        encoderOutputBuffers=encoder.getOutputBuffers();\n      }\n    }\n else     if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n      MediaFormat newFormat=encoder.getOutputFormat();\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"photo encoder new format \" + newFormat);\n      }\n      if (videoTrackIndex == -5 && newFormat != null) {\n        videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n        if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n          ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n          ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n          prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n        }\n      }\n    }\n else     if (encoderStatus < 0) {\n      throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n    }\n else {\n      ByteBuffer encodedData;\n      if (Build.VERSION.SDK_INT < 21) {\n        encodedData=encoderOutputBuffers[encoderStatus];\n      }\n else {\n        encodedData=encoder.getOutputBuffer(encoderStatus);\n      }\n      if (encodedData == null) {\n        throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n      }\n      if (info.size > 1) {\n        if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n          if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n            info.offset+=prependHeaderSize;\n            info.size-=prependHeaderSize;\n          }\n          if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n            if (info.size > 100) {\n              encodedData.position(info.offset);\n              byte[] temp=new byte[100];\n              encodedData.get(temp);\n              int nalCount=0;\n              for (int a=0; a < temp.length - 4; a++) {\n                if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                  nalCount++;\n                  if (nalCount > 1) {\n                    info.offset+=a;\n                    info.size-=a;\n                    break;\n                  }\n                }\n              }\n            }\n            firstEncode=false;\n          }\n          long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n          if (availableSize != 0) {\n            if (callback != null) {\n              callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n            }\n          }\n        }\n else         if (videoTrackIndex == -5) {\n          byte[] csd=new byte[info.size];\n          encodedData.limit(info.offset + info.size);\n          encodedData.position(info.offset);\n          encodedData.get(csd);\n          ByteBuffer sps=null;\n          ByteBuffer pps=null;\n          for (int a=info.size - 1; a >= 0; a--) {\n            if (a > 3) {\n              if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                sps=ByteBuffer.allocate(a - 3);\n                pps=ByteBuffer.allocate(info.size - (a - 3));\n                sps.put(csd,0,a - 3).position(0);\n                pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                break;\n              }\n            }\n else {\n              break;\n            }\n          }\n          MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n          if (sps != null && pps != null) {\n            newFormat.setByteBuffer(\"csd-0\",sps);\n            newFormat.setByteBuffer(\"csd-1\",pps);\n          }\n          videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n        }\n      }\n      outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n      encoder.releaseOutputBuffer(encoderStatus,false);\n    }\n    if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n      continue;\n    }\n    if (!decoderDone) {\n      outputSurface.drawImage();\n      long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n      inputSurface.setPresentationTime(presentationTime);\n      inputSurface.swapBuffers();\n      framesCount++;\n      if (framesCount >= duration / 1000.0f * 30) {\n        decoderDone=true;\n        decoderOutputAvailable=false;\n        encoder.signalEndOfInputStream();\n      }\n    }\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 704,
      "astHeight" : 27
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 11357,
        "startLineNumber" : 95,
        "startColumnNumber" : 20,
        "endLineNumber" : 274,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  boolean outputDone=false;\n  boolean decoderDone=false;\n  int framesCount=0;\n  if (avatarStartTime >= 0) {\n    if (durationS <= 2000) {\n      bitrate=2600000;\n    }\n else     if (durationS <= 5000) {\n      bitrate=2200000;\n    }\n else {\n      bitrate=1560000;\n    }\n  }\n else   if (bitrate <= 0) {\n    bitrate=921600;\n  }\n  if (resultWidth % 16 != 0) {\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n    }\n    resultWidth=Math.round(resultWidth / 16.0f) * 16;\n  }\n  if (resultHeight % 16 != 0) {\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n    }\n    resultHeight=Math.round(resultHeight / 16.0f) * 16;\n  }\n  if (BuildVars.LOGS_ENABLED) {\n    FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n  }\n  MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n  outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n  outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n  outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n  outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n  encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n  encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n  inputSurface=new InputSurface(encoder.createInputSurface());\n  inputSurface.makeCurrent();\n  encoder.start();\n  outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n  ByteBuffer[] encoderOutputBuffers=null;\n  ByteBuffer[] encoderInputBuffers=null;\n  if (Build.VERSION.SDK_INT < 21) {\n    encoderOutputBuffers=encoder.getOutputBuffers();\n  }\n  boolean firstEncode=true;\n  checkConversionCanceled();\n  while (!outputDone) {\n    checkConversionCanceled();\n    boolean decoderOutputAvailable=!decoderDone;\n    boolean encoderOutputAvailable=true;\n    while (decoderOutputAvailable || encoderOutputAvailable) {\n      checkConversionCanceled();\n      int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n      if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n        encoderOutputAvailable=false;\n      }\n else       if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n        if (Build.VERSION.SDK_INT < 21) {\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n      }\n else       if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n        MediaFormat newFormat=encoder.getOutputFormat();\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"photo encoder new format \" + newFormat);\n        }\n        if (videoTrackIndex == -5 && newFormat != null) {\n          videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n          if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n            ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n            ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n            prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n          }\n        }\n      }\n else       if (encoderStatus < 0) {\n        throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n      }\n else {\n        ByteBuffer encodedData;\n        if (Build.VERSION.SDK_INT < 21) {\n          encodedData=encoderOutputBuffers[encoderStatus];\n        }\n else {\n          encodedData=encoder.getOutputBuffer(encoderStatus);\n        }\n        if (encodedData == null) {\n          throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n        }\n        if (info.size > 1) {\n          if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n            if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n              info.offset+=prependHeaderSize;\n              info.size-=prependHeaderSize;\n            }\n            if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n              if (info.size > 100) {\n                encodedData.position(info.offset);\n                byte[] temp=new byte[100];\n                encodedData.get(temp);\n                int nalCount=0;\n                for (int a=0; a < temp.length - 4; a++) {\n                  if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                    nalCount++;\n                    if (nalCount > 1) {\n                      info.offset+=a;\n                      info.size-=a;\n                      break;\n                    }\n                  }\n                }\n              }\n              firstEncode=false;\n            }\n            long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n            if (availableSize != 0) {\n              if (callback != null) {\n                callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n              }\n            }\n          }\n else           if (videoTrackIndex == -5) {\n            byte[] csd=new byte[info.size];\n            encodedData.limit(info.offset + info.size);\n            encodedData.position(info.offset);\n            encodedData.get(csd);\n            ByteBuffer sps=null;\n            ByteBuffer pps=null;\n            for (int a=info.size - 1; a >= 0; a--) {\n              if (a > 3) {\n                if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                  sps=ByteBuffer.allocate(a - 3);\n                  pps=ByteBuffer.allocate(info.size - (a - 3));\n                  sps.put(csd,0,a - 3).position(0);\n                  pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                  break;\n                }\n              }\n else {\n                break;\n              }\n            }\n            MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n            if (sps != null && pps != null) {\n              newFormat.setByteBuffer(\"csd-0\",sps);\n              newFormat.setByteBuffer(\"csd-1\",pps);\n            }\n            videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n          }\n        }\n        outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n        encoder.releaseOutputBuffer(encoderStatus,false);\n      }\n      if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n        continue;\n      }\n      if (!decoderDone) {\n        outputSurface.drawImage();\n        long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n        inputSurface.setPresentationTime(presentationTime);\n        inputSurface.swapBuffers();\n        framesCount++;\n        if (framesCount >= duration / 1000.0f * 30) {\n          decoderDone=true;\n          decoderOutputAvailable=false;\n          encoder.signalEndOfInputStream();\n        }\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 991,
      "astHeight" : 28
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11958,
        "startLineNumber" : 95,
        "startColumnNumber" : 16,
        "endLineNumber" : 284,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try {\n  boolean outputDone=false;\n  boolean decoderDone=false;\n  int framesCount=0;\n  if (avatarStartTime >= 0) {\n    if (durationS <= 2000) {\n      bitrate=2600000;\n    }\n else     if (durationS <= 5000) {\n      bitrate=2200000;\n    }\n else {\n      bitrate=1560000;\n    }\n  }\n else   if (bitrate <= 0) {\n    bitrate=921600;\n  }\n  if (resultWidth % 16 != 0) {\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n    }\n    resultWidth=Math.round(resultWidth / 16.0f) * 16;\n  }\n  if (resultHeight % 16 != 0) {\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n    }\n    resultHeight=Math.round(resultHeight / 16.0f) * 16;\n  }\n  if (BuildVars.LOGS_ENABLED) {\n    FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n  }\n  MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n  outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n  outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n  outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n  outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n  encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n  encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n  inputSurface=new InputSurface(encoder.createInputSurface());\n  inputSurface.makeCurrent();\n  encoder.start();\n  outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n  ByteBuffer[] encoderOutputBuffers=null;\n  ByteBuffer[] encoderInputBuffers=null;\n  if (Build.VERSION.SDK_INT < 21) {\n    encoderOutputBuffers=encoder.getOutputBuffers();\n  }\n  boolean firstEncode=true;\n  checkConversionCanceled();\n  while (!outputDone) {\n    checkConversionCanceled();\n    boolean decoderOutputAvailable=!decoderDone;\n    boolean encoderOutputAvailable=true;\n    while (decoderOutputAvailable || encoderOutputAvailable) {\n      checkConversionCanceled();\n      int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n      if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n        encoderOutputAvailable=false;\n      }\n else       if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n        if (Build.VERSION.SDK_INT < 21) {\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n      }\n else       if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n        MediaFormat newFormat=encoder.getOutputFormat();\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"photo encoder new format \" + newFormat);\n        }\n        if (videoTrackIndex == -5 && newFormat != null) {\n          videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n          if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n            ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n            ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n            prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n          }\n        }\n      }\n else       if (encoderStatus < 0) {\n        throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n      }\n else {\n        ByteBuffer encodedData;\n        if (Build.VERSION.SDK_INT < 21) {\n          encodedData=encoderOutputBuffers[encoderStatus];\n        }\n else {\n          encodedData=encoder.getOutputBuffer(encoderStatus);\n        }\n        if (encodedData == null) {\n          throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n        }\n        if (info.size > 1) {\n          if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n            if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n              info.offset+=prependHeaderSize;\n              info.size-=prependHeaderSize;\n            }\n            if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n              if (info.size > 100) {\n                encodedData.position(info.offset);\n                byte[] temp=new byte[100];\n                encodedData.get(temp);\n                int nalCount=0;\n                for (int a=0; a < temp.length - 4; a++) {\n                  if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                    nalCount++;\n                    if (nalCount > 1) {\n                      info.offset+=a;\n                      info.size-=a;\n                      break;\n                    }\n                  }\n                }\n              }\n              firstEncode=false;\n            }\n            long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n            if (availableSize != 0) {\n              if (callback != null) {\n                callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n              }\n            }\n          }\n else           if (videoTrackIndex == -5) {\n            byte[] csd=new byte[info.size];\n            encodedData.limit(info.offset + info.size);\n            encodedData.position(info.offset);\n            encodedData.get(csd);\n            ByteBuffer sps=null;\n            ByteBuffer pps=null;\n            for (int a=info.size - 1; a >= 0; a--) {\n              if (a > 3) {\n                if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                  sps=ByteBuffer.allocate(a - 3);\n                  pps=ByteBuffer.allocate(info.size - (a - 3));\n                  sps.put(csd,0,a - 3).position(0);\n                  pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                  break;\n                }\n              }\n else {\n                break;\n              }\n            }\n            MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n            if (sps != null && pps != null) {\n              newFormat.setByteBuffer(\"csd-0\",sps);\n              newFormat.setByteBuffer(\"csd-1\",pps);\n            }\n            videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n          }\n        }\n        outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n        encoder.releaseOutputBuffer(encoderStatus,false);\n      }\n      if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n        continue;\n      }\n      if (!decoderDone) {\n        outputSurface.drawImage();\n        long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n        inputSurface.setPresentationTime(presentationTime);\n        inputSurface.swapBuffers();\n        framesCount++;\n        if (framesCount >= duration / 1000.0f * 30) {\n          decoderDone=true;\n          decoderOutputAvailable=false;\n          encoder.signalEndOfInputStream();\n        }\n      }\n    }\n  }\n}\n catch (Exception e) {\n  if (e instanceof IllegalStateException && !increaseTimeout) {\n    repeatWithIncreasedTimeout=true;\n  }\n  FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n  FileLog.e(e);\n  error=true;\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 1033,
      "astHeight" : 29
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 12380,
        "startLineNumber" : 94,
        "startColumnNumber" : 25,
        "endLineNumber" : 297,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  try {\n    boolean outputDone=false;\n    boolean decoderDone=false;\n    int framesCount=0;\n    if (avatarStartTime >= 0) {\n      if (durationS <= 2000) {\n        bitrate=2600000;\n      }\n else       if (durationS <= 5000) {\n        bitrate=2200000;\n      }\n else {\n        bitrate=1560000;\n      }\n    }\n else     if (bitrate <= 0) {\n      bitrate=921600;\n    }\n    if (resultWidth % 16 != 0) {\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n      }\n      resultWidth=Math.round(resultWidth / 16.0f) * 16;\n    }\n    if (resultHeight % 16 != 0) {\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n      }\n      resultHeight=Math.round(resultHeight / 16.0f) * 16;\n    }\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n    }\n    MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n    outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n    outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n    outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n    outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n    encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n    encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n    inputSurface=new InputSurface(encoder.createInputSurface());\n    inputSurface.makeCurrent();\n    encoder.start();\n    outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n    ByteBuffer[] encoderOutputBuffers=null;\n    ByteBuffer[] encoderInputBuffers=null;\n    if (Build.VERSION.SDK_INT < 21) {\n      encoderOutputBuffers=encoder.getOutputBuffers();\n    }\n    boolean firstEncode=true;\n    checkConversionCanceled();\n    while (!outputDone) {\n      checkConversionCanceled();\n      boolean decoderOutputAvailable=!decoderDone;\n      boolean encoderOutputAvailable=true;\n      while (decoderOutputAvailable || encoderOutputAvailable) {\n        checkConversionCanceled();\n        int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n        if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n          encoderOutputAvailable=false;\n        }\n else         if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n          if (Build.VERSION.SDK_INT < 21) {\n            encoderOutputBuffers=encoder.getOutputBuffers();\n          }\n        }\n else         if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n          MediaFormat newFormat=encoder.getOutputFormat();\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"photo encoder new format \" + newFormat);\n          }\n          if (videoTrackIndex == -5 && newFormat != null) {\n            videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n            if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n              ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n              ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n              prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n            }\n          }\n        }\n else         if (encoderStatus < 0) {\n          throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n        }\n else {\n          ByteBuffer encodedData;\n          if (Build.VERSION.SDK_INT < 21) {\n            encodedData=encoderOutputBuffers[encoderStatus];\n          }\n else {\n            encodedData=encoder.getOutputBuffer(encoderStatus);\n          }\n          if (encodedData == null) {\n            throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n          }\n          if (info.size > 1) {\n            if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n              if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                info.offset+=prependHeaderSize;\n                info.size-=prependHeaderSize;\n              }\n              if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                if (info.size > 100) {\n                  encodedData.position(info.offset);\n                  byte[] temp=new byte[100];\n                  encodedData.get(temp);\n                  int nalCount=0;\n                  for (int a=0; a < temp.length - 4; a++) {\n                    if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                      nalCount++;\n                      if (nalCount > 1) {\n                        info.offset+=a;\n                        info.size-=a;\n                        break;\n                      }\n                    }\n                  }\n                }\n                firstEncode=false;\n              }\n              long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n              if (availableSize != 0) {\n                if (callback != null) {\n                  callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                }\n              }\n            }\n else             if (videoTrackIndex == -5) {\n              byte[] csd=new byte[info.size];\n              encodedData.limit(info.offset + info.size);\n              encodedData.position(info.offset);\n              encodedData.get(csd);\n              ByteBuffer sps=null;\n              ByteBuffer pps=null;\n              for (int a=info.size - 1; a >= 0; a--) {\n                if (a > 3) {\n                  if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                    sps=ByteBuffer.allocate(a - 3);\n                    pps=ByteBuffer.allocate(info.size - (a - 3));\n                    sps.put(csd,0,a - 3).position(0);\n                    pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                    break;\n                  }\n                }\n else {\n                  break;\n                }\n              }\n              MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n              if (sps != null && pps != null) {\n                newFormat.setByteBuffer(\"csd-0\",sps);\n                newFormat.setByteBuffer(\"csd-1\",pps);\n              }\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n            }\n          }\n          outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n          encoder.releaseOutputBuffer(encoderStatus,false);\n        }\n        if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n          continue;\n        }\n        if (!decoderDone) {\n          outputSurface.drawImage();\n          long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n          inputSurface.setPresentationTime(presentationTime);\n          inputSurface.swapBuffers();\n          framesCount++;\n          if (framesCount >= duration / 1000.0f * 30) {\n            decoderDone=true;\n            decoderOutputAvailable=false;\n            encoder.signalEndOfInputStream();\n          }\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    if (e instanceof IllegalStateException && !increaseTimeout) {\n      repeatWithIncreasedTimeout=true;\n    }\n    FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n    FileLog.e(e);\n    error=true;\n  }\n  if (outputSurface != null) {\n    outputSurface.release();\n  }\n  if (inputSurface != null) {\n    inputSurface.release();\n  }\n  if (encoder != null) {\n    encoder.stop();\n    encoder.release();\n  }\n  checkConversionCanceled();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1068,
      "astHeight" : 30
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42785,
        "startLineNumber" : 94,
        "startColumnNumber" : 12,
        "endLineNumber" : 746,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (isPhoto) {\n  try {\n    boolean outputDone=false;\n    boolean decoderDone=false;\n    int framesCount=0;\n    if (avatarStartTime >= 0) {\n      if (durationS <= 2000) {\n        bitrate=2600000;\n      }\n else       if (durationS <= 5000) {\n        bitrate=2200000;\n      }\n else {\n        bitrate=1560000;\n      }\n    }\n else     if (bitrate <= 0) {\n      bitrate=921600;\n    }\n    if (resultWidth % 16 != 0) {\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n      }\n      resultWidth=Math.round(resultWidth / 16.0f) * 16;\n    }\n    if (resultHeight % 16 != 0) {\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n      }\n      resultHeight=Math.round(resultHeight / 16.0f) * 16;\n    }\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n    }\n    MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n    outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n    outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n    outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n    outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n    encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n    encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n    inputSurface=new InputSurface(encoder.createInputSurface());\n    inputSurface.makeCurrent();\n    encoder.start();\n    outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n    ByteBuffer[] encoderOutputBuffers=null;\n    ByteBuffer[] encoderInputBuffers=null;\n    if (Build.VERSION.SDK_INT < 21) {\n      encoderOutputBuffers=encoder.getOutputBuffers();\n    }\n    boolean firstEncode=true;\n    checkConversionCanceled();\n    while (!outputDone) {\n      checkConversionCanceled();\n      boolean decoderOutputAvailable=!decoderDone;\n      boolean encoderOutputAvailable=true;\n      while (decoderOutputAvailable || encoderOutputAvailable) {\n        checkConversionCanceled();\n        int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n        if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n          encoderOutputAvailable=false;\n        }\n else         if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n          if (Build.VERSION.SDK_INT < 21) {\n            encoderOutputBuffers=encoder.getOutputBuffers();\n          }\n        }\n else         if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n          MediaFormat newFormat=encoder.getOutputFormat();\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"photo encoder new format \" + newFormat);\n          }\n          if (videoTrackIndex == -5 && newFormat != null) {\n            videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n            if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n              ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n              ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n              prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n            }\n          }\n        }\n else         if (encoderStatus < 0) {\n          throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n        }\n else {\n          ByteBuffer encodedData;\n          if (Build.VERSION.SDK_INT < 21) {\n            encodedData=encoderOutputBuffers[encoderStatus];\n          }\n else {\n            encodedData=encoder.getOutputBuffer(encoderStatus);\n          }\n          if (encodedData == null) {\n            throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n          }\n          if (info.size > 1) {\n            if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n              if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                info.offset+=prependHeaderSize;\n                info.size-=prependHeaderSize;\n              }\n              if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                if (info.size > 100) {\n                  encodedData.position(info.offset);\n                  byte[] temp=new byte[100];\n                  encodedData.get(temp);\n                  int nalCount=0;\n                  for (int a=0; a < temp.length - 4; a++) {\n                    if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                      nalCount++;\n                      if (nalCount > 1) {\n                        info.offset+=a;\n                        info.size-=a;\n                        break;\n                      }\n                    }\n                  }\n                }\n                firstEncode=false;\n              }\n              long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n              if (availableSize != 0) {\n                if (callback != null) {\n                  callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                }\n              }\n            }\n else             if (videoTrackIndex == -5) {\n              byte[] csd=new byte[info.size];\n              encodedData.limit(info.offset + info.size);\n              encodedData.position(info.offset);\n              encodedData.get(csd);\n              ByteBuffer sps=null;\n              ByteBuffer pps=null;\n              for (int a=info.size - 1; a >= 0; a--) {\n                if (a > 3) {\n                  if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                    sps=ByteBuffer.allocate(a - 3);\n                    pps=ByteBuffer.allocate(info.size - (a - 3));\n                    sps.put(csd,0,a - 3).position(0);\n                    pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                    break;\n                  }\n                }\n else {\n                  break;\n                }\n              }\n              MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n              if (sps != null && pps != null) {\n                newFormat.setByteBuffer(\"csd-0\",sps);\n                newFormat.setByteBuffer(\"csd-1\",pps);\n              }\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n            }\n          }\n          outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n          encoder.releaseOutputBuffer(encoderStatus,false);\n        }\n        if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n          continue;\n        }\n        if (!decoderDone) {\n          outputSurface.drawImage();\n          long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n          inputSurface.setPresentationTime(presentationTime);\n          inputSurface.swapBuffers();\n          framesCount++;\n          if (framesCount >= duration / 1000.0f * 30) {\n            decoderDone=true;\n            decoderOutputAvailable=false;\n            encoder.signalEndOfInputStream();\n          }\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    if (e instanceof IllegalStateException && !increaseTimeout) {\n      repeatWithIncreasedTimeout=true;\n    }\n    FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n    FileLog.e(e);\n    error=true;\n  }\n  if (outputSurface != null) {\n    outputSurface.release();\n  }\n  if (inputSurface != null) {\n    inputSurface.release();\n  }\n  if (encoder != null) {\n    encoder.stop();\n    encoder.release();\n  }\n  checkConversionCanceled();\n}\n else {\n  extractor=new MediaExtractor();\n  extractor.setDataSource(videoPath);\n  int videoIndex=MediaController.findTrack(extractor,false);\n  int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n  boolean needConvertVideo=false;\n  if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n    needConvertVideo=true;\n  }\n  if (needCompress || needConvertVideo) {\n    AudioRecoder audioRecoder=null;\n    ByteBuffer audioBuffer=null;\n    boolean copyAudioBuffer=true;\n    if (videoIndex >= 0) {\n      MediaCodec decoder=null;\n      try {\n        long videoTime=-1;\n        boolean outputDone=false;\n        boolean inputDone=false;\n        boolean decoderDone=false;\n        int swapUV=0;\n        int audioTrackIndex=-5;\n        long additionalPresentationTime=0;\n        long minPresentationTime=Integer.MIN_VALUE;\n        long frameDelta=1000 / framerate * 1000;\n        extractor.selectTrack(videoIndex);\n        MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n        if (avatarStartTime >= 0) {\n          if (durationS <= 2000) {\n            bitrate=2600000;\n          }\n else           if (durationS <= 5000) {\n            bitrate=2200000;\n          }\n else {\n            bitrate=1560000;\n          }\n          avatarStartTime=0;\n        }\n else         if (bitrate <= 0) {\n          bitrate=921600;\n        }\n        if (originalBitrate > 0) {\n          bitrate=Math.min(originalBitrate,bitrate);\n        }\n        long trueStartTime;\n        if (avatarStartTime >= 0) {\n          avatarStartTime=-1;\n        }\n        if (avatarStartTime >= 0) {\n          extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else         if (startTime > 0) {\n          extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else {\n          extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n        int w;\n        int h;\n        if (cropState != null) {\n          if (rotationValue == 90 || rotationValue == 270) {\n            w=cropState.transformHeight;\n            h=cropState.transformWidth;\n          }\n else {\n            w=cropState.transformWidth;\n            h=cropState.transformHeight;\n          }\n        }\n else {\n          w=resultWidth;\n          h=resultHeight;\n        }\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n        }\n        MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n        if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n          if (bitrate > 921600) {\n            bitrate=921600;\n          }\n          outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n        }\n        encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n        encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n        inputSurface=new InputSurface(encoder.createInputSurface());\n        inputSurface.makeCurrent();\n        encoder.start();\n        decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n        outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n        decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n        decoder.start();\n        ByteBuffer[] decoderInputBuffers=null;\n        ByteBuffer[] encoderOutputBuffers=null;\n        ByteBuffer[] encoderInputBuffers=null;\n        if (Build.VERSION.SDK_INT < 21) {\n          decoderInputBuffers=decoder.getInputBuffers();\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n        if (audioIndex >= 0) {\n          MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n          copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n          if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n            audioIndex=-1;\n          }\n          if (audioIndex >= 0) {\n            if (copyAudioBuffer) {\n              audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n              extractor.selectTrack(audioIndex);\n              int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n              audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n              if (startTime > 0) {\n                extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n else {\n                extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n            }\n else {\n              MediaExtractor audioExtractor=new MediaExtractor();\n              audioExtractor.setDataSource(videoPath);\n              audioExtractor.selectTrack(audioIndex);\n              if (startTime > 0) {\n                audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n else {\n                audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n              audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n              audioRecoder.startTime=startTime;\n              audioRecoder.endTime=endTime;\n              audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n            }\n          }\n        }\n        boolean audioEncoderDone=audioIndex < 0;\n        boolean firstEncode=true;\n        checkConversionCanceled();\n        while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n          checkConversionCanceled();\n          if (!copyAudioBuffer && audioRecoder != null) {\n            audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n          }\n          if (!inputDone) {\n            boolean eof=false;\n            int index=extractor.getSampleTrackIndex();\n            if (index == videoIndex) {\n              int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n              if (inputBufIndex >= 0) {\n                ByteBuffer inputBuf;\n                if (Build.VERSION.SDK_INT < 21) {\n                  inputBuf=decoderInputBuffers[inputBufIndex];\n                }\n else {\n                  inputBuf=decoder.getInputBuffer(inputBufIndex);\n                }\n                int chunkSize=extractor.readSampleData(inputBuf,0);\n                if (chunkSize < 0) {\n                  decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                  inputDone=true;\n                }\n else {\n                  decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                  extractor.advance();\n                }\n              }\n            }\n else             if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n              info.size=extractor.readSampleData(audioBuffer,0);\n              if (Build.VERSION.SDK_INT < 21) {\n                audioBuffer.position(0);\n                audioBuffer.limit(info.size);\n              }\n              if (info.size >= 0) {\n                info.presentationTimeUs=extractor.getSampleTime();\n                extractor.advance();\n              }\n else {\n                info.size=0;\n                inputDone=true;\n              }\n              if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                info.offset=0;\n                info.flags=extractor.getSampleFlags();\n                long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                if (availableSize != 0) {\n                  if (callback != null) {\n                    if (info.presentationTimeUs - startTime > currentPts) {\n                      currentPts=info.presentationTimeUs - startTime;\n                    }\n                    callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                  }\n                }\n              }\n            }\n else             if (index == -1) {\n              eof=true;\n            }\n            if (eof) {\n              int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n              if (inputBufIndex >= 0) {\n                decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                inputDone=true;\n              }\n            }\n          }\n          boolean decoderOutputAvailable=!decoderDone;\n          boolean encoderOutputAvailable=true;\n          while (decoderOutputAvailable || encoderOutputAvailable) {\n            checkConversionCanceled();\n            int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n            if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n              encoderOutputAvailable=false;\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n              if (Build.VERSION.SDK_INT < 21) {\n                encoderOutputBuffers=encoder.getOutputBuffers();\n              }\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n              MediaFormat newFormat=encoder.getOutputFormat();\n              if (videoTrackIndex == -5 && newFormat != null) {\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                  ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                  ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                  prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                }\n              }\n            }\n else             if (encoderStatus < 0) {\n              throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n            }\n else {\n              ByteBuffer encodedData;\n              if (Build.VERSION.SDK_INT < 21) {\n                encodedData=encoderOutputBuffers[encoderStatus];\n              }\n else {\n                encodedData=encoder.getOutputBuffer(encoderStatus);\n              }\n              if (encodedData == null) {\n                throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n              }\n              if (info.size > 1) {\n                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                  if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    info.offset+=prependHeaderSize;\n                    info.size-=prependHeaderSize;\n                  }\n                  if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    if (info.size > 100) {\n                      encodedData.position(info.offset);\n                      byte[] temp=new byte[100];\n                      encodedData.get(temp);\n                      int nalCount=0;\n                      for (int a=0; a < temp.length - 4; a++) {\n                        if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                          nalCount++;\n                          if (nalCount > 1) {\n                            info.offset+=a;\n                            info.size-=a;\n                            break;\n                          }\n                        }\n                      }\n                    }\n                    firstEncode=false;\n                  }\n                  long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      if (info.presentationTimeUs - startTime > currentPts) {\n                        currentPts=info.presentationTimeUs - startTime;\n                      }\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n else                 if (videoTrackIndex == -5) {\n                  byte[] csd=new byte[info.size];\n                  encodedData.limit(info.offset + info.size);\n                  encodedData.position(info.offset);\n                  encodedData.get(csd);\n                  ByteBuffer sps=null;\n                  ByteBuffer pps=null;\n                  for (int a=info.size - 1; a >= 0; a--) {\n                    if (a > 3) {\n                      if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                        sps=ByteBuffer.allocate(a - 3);\n                        pps=ByteBuffer.allocate(info.size - (a - 3));\n                        sps.put(csd,0,a - 3).position(0);\n                        pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                        break;\n                      }\n                    }\n else {\n                      break;\n                    }\n                  }\n                  MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                  if (sps != null && pps != null) {\n                    newFormat.setByteBuffer(\"csd-0\",sps);\n                    newFormat.setByteBuffer(\"csd-1\",pps);\n                  }\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                }\n              }\n              outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n              encoder.releaseOutputBuffer(encoderStatus,false);\n            }\n            if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n              continue;\n            }\n            if (!decoderDone) {\n              int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n              if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                decoderOutputAvailable=false;\n              }\n else               if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n              }\n else               if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                MediaFormat newFormat=decoder.getOutputFormat();\n                if (BuildVars.LOGS_ENABLED) {\n                  FileLog.d(\"newFormat = \" + newFormat);\n                }\n              }\n else               if (decoderStatus < 0) {\n                throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n              }\n else {\n                boolean doRender=info.size != 0;\n                long originalPresentationTime=info.presentationTimeUs;\n                if (endTime > 0 && originalPresentationTime >= endTime) {\n                  inputDone=true;\n                  decoderDone=true;\n                  doRender=false;\n                  info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                }\n                boolean flushed=false;\n                if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                  if (startTime > 0) {\n                    extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                  additionalPresentationTime=minPresentationTime + frameDelta;\n                  endTime=avatarStartTime;\n                  avatarStartTime=-1;\n                  inputDone=false;\n                  decoderDone=false;\n                  doRender=false;\n                  info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                  decoder.flush();\n                  flushed=true;\n                }\n                trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                if (trueStartTime > 0 && videoTime == -1) {\n                  if (originalPresentationTime < trueStartTime) {\n                    doRender=false;\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                    }\n                  }\n else {\n                    videoTime=info.presentationTimeUs;\n                    if (minPresentationTime != Integer.MIN_VALUE) {\n                      additionalPresentationTime-=videoTime;\n                    }\n                  }\n                }\n                if (flushed) {\n                  videoTime=-1;\n                }\n else {\n                  if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                    info.presentationTimeUs+=additionalPresentationTime;\n                  }\n                  decoder.releaseOutputBuffer(decoderStatus,doRender);\n                }\n                if (doRender) {\n                  if (avatarStartTime >= 0) {\n                    minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                  }\n                  boolean errorWait=false;\n                  try {\n                    outputSurface.awaitNewImage();\n                  }\n catch (                  Exception e) {\n                    errorWait=true;\n                    FileLog.e(e);\n                  }\n                  if (!errorWait) {\n                    outputSurface.drawImage();\n                    inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                    inputSurface.swapBuffers();\n                  }\n                }\n                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                  decoderOutputAvailable=false;\n                  if (BuildVars.LOGS_ENABLED) {\n                    FileLog.d(\"decoder stream end\");\n                  }\n                  encoder.signalEndOfInputStream();\n                }\n              }\n            }\n          }\n        }\n      }\n catch (      Exception e) {\n        if (e instanceof IllegalStateException && !increaseTimeout) {\n          repeatWithIncreasedTimeout=true;\n        }\n        FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n        FileLog.e(e);\n        error=true;\n      }\n      extractor.unselectTrack(videoIndex);\n      if (decoder != null) {\n        decoder.stop();\n        decoder.release();\n      }\n    }\n    if (outputSurface != null) {\n      outputSurface.release();\n    }\n    if (inputSurface != null) {\n      inputSurface.release();\n    }\n    if (encoder != null) {\n      encoder.stop();\n      encoder.release();\n    }\n    if (audioRecoder != null) {\n      audioRecoder.release();\n    }\n    checkConversionCanceled();\n  }\n else {\n    readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 3315,
      "astHeight" : 35
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 43472,
        "startLineNumber" : 77,
        "startColumnNumber" : 12,
        "endLineNumber" : 747,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  MediaCodec.BufferInfo info=new MediaCodec.BufferInfo();\n  Mp4Movie movie=new Mp4Movie();\n  movie.setCacheFile(cacheFile);\n  movie.setRotation(0);\n  movie.setSize(resultWidth,resultHeight);\n  mediaMuxer=new MP4Builder().createMovie(movie,isSecret);\n  long currentPts=0;\n  float durationS=duration / 1000f;\n  MediaCodec encoder=null;\n  InputSurface inputSurface=null;\n  OutputSurface outputSurface=null;\n  int prependHeaderSize=0;\n  endPresentationTime=duration * 1000;\n  checkConversionCanceled();\n  if (isPhoto) {\n    try {\n      boolean outputDone=false;\n      boolean decoderDone=false;\n      int framesCount=0;\n      if (avatarStartTime >= 0) {\n        if (durationS <= 2000) {\n          bitrate=2600000;\n        }\n else         if (durationS <= 5000) {\n          bitrate=2200000;\n        }\n else {\n          bitrate=1560000;\n        }\n      }\n else       if (bitrate <= 0) {\n        bitrate=921600;\n      }\n      if (resultWidth % 16 != 0) {\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n        }\n        resultWidth=Math.round(resultWidth / 16.0f) * 16;\n      }\n      if (resultHeight % 16 != 0) {\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n        }\n        resultHeight=Math.round(resultHeight / 16.0f) * 16;\n      }\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n      }\n      MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n      outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n      outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n      outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n      outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n      encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n      encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n      inputSurface=new InputSurface(encoder.createInputSurface());\n      inputSurface.makeCurrent();\n      encoder.start();\n      outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n      ByteBuffer[] encoderOutputBuffers=null;\n      ByteBuffer[] encoderInputBuffers=null;\n      if (Build.VERSION.SDK_INT < 21) {\n        encoderOutputBuffers=encoder.getOutputBuffers();\n      }\n      boolean firstEncode=true;\n      checkConversionCanceled();\n      while (!outputDone) {\n        checkConversionCanceled();\n        boolean decoderOutputAvailable=!decoderDone;\n        boolean encoderOutputAvailable=true;\n        while (decoderOutputAvailable || encoderOutputAvailable) {\n          checkConversionCanceled();\n          int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n          if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n            encoderOutputAvailable=false;\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n            if (Build.VERSION.SDK_INT < 21) {\n              encoderOutputBuffers=encoder.getOutputBuffers();\n            }\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n            MediaFormat newFormat=encoder.getOutputFormat();\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"photo encoder new format \" + newFormat);\n            }\n            if (videoTrackIndex == -5 && newFormat != null) {\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n              }\n            }\n          }\n else           if (encoderStatus < 0) {\n            throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n          }\n else {\n            ByteBuffer encodedData;\n            if (Build.VERSION.SDK_INT < 21) {\n              encodedData=encoderOutputBuffers[encoderStatus];\n            }\n else {\n              encodedData=encoder.getOutputBuffer(encoderStatus);\n            }\n            if (encodedData == null) {\n              throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n            }\n            if (info.size > 1) {\n              if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  info.offset+=prependHeaderSize;\n                  info.size-=prependHeaderSize;\n                }\n                if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  if (info.size > 100) {\n                    encodedData.position(info.offset);\n                    byte[] temp=new byte[100];\n                    encodedData.get(temp);\n                    int nalCount=0;\n                    for (int a=0; a < temp.length - 4; a++) {\n                      if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                        nalCount++;\n                        if (nalCount > 1) {\n                          info.offset+=a;\n                          info.size-=a;\n                          break;\n                        }\n                      }\n                    }\n                  }\n                  firstEncode=false;\n                }\n                long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                if (availableSize != 0) {\n                  if (callback != null) {\n                    callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                  }\n                }\n              }\n else               if (videoTrackIndex == -5) {\n                byte[] csd=new byte[info.size];\n                encodedData.limit(info.offset + info.size);\n                encodedData.position(info.offset);\n                encodedData.get(csd);\n                ByteBuffer sps=null;\n                ByteBuffer pps=null;\n                for (int a=info.size - 1; a >= 0; a--) {\n                  if (a > 3) {\n                    if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                      sps=ByteBuffer.allocate(a - 3);\n                      pps=ByteBuffer.allocate(info.size - (a - 3));\n                      sps.put(csd,0,a - 3).position(0);\n                      pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                      break;\n                    }\n                  }\n else {\n                    break;\n                  }\n                }\n                MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n                if (sps != null && pps != null) {\n                  newFormat.setByteBuffer(\"csd-0\",sps);\n                  newFormat.setByteBuffer(\"csd-1\",pps);\n                }\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              }\n            }\n            outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n            encoder.releaseOutputBuffer(encoderStatus,false);\n          }\n          if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n            continue;\n          }\n          if (!decoderDone) {\n            outputSurface.drawImage();\n            long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n            inputSurface.setPresentationTime(presentationTime);\n            inputSurface.swapBuffers();\n            framesCount++;\n            if (framesCount >= duration / 1000.0f * 30) {\n              decoderDone=true;\n              decoderOutputAvailable=false;\n              encoder.signalEndOfInputStream();\n            }\n          }\n        }\n      }\n    }\n catch (    Exception e) {\n      if (e instanceof IllegalStateException && !increaseTimeout) {\n        repeatWithIncreasedTimeout=true;\n      }\n      FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n      FileLog.e(e);\n      error=true;\n    }\n    if (outputSurface != null) {\n      outputSurface.release();\n    }\n    if (inputSurface != null) {\n      inputSurface.release();\n    }\n    if (encoder != null) {\n      encoder.stop();\n      encoder.release();\n    }\n    checkConversionCanceled();\n  }\n else {\n    extractor=new MediaExtractor();\n    extractor.setDataSource(videoPath);\n    int videoIndex=MediaController.findTrack(extractor,false);\n    int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n    boolean needConvertVideo=false;\n    if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n      needConvertVideo=true;\n    }\n    if (needCompress || needConvertVideo) {\n      AudioRecoder audioRecoder=null;\n      ByteBuffer audioBuffer=null;\n      boolean copyAudioBuffer=true;\n      if (videoIndex >= 0) {\n        MediaCodec decoder=null;\n        try {\n          long videoTime=-1;\n          boolean outputDone=false;\n          boolean inputDone=false;\n          boolean decoderDone=false;\n          int swapUV=0;\n          int audioTrackIndex=-5;\n          long additionalPresentationTime=0;\n          long minPresentationTime=Integer.MIN_VALUE;\n          long frameDelta=1000 / framerate * 1000;\n          extractor.selectTrack(videoIndex);\n          MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n          if (avatarStartTime >= 0) {\n            if (durationS <= 2000) {\n              bitrate=2600000;\n            }\n else             if (durationS <= 5000) {\n              bitrate=2200000;\n            }\n else {\n              bitrate=1560000;\n            }\n            avatarStartTime=0;\n          }\n else           if (bitrate <= 0) {\n            bitrate=921600;\n          }\n          if (originalBitrate > 0) {\n            bitrate=Math.min(originalBitrate,bitrate);\n          }\n          long trueStartTime;\n          if (avatarStartTime >= 0) {\n            avatarStartTime=-1;\n          }\n          if (avatarStartTime >= 0) {\n            extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else           if (startTime > 0) {\n            extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else {\n            extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n          int w;\n          int h;\n          if (cropState != null) {\n            if (rotationValue == 90 || rotationValue == 270) {\n              w=cropState.transformHeight;\n              h=cropState.transformWidth;\n            }\n else {\n              w=cropState.transformWidth;\n              h=cropState.transformHeight;\n            }\n          }\n else {\n            w=resultWidth;\n            h=resultHeight;\n          }\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n          }\n          MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n          outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n          outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n          outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n          outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n          if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n            if (bitrate > 921600) {\n              bitrate=921600;\n            }\n            outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n          }\n          encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n          encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n          inputSurface=new InputSurface(encoder.createInputSurface());\n          inputSurface.makeCurrent();\n          encoder.start();\n          decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n          outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n          decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n          decoder.start();\n          ByteBuffer[] decoderInputBuffers=null;\n          ByteBuffer[] encoderOutputBuffers=null;\n          ByteBuffer[] encoderInputBuffers=null;\n          if (Build.VERSION.SDK_INT < 21) {\n            decoderInputBuffers=decoder.getInputBuffers();\n            encoderOutputBuffers=encoder.getOutputBuffers();\n          }\n          if (audioIndex >= 0) {\n            MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n            copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n            if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n              audioIndex=-1;\n            }\n            if (audioIndex >= 0) {\n              if (copyAudioBuffer) {\n                audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n                extractor.selectTrack(audioIndex);\n                int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n                audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n                if (startTime > 0) {\n                  extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n else {\n                  extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n              }\n else {\n                MediaExtractor audioExtractor=new MediaExtractor();\n                audioExtractor.setDataSource(videoPath);\n                audioExtractor.selectTrack(audioIndex);\n                if (startTime > 0) {\n                  audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n else {\n                  audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n                audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n                audioRecoder.startTime=startTime;\n                audioRecoder.endTime=endTime;\n                audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n              }\n            }\n          }\n          boolean audioEncoderDone=audioIndex < 0;\n          boolean firstEncode=true;\n          checkConversionCanceled();\n          while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n            checkConversionCanceled();\n            if (!copyAudioBuffer && audioRecoder != null) {\n              audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n            }\n            if (!inputDone) {\n              boolean eof=false;\n              int index=extractor.getSampleTrackIndex();\n              if (index == videoIndex) {\n                int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                if (inputBufIndex >= 0) {\n                  ByteBuffer inputBuf;\n                  if (Build.VERSION.SDK_INT < 21) {\n                    inputBuf=decoderInputBuffers[inputBufIndex];\n                  }\n else {\n                    inputBuf=decoder.getInputBuffer(inputBufIndex);\n                  }\n                  int chunkSize=extractor.readSampleData(inputBuf,0);\n                  if (chunkSize < 0) {\n                    decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                    inputDone=true;\n                  }\n else {\n                    decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                    extractor.advance();\n                  }\n                }\n              }\n else               if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n                info.size=extractor.readSampleData(audioBuffer,0);\n                if (Build.VERSION.SDK_INT < 21) {\n                  audioBuffer.position(0);\n                  audioBuffer.limit(info.size);\n                }\n                if (info.size >= 0) {\n                  info.presentationTimeUs=extractor.getSampleTime();\n                  extractor.advance();\n                }\n else {\n                  info.size=0;\n                  inputDone=true;\n                }\n                if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                  info.offset=0;\n                  info.flags=extractor.getSampleFlags();\n                  long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      if (info.presentationTimeUs - startTime > currentPts) {\n                        currentPts=info.presentationTimeUs - startTime;\n                      }\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n              }\n else               if (index == -1) {\n                eof=true;\n              }\n              if (eof) {\n                int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                if (inputBufIndex >= 0) {\n                  decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                  inputDone=true;\n                }\n              }\n            }\n            boolean decoderOutputAvailable=!decoderDone;\n            boolean encoderOutputAvailable=true;\n            while (decoderOutputAvailable || encoderOutputAvailable) {\n              checkConversionCanceled();\n              int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n              if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                encoderOutputAvailable=false;\n              }\n else               if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                if (Build.VERSION.SDK_INT < 21) {\n                  encoderOutputBuffers=encoder.getOutputBuffers();\n                }\n              }\n else               if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                MediaFormat newFormat=encoder.getOutputFormat();\n                if (videoTrackIndex == -5 && newFormat != null) {\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                  if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                    ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                    ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                    prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                  }\n                }\n              }\n else               if (encoderStatus < 0) {\n                throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n              }\n else {\n                ByteBuffer encodedData;\n                if (Build.VERSION.SDK_INT < 21) {\n                  encodedData=encoderOutputBuffers[encoderStatus];\n                }\n else {\n                  encodedData=encoder.getOutputBuffer(encoderStatus);\n                }\n                if (encodedData == null) {\n                  throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n                }\n                if (info.size > 1) {\n                  if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                    if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                      info.offset+=prependHeaderSize;\n                      info.size-=prependHeaderSize;\n                    }\n                    if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                      if (info.size > 100) {\n                        encodedData.position(info.offset);\n                        byte[] temp=new byte[100];\n                        encodedData.get(temp);\n                        int nalCount=0;\n                        for (int a=0; a < temp.length - 4; a++) {\n                          if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                            nalCount++;\n                            if (nalCount > 1) {\n                              info.offset+=a;\n                              info.size-=a;\n                              break;\n                            }\n                          }\n                        }\n                      }\n                      firstEncode=false;\n                    }\n                    long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                    if (availableSize != 0) {\n                      if (callback != null) {\n                        if (info.presentationTimeUs - startTime > currentPts) {\n                          currentPts=info.presentationTimeUs - startTime;\n                        }\n                        callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                      }\n                    }\n                  }\n else                   if (videoTrackIndex == -5) {\n                    byte[] csd=new byte[info.size];\n                    encodedData.limit(info.offset + info.size);\n                    encodedData.position(info.offset);\n                    encodedData.get(csd);\n                    ByteBuffer sps=null;\n                    ByteBuffer pps=null;\n                    for (int a=info.size - 1; a >= 0; a--) {\n                      if (a > 3) {\n                        if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                          sps=ByteBuffer.allocate(a - 3);\n                          pps=ByteBuffer.allocate(info.size - (a - 3));\n                          sps.put(csd,0,a - 3).position(0);\n                          pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                          break;\n                        }\n                      }\n else {\n                        break;\n                      }\n                    }\n                    MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                    if (sps != null && pps != null) {\n                      newFormat.setByteBuffer(\"csd-0\",sps);\n                      newFormat.setByteBuffer(\"csd-1\",pps);\n                    }\n                    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                  }\n                }\n                outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n                encoder.releaseOutputBuffer(encoderStatus,false);\n              }\n              if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n                continue;\n              }\n              if (!decoderDone) {\n                int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n                if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  decoderOutputAvailable=false;\n                }\n else                 if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                }\n else                 if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                  MediaFormat newFormat=decoder.getOutputFormat();\n                  if (BuildVars.LOGS_ENABLED) {\n                    FileLog.d(\"newFormat = \" + newFormat);\n                  }\n                }\n else                 if (decoderStatus < 0) {\n                  throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n                }\n else {\n                  boolean doRender=info.size != 0;\n                  long originalPresentationTime=info.presentationTimeUs;\n                  if (endTime > 0 && originalPresentationTime >= endTime) {\n                    inputDone=true;\n                    decoderDone=true;\n                    doRender=false;\n                    info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                  }\n                  boolean flushed=false;\n                  if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                    if (startTime > 0) {\n                      extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                    }\n else {\n                      extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                    }\n                    additionalPresentationTime=minPresentationTime + frameDelta;\n                    endTime=avatarStartTime;\n                    avatarStartTime=-1;\n                    inputDone=false;\n                    decoderDone=false;\n                    doRender=false;\n                    info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                    decoder.flush();\n                    flushed=true;\n                  }\n                  trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                  if (trueStartTime > 0 && videoTime == -1) {\n                    if (originalPresentationTime < trueStartTime) {\n                      doRender=false;\n                      if (BuildVars.LOGS_ENABLED) {\n                        FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                      }\n                    }\n else {\n                      videoTime=info.presentationTimeUs;\n                      if (minPresentationTime != Integer.MIN_VALUE) {\n                        additionalPresentationTime-=videoTime;\n                      }\n                    }\n                  }\n                  if (flushed) {\n                    videoTime=-1;\n                  }\n else {\n                    if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                      info.presentationTimeUs+=additionalPresentationTime;\n                    }\n                    decoder.releaseOutputBuffer(decoderStatus,doRender);\n                  }\n                  if (doRender) {\n                    if (avatarStartTime >= 0) {\n                      minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                    }\n                    boolean errorWait=false;\n                    try {\n                      outputSurface.awaitNewImage();\n                    }\n catch (                    Exception e) {\n                      errorWait=true;\n                      FileLog.e(e);\n                    }\n                    if (!errorWait) {\n                      outputSurface.drawImage();\n                      inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                      inputSurface.swapBuffers();\n                    }\n                  }\n                  if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                    decoderOutputAvailable=false;\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"decoder stream end\");\n                    }\n                    encoder.signalEndOfInputStream();\n                  }\n                }\n              }\n            }\n          }\n        }\n catch (        Exception e) {\n          if (e instanceof IllegalStateException && !increaseTimeout) {\n            repeatWithIncreasedTimeout=true;\n          }\n          FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n          FileLog.e(e);\n          error=true;\n        }\n        extractor.unselectTrack(videoIndex);\n        if (decoder != null) {\n          decoder.stop();\n          decoder.release();\n        }\n      }\n      if (outputSurface != null) {\n        outputSurface.release();\n      }\n      if (inputSurface != null) {\n        inputSurface.release();\n      }\n      if (encoder != null) {\n        encoder.stop();\n        encoder.release();\n      }\n      if (audioRecoder != null) {\n        audioRecoder.release();\n      }\n      checkConversionCanceled();\n    }\n else {\n      readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 3406,
      "astHeight" : 36
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 44095,
        "startLineNumber" : 77,
        "startColumnNumber" : 8,
        "endLineNumber" : 763,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try {\n  MediaCodec.BufferInfo info=new MediaCodec.BufferInfo();\n  Mp4Movie movie=new Mp4Movie();\n  movie.setCacheFile(cacheFile);\n  movie.setRotation(0);\n  movie.setSize(resultWidth,resultHeight);\n  mediaMuxer=new MP4Builder().createMovie(movie,isSecret);\n  long currentPts=0;\n  float durationS=duration / 1000f;\n  MediaCodec encoder=null;\n  InputSurface inputSurface=null;\n  OutputSurface outputSurface=null;\n  int prependHeaderSize=0;\n  endPresentationTime=duration * 1000;\n  checkConversionCanceled();\n  if (isPhoto) {\n    try {\n      boolean outputDone=false;\n      boolean decoderDone=false;\n      int framesCount=0;\n      if (avatarStartTime >= 0) {\n        if (durationS <= 2000) {\n          bitrate=2600000;\n        }\n else         if (durationS <= 5000) {\n          bitrate=2200000;\n        }\n else {\n          bitrate=1560000;\n        }\n      }\n else       if (bitrate <= 0) {\n        bitrate=921600;\n      }\n      if (resultWidth % 16 != 0) {\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n        }\n        resultWidth=Math.round(resultWidth / 16.0f) * 16;\n      }\n      if (resultHeight % 16 != 0) {\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n        }\n        resultHeight=Math.round(resultHeight / 16.0f) * 16;\n      }\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n      }\n      MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n      outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n      outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n      outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n      outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n      encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n      encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n      inputSurface=new InputSurface(encoder.createInputSurface());\n      inputSurface.makeCurrent();\n      encoder.start();\n      outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n      ByteBuffer[] encoderOutputBuffers=null;\n      ByteBuffer[] encoderInputBuffers=null;\n      if (Build.VERSION.SDK_INT < 21) {\n        encoderOutputBuffers=encoder.getOutputBuffers();\n      }\n      boolean firstEncode=true;\n      checkConversionCanceled();\n      while (!outputDone) {\n        checkConversionCanceled();\n        boolean decoderOutputAvailable=!decoderDone;\n        boolean encoderOutputAvailable=true;\n        while (decoderOutputAvailable || encoderOutputAvailable) {\n          checkConversionCanceled();\n          int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n          if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n            encoderOutputAvailable=false;\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n            if (Build.VERSION.SDK_INT < 21) {\n              encoderOutputBuffers=encoder.getOutputBuffers();\n            }\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n            MediaFormat newFormat=encoder.getOutputFormat();\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"photo encoder new format \" + newFormat);\n            }\n            if (videoTrackIndex == -5 && newFormat != null) {\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n              }\n            }\n          }\n else           if (encoderStatus < 0) {\n            throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n          }\n else {\n            ByteBuffer encodedData;\n            if (Build.VERSION.SDK_INT < 21) {\n              encodedData=encoderOutputBuffers[encoderStatus];\n            }\n else {\n              encodedData=encoder.getOutputBuffer(encoderStatus);\n            }\n            if (encodedData == null) {\n              throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n            }\n            if (info.size > 1) {\n              if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  info.offset+=prependHeaderSize;\n                  info.size-=prependHeaderSize;\n                }\n                if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  if (info.size > 100) {\n                    encodedData.position(info.offset);\n                    byte[] temp=new byte[100];\n                    encodedData.get(temp);\n                    int nalCount=0;\n                    for (int a=0; a < temp.length - 4; a++) {\n                      if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                        nalCount++;\n                        if (nalCount > 1) {\n                          info.offset+=a;\n                          info.size-=a;\n                          break;\n                        }\n                      }\n                    }\n                  }\n                  firstEncode=false;\n                }\n                long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                if (availableSize != 0) {\n                  if (callback != null) {\n                    callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                  }\n                }\n              }\n else               if (videoTrackIndex == -5) {\n                byte[] csd=new byte[info.size];\n                encodedData.limit(info.offset + info.size);\n                encodedData.position(info.offset);\n                encodedData.get(csd);\n                ByteBuffer sps=null;\n                ByteBuffer pps=null;\n                for (int a=info.size - 1; a >= 0; a--) {\n                  if (a > 3) {\n                    if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                      sps=ByteBuffer.allocate(a - 3);\n                      pps=ByteBuffer.allocate(info.size - (a - 3));\n                      sps.put(csd,0,a - 3).position(0);\n                      pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                      break;\n                    }\n                  }\n else {\n                    break;\n                  }\n                }\n                MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n                if (sps != null && pps != null) {\n                  newFormat.setByteBuffer(\"csd-0\",sps);\n                  newFormat.setByteBuffer(\"csd-1\",pps);\n                }\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              }\n            }\n            outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n            encoder.releaseOutputBuffer(encoderStatus,false);\n          }\n          if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n            continue;\n          }\n          if (!decoderDone) {\n            outputSurface.drawImage();\n            long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n            inputSurface.setPresentationTime(presentationTime);\n            inputSurface.swapBuffers();\n            framesCount++;\n            if (framesCount >= duration / 1000.0f * 30) {\n              decoderDone=true;\n              decoderOutputAvailable=false;\n              encoder.signalEndOfInputStream();\n            }\n          }\n        }\n      }\n    }\n catch (    Exception e) {\n      if (e instanceof IllegalStateException && !increaseTimeout) {\n        repeatWithIncreasedTimeout=true;\n      }\n      FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n      FileLog.e(e);\n      error=true;\n    }\n    if (outputSurface != null) {\n      outputSurface.release();\n    }\n    if (inputSurface != null) {\n      inputSurface.release();\n    }\n    if (encoder != null) {\n      encoder.stop();\n      encoder.release();\n    }\n    checkConversionCanceled();\n  }\n else {\n    extractor=new MediaExtractor();\n    extractor.setDataSource(videoPath);\n    int videoIndex=MediaController.findTrack(extractor,false);\n    int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n    boolean needConvertVideo=false;\n    if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n      needConvertVideo=true;\n    }\n    if (needCompress || needConvertVideo) {\n      AudioRecoder audioRecoder=null;\n      ByteBuffer audioBuffer=null;\n      boolean copyAudioBuffer=true;\n      if (videoIndex >= 0) {\n        MediaCodec decoder=null;\n        try {\n          long videoTime=-1;\n          boolean outputDone=false;\n          boolean inputDone=false;\n          boolean decoderDone=false;\n          int swapUV=0;\n          int audioTrackIndex=-5;\n          long additionalPresentationTime=0;\n          long minPresentationTime=Integer.MIN_VALUE;\n          long frameDelta=1000 / framerate * 1000;\n          extractor.selectTrack(videoIndex);\n          MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n          if (avatarStartTime >= 0) {\n            if (durationS <= 2000) {\n              bitrate=2600000;\n            }\n else             if (durationS <= 5000) {\n              bitrate=2200000;\n            }\n else {\n              bitrate=1560000;\n            }\n            avatarStartTime=0;\n          }\n else           if (bitrate <= 0) {\n            bitrate=921600;\n          }\n          if (originalBitrate > 0) {\n            bitrate=Math.min(originalBitrate,bitrate);\n          }\n          long trueStartTime;\n          if (avatarStartTime >= 0) {\n            avatarStartTime=-1;\n          }\n          if (avatarStartTime >= 0) {\n            extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else           if (startTime > 0) {\n            extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else {\n            extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n          int w;\n          int h;\n          if (cropState != null) {\n            if (rotationValue == 90 || rotationValue == 270) {\n              w=cropState.transformHeight;\n              h=cropState.transformWidth;\n            }\n else {\n              w=cropState.transformWidth;\n              h=cropState.transformHeight;\n            }\n          }\n else {\n            w=resultWidth;\n            h=resultHeight;\n          }\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n          }\n          MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n          outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n          outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n          outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n          outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n          if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n            if (bitrate > 921600) {\n              bitrate=921600;\n            }\n            outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n          }\n          encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n          encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n          inputSurface=new InputSurface(encoder.createInputSurface());\n          inputSurface.makeCurrent();\n          encoder.start();\n          decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n          outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n          decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n          decoder.start();\n          ByteBuffer[] decoderInputBuffers=null;\n          ByteBuffer[] encoderOutputBuffers=null;\n          ByteBuffer[] encoderInputBuffers=null;\n          if (Build.VERSION.SDK_INT < 21) {\n            decoderInputBuffers=decoder.getInputBuffers();\n            encoderOutputBuffers=encoder.getOutputBuffers();\n          }\n          if (audioIndex >= 0) {\n            MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n            copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n            if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n              audioIndex=-1;\n            }\n            if (audioIndex >= 0) {\n              if (copyAudioBuffer) {\n                audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n                extractor.selectTrack(audioIndex);\n                int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n                audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n                if (startTime > 0) {\n                  extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n else {\n                  extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n              }\n else {\n                MediaExtractor audioExtractor=new MediaExtractor();\n                audioExtractor.setDataSource(videoPath);\n                audioExtractor.selectTrack(audioIndex);\n                if (startTime > 0) {\n                  audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n else {\n                  audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n                audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n                audioRecoder.startTime=startTime;\n                audioRecoder.endTime=endTime;\n                audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n              }\n            }\n          }\n          boolean audioEncoderDone=audioIndex < 0;\n          boolean firstEncode=true;\n          checkConversionCanceled();\n          while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n            checkConversionCanceled();\n            if (!copyAudioBuffer && audioRecoder != null) {\n              audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n            }\n            if (!inputDone) {\n              boolean eof=false;\n              int index=extractor.getSampleTrackIndex();\n              if (index == videoIndex) {\n                int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                if (inputBufIndex >= 0) {\n                  ByteBuffer inputBuf;\n                  if (Build.VERSION.SDK_INT < 21) {\n                    inputBuf=decoderInputBuffers[inputBufIndex];\n                  }\n else {\n                    inputBuf=decoder.getInputBuffer(inputBufIndex);\n                  }\n                  int chunkSize=extractor.readSampleData(inputBuf,0);\n                  if (chunkSize < 0) {\n                    decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                    inputDone=true;\n                  }\n else {\n                    decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                    extractor.advance();\n                  }\n                }\n              }\n else               if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n                info.size=extractor.readSampleData(audioBuffer,0);\n                if (Build.VERSION.SDK_INT < 21) {\n                  audioBuffer.position(0);\n                  audioBuffer.limit(info.size);\n                }\n                if (info.size >= 0) {\n                  info.presentationTimeUs=extractor.getSampleTime();\n                  extractor.advance();\n                }\n else {\n                  info.size=0;\n                  inputDone=true;\n                }\n                if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                  info.offset=0;\n                  info.flags=extractor.getSampleFlags();\n                  long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      if (info.presentationTimeUs - startTime > currentPts) {\n                        currentPts=info.presentationTimeUs - startTime;\n                      }\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n              }\n else               if (index == -1) {\n                eof=true;\n              }\n              if (eof) {\n                int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                if (inputBufIndex >= 0) {\n                  decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                  inputDone=true;\n                }\n              }\n            }\n            boolean decoderOutputAvailable=!decoderDone;\n            boolean encoderOutputAvailable=true;\n            while (decoderOutputAvailable || encoderOutputAvailable) {\n              checkConversionCanceled();\n              int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n              if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                encoderOutputAvailable=false;\n              }\n else               if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                if (Build.VERSION.SDK_INT < 21) {\n                  encoderOutputBuffers=encoder.getOutputBuffers();\n                }\n              }\n else               if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                MediaFormat newFormat=encoder.getOutputFormat();\n                if (videoTrackIndex == -5 && newFormat != null) {\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                  if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                    ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                    ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                    prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                  }\n                }\n              }\n else               if (encoderStatus < 0) {\n                throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n              }\n else {\n                ByteBuffer encodedData;\n                if (Build.VERSION.SDK_INT < 21) {\n                  encodedData=encoderOutputBuffers[encoderStatus];\n                }\n else {\n                  encodedData=encoder.getOutputBuffer(encoderStatus);\n                }\n                if (encodedData == null) {\n                  throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n                }\n                if (info.size > 1) {\n                  if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                    if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                      info.offset+=prependHeaderSize;\n                      info.size-=prependHeaderSize;\n                    }\n                    if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                      if (info.size > 100) {\n                        encodedData.position(info.offset);\n                        byte[] temp=new byte[100];\n                        encodedData.get(temp);\n                        int nalCount=0;\n                        for (int a=0; a < temp.length - 4; a++) {\n                          if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                            nalCount++;\n                            if (nalCount > 1) {\n                              info.offset+=a;\n                              info.size-=a;\n                              break;\n                            }\n                          }\n                        }\n                      }\n                      firstEncode=false;\n                    }\n                    long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                    if (availableSize != 0) {\n                      if (callback != null) {\n                        if (info.presentationTimeUs - startTime > currentPts) {\n                          currentPts=info.presentationTimeUs - startTime;\n                        }\n                        callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                      }\n                    }\n                  }\n else                   if (videoTrackIndex == -5) {\n                    byte[] csd=new byte[info.size];\n                    encodedData.limit(info.offset + info.size);\n                    encodedData.position(info.offset);\n                    encodedData.get(csd);\n                    ByteBuffer sps=null;\n                    ByteBuffer pps=null;\n                    for (int a=info.size - 1; a >= 0; a--) {\n                      if (a > 3) {\n                        if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                          sps=ByteBuffer.allocate(a - 3);\n                          pps=ByteBuffer.allocate(info.size - (a - 3));\n                          sps.put(csd,0,a - 3).position(0);\n                          pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                          break;\n                        }\n                      }\n else {\n                        break;\n                      }\n                    }\n                    MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                    if (sps != null && pps != null) {\n                      newFormat.setByteBuffer(\"csd-0\",sps);\n                      newFormat.setByteBuffer(\"csd-1\",pps);\n                    }\n                    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                  }\n                }\n                outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n                encoder.releaseOutputBuffer(encoderStatus,false);\n              }\n              if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n                continue;\n              }\n              if (!decoderDone) {\n                int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n                if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  decoderOutputAvailable=false;\n                }\n else                 if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                }\n else                 if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                  MediaFormat newFormat=decoder.getOutputFormat();\n                  if (BuildVars.LOGS_ENABLED) {\n                    FileLog.d(\"newFormat = \" + newFormat);\n                  }\n                }\n else                 if (decoderStatus < 0) {\n                  throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n                }\n else {\n                  boolean doRender=info.size != 0;\n                  long originalPresentationTime=info.presentationTimeUs;\n                  if (endTime > 0 && originalPresentationTime >= endTime) {\n                    inputDone=true;\n                    decoderDone=true;\n                    doRender=false;\n                    info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                  }\n                  boolean flushed=false;\n                  if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                    if (startTime > 0) {\n                      extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                    }\n else {\n                      extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                    }\n                    additionalPresentationTime=minPresentationTime + frameDelta;\n                    endTime=avatarStartTime;\n                    avatarStartTime=-1;\n                    inputDone=false;\n                    decoderDone=false;\n                    doRender=false;\n                    info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                    decoder.flush();\n                    flushed=true;\n                  }\n                  trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                  if (trueStartTime > 0 && videoTime == -1) {\n                    if (originalPresentationTime < trueStartTime) {\n                      doRender=false;\n                      if (BuildVars.LOGS_ENABLED) {\n                        FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                      }\n                    }\n else {\n                      videoTime=info.presentationTimeUs;\n                      if (minPresentationTime != Integer.MIN_VALUE) {\n                        additionalPresentationTime-=videoTime;\n                      }\n                    }\n                  }\n                  if (flushed) {\n                    videoTime=-1;\n                  }\n else {\n                    if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                      info.presentationTimeUs+=additionalPresentationTime;\n                    }\n                    decoder.releaseOutputBuffer(decoderStatus,doRender);\n                  }\n                  if (doRender) {\n                    if (avatarStartTime >= 0) {\n                      minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                    }\n                    boolean errorWait=false;\n                    try {\n                      outputSurface.awaitNewImage();\n                    }\n catch (                    Exception e) {\n                      errorWait=true;\n                      FileLog.e(e);\n                    }\n                    if (!errorWait) {\n                      outputSurface.drawImage();\n                      inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                      inputSurface.swapBuffers();\n                    }\n                  }\n                  if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                    decoderOutputAvailable=false;\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"decoder stream end\");\n                    }\n                    encoder.signalEndOfInputStream();\n                  }\n                }\n              }\n            }\n          }\n        }\n catch (        Exception e) {\n          if (e instanceof IllegalStateException && !increaseTimeout) {\n            repeatWithIncreasedTimeout=true;\n          }\n          FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n          FileLog.e(e);\n          error=true;\n        }\n        extractor.unselectTrack(videoIndex);\n        if (decoder != null) {\n          decoder.stop();\n          decoder.release();\n        }\n      }\n      if (outputSurface != null) {\n        outputSurface.release();\n      }\n      if (inputSurface != null) {\n        inputSurface.release();\n      }\n      if (encoder != null) {\n        encoder.stop();\n        encoder.release();\n      }\n      if (audioRecoder != null) {\n        audioRecoder.release();\n      }\n      checkConversionCanceled();\n    }\n else {\n      readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n    }\n  }\n}\n catch (Exception e) {\n  error=true;\n  FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n  FileLog.e(e);\n}\n finally {\n  if (extractor != null) {\n    extractor.release();\n  }\n  if (mediaMuxer != null) {\n    try {\n      mediaMuxer.finishMovie();\n      endPresentationTime=mediaMuxer.getLastFrameTimestamp(videoTrackIndex);\n    }\n catch (    Exception e) {\n      FileLog.e(e);\n    }\n  }\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 3474,
      "astHeight" : 37
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 44649,
        "startLineNumber" : 71,
        "startColumnNumber" : 78,
        "endLineNumber" : 773,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  boolean error=false;\n  boolean repeatWithIncreasedTimeout=false;\n  int videoTrackIndex=-5;\n  try {\n    MediaCodec.BufferInfo info=new MediaCodec.BufferInfo();\n    Mp4Movie movie=new Mp4Movie();\n    movie.setCacheFile(cacheFile);\n    movie.setRotation(0);\n    movie.setSize(resultWidth,resultHeight);\n    mediaMuxer=new MP4Builder().createMovie(movie,isSecret);\n    long currentPts=0;\n    float durationS=duration / 1000f;\n    MediaCodec encoder=null;\n    InputSurface inputSurface=null;\n    OutputSurface outputSurface=null;\n    int prependHeaderSize=0;\n    endPresentationTime=duration * 1000;\n    checkConversionCanceled();\n    if (isPhoto) {\n      try {\n        boolean outputDone=false;\n        boolean decoderDone=false;\n        int framesCount=0;\n        if (avatarStartTime >= 0) {\n          if (durationS <= 2000) {\n            bitrate=2600000;\n          }\n else           if (durationS <= 5000) {\n            bitrate=2200000;\n          }\n else {\n            bitrate=1560000;\n          }\n        }\n else         if (bitrate <= 0) {\n          bitrate=921600;\n        }\n        if (resultWidth % 16 != 0) {\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n          }\n          resultWidth=Math.round(resultWidth / 16.0f) * 16;\n        }\n        if (resultHeight % 16 != 0) {\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n          }\n          resultHeight=Math.round(resultHeight / 16.0f) * 16;\n        }\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n        }\n        MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n        encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n        encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n        inputSurface=new InputSurface(encoder.createInputSurface());\n        inputSurface.makeCurrent();\n        encoder.start();\n        outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n        ByteBuffer[] encoderOutputBuffers=null;\n        ByteBuffer[] encoderInputBuffers=null;\n        if (Build.VERSION.SDK_INT < 21) {\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n        boolean firstEncode=true;\n        checkConversionCanceled();\n        while (!outputDone) {\n          checkConversionCanceled();\n          boolean decoderOutputAvailable=!decoderDone;\n          boolean encoderOutputAvailable=true;\n          while (decoderOutputAvailable || encoderOutputAvailable) {\n            checkConversionCanceled();\n            int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n            if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n              encoderOutputAvailable=false;\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n              if (Build.VERSION.SDK_INT < 21) {\n                encoderOutputBuffers=encoder.getOutputBuffers();\n              }\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n              MediaFormat newFormat=encoder.getOutputFormat();\n              if (BuildVars.LOGS_ENABLED) {\n                FileLog.d(\"photo encoder new format \" + newFormat);\n              }\n              if (videoTrackIndex == -5 && newFormat != null) {\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                  ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                  ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                  prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                }\n              }\n            }\n else             if (encoderStatus < 0) {\n              throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n            }\n else {\n              ByteBuffer encodedData;\n              if (Build.VERSION.SDK_INT < 21) {\n                encodedData=encoderOutputBuffers[encoderStatus];\n              }\n else {\n                encodedData=encoder.getOutputBuffer(encoderStatus);\n              }\n              if (encodedData == null) {\n                throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n              }\n              if (info.size > 1) {\n                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                  if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    info.offset+=prependHeaderSize;\n                    info.size-=prependHeaderSize;\n                  }\n                  if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    if (info.size > 100) {\n                      encodedData.position(info.offset);\n                      byte[] temp=new byte[100];\n                      encodedData.get(temp);\n                      int nalCount=0;\n                      for (int a=0; a < temp.length - 4; a++) {\n                        if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                          nalCount++;\n                          if (nalCount > 1) {\n                            info.offset+=a;\n                            info.size-=a;\n                            break;\n                          }\n                        }\n                      }\n                    }\n                    firstEncode=false;\n                  }\n                  long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n else                 if (videoTrackIndex == -5) {\n                  byte[] csd=new byte[info.size];\n                  encodedData.limit(info.offset + info.size);\n                  encodedData.position(info.offset);\n                  encodedData.get(csd);\n                  ByteBuffer sps=null;\n                  ByteBuffer pps=null;\n                  for (int a=info.size - 1; a >= 0; a--) {\n                    if (a > 3) {\n                      if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                        sps=ByteBuffer.allocate(a - 3);\n                        pps=ByteBuffer.allocate(info.size - (a - 3));\n                        sps.put(csd,0,a - 3).position(0);\n                        pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                        break;\n                      }\n                    }\n else {\n                      break;\n                    }\n                  }\n                  MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n                  if (sps != null && pps != null) {\n                    newFormat.setByteBuffer(\"csd-0\",sps);\n                    newFormat.setByteBuffer(\"csd-1\",pps);\n                  }\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                }\n              }\n              outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n              encoder.releaseOutputBuffer(encoderStatus,false);\n            }\n            if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n              continue;\n            }\n            if (!decoderDone) {\n              outputSurface.drawImage();\n              long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n              inputSurface.setPresentationTime(presentationTime);\n              inputSurface.swapBuffers();\n              framesCount++;\n              if (framesCount >= duration / 1000.0f * 30) {\n                decoderDone=true;\n                decoderOutputAvailable=false;\n                encoder.signalEndOfInputStream();\n              }\n            }\n          }\n        }\n      }\n catch (      Exception e) {\n        if (e instanceof IllegalStateException && !increaseTimeout) {\n          repeatWithIncreasedTimeout=true;\n        }\n        FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n        FileLog.e(e);\n        error=true;\n      }\n      if (outputSurface != null) {\n        outputSurface.release();\n      }\n      if (inputSurface != null) {\n        inputSurface.release();\n      }\n      if (encoder != null) {\n        encoder.stop();\n        encoder.release();\n      }\n      checkConversionCanceled();\n    }\n else {\n      extractor=new MediaExtractor();\n      extractor.setDataSource(videoPath);\n      int videoIndex=MediaController.findTrack(extractor,false);\n      int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n      boolean needConvertVideo=false;\n      if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n        needConvertVideo=true;\n      }\n      if (needCompress || needConvertVideo) {\n        AudioRecoder audioRecoder=null;\n        ByteBuffer audioBuffer=null;\n        boolean copyAudioBuffer=true;\n        if (videoIndex >= 0) {\n          MediaCodec decoder=null;\n          try {\n            long videoTime=-1;\n            boolean outputDone=false;\n            boolean inputDone=false;\n            boolean decoderDone=false;\n            int swapUV=0;\n            int audioTrackIndex=-5;\n            long additionalPresentationTime=0;\n            long minPresentationTime=Integer.MIN_VALUE;\n            long frameDelta=1000 / framerate * 1000;\n            extractor.selectTrack(videoIndex);\n            MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n            if (avatarStartTime >= 0) {\n              if (durationS <= 2000) {\n                bitrate=2600000;\n              }\n else               if (durationS <= 5000) {\n                bitrate=2200000;\n              }\n else {\n                bitrate=1560000;\n              }\n              avatarStartTime=0;\n            }\n else             if (bitrate <= 0) {\n              bitrate=921600;\n            }\n            if (originalBitrate > 0) {\n              bitrate=Math.min(originalBitrate,bitrate);\n            }\n            long trueStartTime;\n            if (avatarStartTime >= 0) {\n              avatarStartTime=-1;\n            }\n            if (avatarStartTime >= 0) {\n              extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else             if (startTime > 0) {\n              extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else {\n              extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n            int w;\n            int h;\n            if (cropState != null) {\n              if (rotationValue == 90 || rotationValue == 270) {\n                w=cropState.transformHeight;\n                h=cropState.transformWidth;\n              }\n else {\n                w=cropState.transformWidth;\n                h=cropState.transformHeight;\n              }\n            }\n else {\n              w=resultWidth;\n              h=resultHeight;\n            }\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n            }\n            MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n            outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n            outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n            outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n            outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n            if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n              if (bitrate > 921600) {\n                bitrate=921600;\n              }\n              outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n            }\n            encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n            encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n            inputSurface=new InputSurface(encoder.createInputSurface());\n            inputSurface.makeCurrent();\n            encoder.start();\n            decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n            outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n            decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n            decoder.start();\n            ByteBuffer[] decoderInputBuffers=null;\n            ByteBuffer[] encoderOutputBuffers=null;\n            ByteBuffer[] encoderInputBuffers=null;\n            if (Build.VERSION.SDK_INT < 21) {\n              decoderInputBuffers=decoder.getInputBuffers();\n              encoderOutputBuffers=encoder.getOutputBuffers();\n            }\n            if (audioIndex >= 0) {\n              MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n              copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n              if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n                audioIndex=-1;\n              }\n              if (audioIndex >= 0) {\n                if (copyAudioBuffer) {\n                  audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n                  extractor.selectTrack(audioIndex);\n                  int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n                  audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n                  if (startTime > 0) {\n                    extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                }\n else {\n                  MediaExtractor audioExtractor=new MediaExtractor();\n                  audioExtractor.setDataSource(videoPath);\n                  audioExtractor.selectTrack(audioIndex);\n                  if (startTime > 0) {\n                    audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                  audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n                  audioRecoder.startTime=startTime;\n                  audioRecoder.endTime=endTime;\n                  audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n                }\n              }\n            }\n            boolean audioEncoderDone=audioIndex < 0;\n            boolean firstEncode=true;\n            checkConversionCanceled();\n            while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n              checkConversionCanceled();\n              if (!copyAudioBuffer && audioRecoder != null) {\n                audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n              }\n              if (!inputDone) {\n                boolean eof=false;\n                int index=extractor.getSampleTrackIndex();\n                if (index == videoIndex) {\n                  int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (inputBufIndex >= 0) {\n                    ByteBuffer inputBuf;\n                    if (Build.VERSION.SDK_INT < 21) {\n                      inputBuf=decoderInputBuffers[inputBufIndex];\n                    }\n else {\n                      inputBuf=decoder.getInputBuffer(inputBufIndex);\n                    }\n                    int chunkSize=extractor.readSampleData(inputBuf,0);\n                    if (chunkSize < 0) {\n                      decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                      inputDone=true;\n                    }\n else {\n                      decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                      extractor.advance();\n                    }\n                  }\n                }\n else                 if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n                  info.size=extractor.readSampleData(audioBuffer,0);\n                  if (Build.VERSION.SDK_INT < 21) {\n                    audioBuffer.position(0);\n                    audioBuffer.limit(info.size);\n                  }\n                  if (info.size >= 0) {\n                    info.presentationTimeUs=extractor.getSampleTime();\n                    extractor.advance();\n                  }\n else {\n                    info.size=0;\n                    inputDone=true;\n                  }\n                  if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                    info.offset=0;\n                    info.flags=extractor.getSampleFlags();\n                    long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                    if (availableSize != 0) {\n                      if (callback != null) {\n                        if (info.presentationTimeUs - startTime > currentPts) {\n                          currentPts=info.presentationTimeUs - startTime;\n                        }\n                        callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                      }\n                    }\n                  }\n                }\n else                 if (index == -1) {\n                  eof=true;\n                }\n                if (eof) {\n                  int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (inputBufIndex >= 0) {\n                    decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                    inputDone=true;\n                  }\n                }\n              }\n              boolean decoderOutputAvailable=!decoderDone;\n              boolean encoderOutputAvailable=true;\n              while (decoderOutputAvailable || encoderOutputAvailable) {\n                checkConversionCanceled();\n                int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n                if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  encoderOutputAvailable=false;\n                }\n else                 if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                  if (Build.VERSION.SDK_INT < 21) {\n                    encoderOutputBuffers=encoder.getOutputBuffers();\n                  }\n                }\n else                 if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                  MediaFormat newFormat=encoder.getOutputFormat();\n                  if (videoTrackIndex == -5 && newFormat != null) {\n                    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                    if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                      ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                      ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                      prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                    }\n                  }\n                }\n else                 if (encoderStatus < 0) {\n                  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n                }\n else {\n                  ByteBuffer encodedData;\n                  if (Build.VERSION.SDK_INT < 21) {\n                    encodedData=encoderOutputBuffers[encoderStatus];\n                  }\n else {\n                    encodedData=encoder.getOutputBuffer(encoderStatus);\n                  }\n                  if (encodedData == null) {\n                    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n                  }\n                  if (info.size > 1) {\n                    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                        info.offset+=prependHeaderSize;\n                        info.size-=prependHeaderSize;\n                      }\n                      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                        if (info.size > 100) {\n                          encodedData.position(info.offset);\n                          byte[] temp=new byte[100];\n                          encodedData.get(temp);\n                          int nalCount=0;\n                          for (int a=0; a < temp.length - 4; a++) {\n                            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                              nalCount++;\n                              if (nalCount > 1) {\n                                info.offset+=a;\n                                info.size-=a;\n                                break;\n                              }\n                            }\n                          }\n                        }\n                        firstEncode=false;\n                      }\n                      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                      if (availableSize != 0) {\n                        if (callback != null) {\n                          if (info.presentationTimeUs - startTime > currentPts) {\n                            currentPts=info.presentationTimeUs - startTime;\n                          }\n                          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                        }\n                      }\n                    }\n else                     if (videoTrackIndex == -5) {\n                      byte[] csd=new byte[info.size];\n                      encodedData.limit(info.offset + info.size);\n                      encodedData.position(info.offset);\n                      encodedData.get(csd);\n                      ByteBuffer sps=null;\n                      ByteBuffer pps=null;\n                      for (int a=info.size - 1; a >= 0; a--) {\n                        if (a > 3) {\n                          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                            sps=ByteBuffer.allocate(a - 3);\n                            pps=ByteBuffer.allocate(info.size - (a - 3));\n                            sps.put(csd,0,a - 3).position(0);\n                            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                            break;\n                          }\n                        }\n else {\n                          break;\n                        }\n                      }\n                      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                      if (sps != null && pps != null) {\n                        newFormat.setByteBuffer(\"csd-0\",sps);\n                        newFormat.setByteBuffer(\"csd-1\",pps);\n                      }\n                      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                    }\n                  }\n                  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n                  encoder.releaseOutputBuffer(encoderStatus,false);\n                }\n                if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  continue;\n                }\n                if (!decoderDone) {\n                  int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                    decoderOutputAvailable=false;\n                  }\n else                   if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                  }\n else                   if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                    MediaFormat newFormat=decoder.getOutputFormat();\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"newFormat = \" + newFormat);\n                    }\n                  }\n else                   if (decoderStatus < 0) {\n                    throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n                  }\n else {\n                    boolean doRender=info.size != 0;\n                    long originalPresentationTime=info.presentationTimeUs;\n                    if (endTime > 0 && originalPresentationTime >= endTime) {\n                      inputDone=true;\n                      decoderDone=true;\n                      doRender=false;\n                      info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                    }\n                    boolean flushed=false;\n                    if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                      if (startTime > 0) {\n                        extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                      }\n else {\n                        extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                      }\n                      additionalPresentationTime=minPresentationTime + frameDelta;\n                      endTime=avatarStartTime;\n                      avatarStartTime=-1;\n                      inputDone=false;\n                      decoderDone=false;\n                      doRender=false;\n                      info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                      decoder.flush();\n                      flushed=true;\n                    }\n                    trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                    if (trueStartTime > 0 && videoTime == -1) {\n                      if (originalPresentationTime < trueStartTime) {\n                        doRender=false;\n                        if (BuildVars.LOGS_ENABLED) {\n                          FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                        }\n                      }\n else {\n                        videoTime=info.presentationTimeUs;\n                        if (minPresentationTime != Integer.MIN_VALUE) {\n                          additionalPresentationTime-=videoTime;\n                        }\n                      }\n                    }\n                    if (flushed) {\n                      videoTime=-1;\n                    }\n else {\n                      if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                        info.presentationTimeUs+=additionalPresentationTime;\n                      }\n                      decoder.releaseOutputBuffer(decoderStatus,doRender);\n                    }\n                    if (doRender) {\n                      if (avatarStartTime >= 0) {\n                        minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                      }\n                      boolean errorWait=false;\n                      try {\n                        outputSurface.awaitNewImage();\n                      }\n catch (                      Exception e) {\n                        errorWait=true;\n                        FileLog.e(e);\n                      }\n                      if (!errorWait) {\n                        outputSurface.drawImage();\n                        inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                        inputSurface.swapBuffers();\n                      }\n                    }\n                    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                      decoderOutputAvailable=false;\n                      if (BuildVars.LOGS_ENABLED) {\n                        FileLog.d(\"decoder stream end\");\n                      }\n                      encoder.signalEndOfInputStream();\n                    }\n                  }\n                }\n              }\n            }\n          }\n catch (          Exception e) {\n            if (e instanceof IllegalStateException && !increaseTimeout) {\n              repeatWithIncreasedTimeout=true;\n            }\n            FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n            FileLog.e(e);\n            error=true;\n          }\n          extractor.unselectTrack(videoIndex);\n          if (decoder != null) {\n            decoder.stop();\n            decoder.release();\n          }\n        }\n        if (outputSurface != null) {\n          outputSurface.release();\n        }\n        if (inputSurface != null) {\n          inputSurface.release();\n        }\n        if (encoder != null) {\n          encoder.stop();\n          encoder.release();\n        }\n        if (audioRecoder != null) {\n          audioRecoder.release();\n        }\n        checkConversionCanceled();\n      }\n else {\n        readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n      }\n    }\n  }\n catch (  Exception e) {\n    error=true;\n    FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n    FileLog.e(e);\n  }\n finally {\n    if (extractor != null) {\n      extractor.release();\n    }\n    if (mediaMuxer != null) {\n      try {\n        mediaMuxer.finishMovie();\n        endPresentationTime=mediaMuxer.getLastFrameTimestamp(videoTrackIndex);\n      }\n catch (      Exception e) {\n        FileLog.e(e);\n      }\n    }\n  }\n  if (repeatWithIncreasedTimeout) {\n    return convertVideoInternal(videoPath,cacheFile,rotationValue,isSecret,resultWidth,resultHeight,framerate,bitrate,originalBitrate,startTime,endTime,avatarStartTime,duration,needCompress,true,savedFilterState,paintPath,mediaEntities,isPhoto,cropState);\n  }\n  return error;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 3519,
      "astHeight" : 38
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 45602,
        "startLineNumber" : 59,
        "startColumnNumber" : 4,
        "endLineNumber" : 773,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@TargetApi(18) private boolean convertVideoInternal(String videoPath,File cacheFile,int rotationValue,boolean isSecret,int resultWidth,int resultHeight,int framerate,int bitrate,int originalBitrate,long startTime,long endTime,long avatarStartTime,long duration,boolean needCompress,boolean increaseTimeout,MediaController.SavedFilterState savedFilterState,String paintPath,ArrayList<VideoEditedInfo.MediaEntity> mediaEntities,boolean isPhoto,MediaController.CropState cropState){\n  boolean error=false;\n  boolean repeatWithIncreasedTimeout=false;\n  int videoTrackIndex=-5;\n  try {\n    MediaCodec.BufferInfo info=new MediaCodec.BufferInfo();\n    Mp4Movie movie=new Mp4Movie();\n    movie.setCacheFile(cacheFile);\n    movie.setRotation(0);\n    movie.setSize(resultWidth,resultHeight);\n    mediaMuxer=new MP4Builder().createMovie(movie,isSecret);\n    long currentPts=0;\n    float durationS=duration / 1000f;\n    MediaCodec encoder=null;\n    InputSurface inputSurface=null;\n    OutputSurface outputSurface=null;\n    int prependHeaderSize=0;\n    endPresentationTime=duration * 1000;\n    checkConversionCanceled();\n    if (isPhoto) {\n      try {\n        boolean outputDone=false;\n        boolean decoderDone=false;\n        int framesCount=0;\n        if (avatarStartTime >= 0) {\n          if (durationS <= 2000) {\n            bitrate=2600000;\n          }\n else           if (durationS <= 5000) {\n            bitrate=2200000;\n          }\n else {\n            bitrate=1560000;\n          }\n        }\n else         if (bitrate <= 0) {\n          bitrate=921600;\n        }\n        if (resultWidth % 16 != 0) {\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n          }\n          resultWidth=Math.round(resultWidth / 16.0f) * 16;\n        }\n        if (resultHeight % 16 != 0) {\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n          }\n          resultHeight=Math.round(resultHeight / 16.0f) * 16;\n        }\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n        }\n        MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n        encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n        encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n        inputSurface=new InputSurface(encoder.createInputSurface());\n        inputSurface.makeCurrent();\n        encoder.start();\n        outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n        ByteBuffer[] encoderOutputBuffers=null;\n        ByteBuffer[] encoderInputBuffers=null;\n        if (Build.VERSION.SDK_INT < 21) {\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n        boolean firstEncode=true;\n        checkConversionCanceled();\n        while (!outputDone) {\n          checkConversionCanceled();\n          boolean decoderOutputAvailable=!decoderDone;\n          boolean encoderOutputAvailable=true;\n          while (decoderOutputAvailable || encoderOutputAvailable) {\n            checkConversionCanceled();\n            int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n            if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n              encoderOutputAvailable=false;\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n              if (Build.VERSION.SDK_INT < 21) {\n                encoderOutputBuffers=encoder.getOutputBuffers();\n              }\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n              MediaFormat newFormat=encoder.getOutputFormat();\n              if (BuildVars.LOGS_ENABLED) {\n                FileLog.d(\"photo encoder new format \" + newFormat);\n              }\n              if (videoTrackIndex == -5 && newFormat != null) {\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                  ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                  ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                  prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                }\n              }\n            }\n else             if (encoderStatus < 0) {\n              throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n            }\n else {\n              ByteBuffer encodedData;\n              if (Build.VERSION.SDK_INT < 21) {\n                encodedData=encoderOutputBuffers[encoderStatus];\n              }\n else {\n                encodedData=encoder.getOutputBuffer(encoderStatus);\n              }\n              if (encodedData == null) {\n                throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n              }\n              if (info.size > 1) {\n                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                  if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    info.offset+=prependHeaderSize;\n                    info.size-=prependHeaderSize;\n                  }\n                  if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    if (info.size > 100) {\n                      encodedData.position(info.offset);\n                      byte[] temp=new byte[100];\n                      encodedData.get(temp);\n                      int nalCount=0;\n                      for (int a=0; a < temp.length - 4; a++) {\n                        if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                          nalCount++;\n                          if (nalCount > 1) {\n                            info.offset+=a;\n                            info.size-=a;\n                            break;\n                          }\n                        }\n                      }\n                    }\n                    firstEncode=false;\n                  }\n                  long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n else                 if (videoTrackIndex == -5) {\n                  byte[] csd=new byte[info.size];\n                  encodedData.limit(info.offset + info.size);\n                  encodedData.position(info.offset);\n                  encodedData.get(csd);\n                  ByteBuffer sps=null;\n                  ByteBuffer pps=null;\n                  for (int a=info.size - 1; a >= 0; a--) {\n                    if (a > 3) {\n                      if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                        sps=ByteBuffer.allocate(a - 3);\n                        pps=ByteBuffer.allocate(info.size - (a - 3));\n                        sps.put(csd,0,a - 3).position(0);\n                        pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                        break;\n                      }\n                    }\n else {\n                      break;\n                    }\n                  }\n                  MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n                  if (sps != null && pps != null) {\n                    newFormat.setByteBuffer(\"csd-0\",sps);\n                    newFormat.setByteBuffer(\"csd-1\",pps);\n                  }\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                }\n              }\n              outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n              encoder.releaseOutputBuffer(encoderStatus,false);\n            }\n            if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n              continue;\n            }\n            if (!decoderDone) {\n              outputSurface.drawImage();\n              long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n              inputSurface.setPresentationTime(presentationTime);\n              inputSurface.swapBuffers();\n              framesCount++;\n              if (framesCount >= duration / 1000.0f * 30) {\n                decoderDone=true;\n                decoderOutputAvailable=false;\n                encoder.signalEndOfInputStream();\n              }\n            }\n          }\n        }\n      }\n catch (      Exception e) {\n        if (e instanceof IllegalStateException && !increaseTimeout) {\n          repeatWithIncreasedTimeout=true;\n        }\n        FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n        FileLog.e(e);\n        error=true;\n      }\n      if (outputSurface != null) {\n        outputSurface.release();\n      }\n      if (inputSurface != null) {\n        inputSurface.release();\n      }\n      if (encoder != null) {\n        encoder.stop();\n        encoder.release();\n      }\n      checkConversionCanceled();\n    }\n else {\n      extractor=new MediaExtractor();\n      extractor.setDataSource(videoPath);\n      int videoIndex=MediaController.findTrack(extractor,false);\n      int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n      boolean needConvertVideo=false;\n      if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n        needConvertVideo=true;\n      }\n      if (needCompress || needConvertVideo) {\n        AudioRecoder audioRecoder=null;\n        ByteBuffer audioBuffer=null;\n        boolean copyAudioBuffer=true;\n        if (videoIndex >= 0) {\n          MediaCodec decoder=null;\n          try {\n            long videoTime=-1;\n            boolean outputDone=false;\n            boolean inputDone=false;\n            boolean decoderDone=false;\n            int swapUV=0;\n            int audioTrackIndex=-5;\n            long additionalPresentationTime=0;\n            long minPresentationTime=Integer.MIN_VALUE;\n            long frameDelta=1000 / framerate * 1000;\n            extractor.selectTrack(videoIndex);\n            MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n            if (avatarStartTime >= 0) {\n              if (durationS <= 2000) {\n                bitrate=2600000;\n              }\n else               if (durationS <= 5000) {\n                bitrate=2200000;\n              }\n else {\n                bitrate=1560000;\n              }\n              avatarStartTime=0;\n            }\n else             if (bitrate <= 0) {\n              bitrate=921600;\n            }\n            if (originalBitrate > 0) {\n              bitrate=Math.min(originalBitrate,bitrate);\n            }\n            long trueStartTime;\n            if (avatarStartTime >= 0) {\n              avatarStartTime=-1;\n            }\n            if (avatarStartTime >= 0) {\n              extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else             if (startTime > 0) {\n              extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else {\n              extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n            int w;\n            int h;\n            if (cropState != null) {\n              if (rotationValue == 90 || rotationValue == 270) {\n                w=cropState.transformHeight;\n                h=cropState.transformWidth;\n              }\n else {\n                w=cropState.transformWidth;\n                h=cropState.transformHeight;\n              }\n            }\n else {\n              w=resultWidth;\n              h=resultHeight;\n            }\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n            }\n            MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n            outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n            outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n            outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n            outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n            if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n              if (bitrate > 921600) {\n                bitrate=921600;\n              }\n              outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n            }\n            encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n            encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n            inputSurface=new InputSurface(encoder.createInputSurface());\n            inputSurface.makeCurrent();\n            encoder.start();\n            decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n            outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n            decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n            decoder.start();\n            ByteBuffer[] decoderInputBuffers=null;\n            ByteBuffer[] encoderOutputBuffers=null;\n            ByteBuffer[] encoderInputBuffers=null;\n            if (Build.VERSION.SDK_INT < 21) {\n              decoderInputBuffers=decoder.getInputBuffers();\n              encoderOutputBuffers=encoder.getOutputBuffers();\n            }\n            if (audioIndex >= 0) {\n              MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n              copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n              if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n                audioIndex=-1;\n              }\n              if (audioIndex >= 0) {\n                if (copyAudioBuffer) {\n                  audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n                  extractor.selectTrack(audioIndex);\n                  int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n                  audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n                  if (startTime > 0) {\n                    extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                }\n else {\n                  MediaExtractor audioExtractor=new MediaExtractor();\n                  audioExtractor.setDataSource(videoPath);\n                  audioExtractor.selectTrack(audioIndex);\n                  if (startTime > 0) {\n                    audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                  audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n                  audioRecoder.startTime=startTime;\n                  audioRecoder.endTime=endTime;\n                  audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n                }\n              }\n            }\n            boolean audioEncoderDone=audioIndex < 0;\n            boolean firstEncode=true;\n            checkConversionCanceled();\n            while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n              checkConversionCanceled();\n              if (!copyAudioBuffer && audioRecoder != null) {\n                audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n              }\n              if (!inputDone) {\n                boolean eof=false;\n                int index=extractor.getSampleTrackIndex();\n                if (index == videoIndex) {\n                  int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (inputBufIndex >= 0) {\n                    ByteBuffer inputBuf;\n                    if (Build.VERSION.SDK_INT < 21) {\n                      inputBuf=decoderInputBuffers[inputBufIndex];\n                    }\n else {\n                      inputBuf=decoder.getInputBuffer(inputBufIndex);\n                    }\n                    int chunkSize=extractor.readSampleData(inputBuf,0);\n                    if (chunkSize < 0) {\n                      decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                      inputDone=true;\n                    }\n else {\n                      decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                      extractor.advance();\n                    }\n                  }\n                }\n else                 if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n                  info.size=extractor.readSampleData(audioBuffer,0);\n                  if (Build.VERSION.SDK_INT < 21) {\n                    audioBuffer.position(0);\n                    audioBuffer.limit(info.size);\n                  }\n                  if (info.size >= 0) {\n                    info.presentationTimeUs=extractor.getSampleTime();\n                    extractor.advance();\n                  }\n else {\n                    info.size=0;\n                    inputDone=true;\n                  }\n                  if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                    info.offset=0;\n                    info.flags=extractor.getSampleFlags();\n                    long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                    if (availableSize != 0) {\n                      if (callback != null) {\n                        if (info.presentationTimeUs - startTime > currentPts) {\n                          currentPts=info.presentationTimeUs - startTime;\n                        }\n                        callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                      }\n                    }\n                  }\n                }\n else                 if (index == -1) {\n                  eof=true;\n                }\n                if (eof) {\n                  int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (inputBufIndex >= 0) {\n                    decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                    inputDone=true;\n                  }\n                }\n              }\n              boolean decoderOutputAvailable=!decoderDone;\n              boolean encoderOutputAvailable=true;\n              while (decoderOutputAvailable || encoderOutputAvailable) {\n                checkConversionCanceled();\n                int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n                if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  encoderOutputAvailable=false;\n                }\n else                 if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                  if (Build.VERSION.SDK_INT < 21) {\n                    encoderOutputBuffers=encoder.getOutputBuffers();\n                  }\n                }\n else                 if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                  MediaFormat newFormat=encoder.getOutputFormat();\n                  if (videoTrackIndex == -5 && newFormat != null) {\n                    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                    if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                      ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                      ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                      prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                    }\n                  }\n                }\n else                 if (encoderStatus < 0) {\n                  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n                }\n else {\n                  ByteBuffer encodedData;\n                  if (Build.VERSION.SDK_INT < 21) {\n                    encodedData=encoderOutputBuffers[encoderStatus];\n                  }\n else {\n                    encodedData=encoder.getOutputBuffer(encoderStatus);\n                  }\n                  if (encodedData == null) {\n                    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n                  }\n                  if (info.size > 1) {\n                    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                        info.offset+=prependHeaderSize;\n                        info.size-=prependHeaderSize;\n                      }\n                      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                        if (info.size > 100) {\n                          encodedData.position(info.offset);\n                          byte[] temp=new byte[100];\n                          encodedData.get(temp);\n                          int nalCount=0;\n                          for (int a=0; a < temp.length - 4; a++) {\n                            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                              nalCount++;\n                              if (nalCount > 1) {\n                                info.offset+=a;\n                                info.size-=a;\n                                break;\n                              }\n                            }\n                          }\n                        }\n                        firstEncode=false;\n                      }\n                      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                      if (availableSize != 0) {\n                        if (callback != null) {\n                          if (info.presentationTimeUs - startTime > currentPts) {\n                            currentPts=info.presentationTimeUs - startTime;\n                          }\n                          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                        }\n                      }\n                    }\n else                     if (videoTrackIndex == -5) {\n                      byte[] csd=new byte[info.size];\n                      encodedData.limit(info.offset + info.size);\n                      encodedData.position(info.offset);\n                      encodedData.get(csd);\n                      ByteBuffer sps=null;\n                      ByteBuffer pps=null;\n                      for (int a=info.size - 1; a >= 0; a--) {\n                        if (a > 3) {\n                          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                            sps=ByteBuffer.allocate(a - 3);\n                            pps=ByteBuffer.allocate(info.size - (a - 3));\n                            sps.put(csd,0,a - 3).position(0);\n                            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                            break;\n                          }\n                        }\n else {\n                          break;\n                        }\n                      }\n                      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                      if (sps != null && pps != null) {\n                        newFormat.setByteBuffer(\"csd-0\",sps);\n                        newFormat.setByteBuffer(\"csd-1\",pps);\n                      }\n                      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                    }\n                  }\n                  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n                  encoder.releaseOutputBuffer(encoderStatus,false);\n                }\n                if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  continue;\n                }\n                if (!decoderDone) {\n                  int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                    decoderOutputAvailable=false;\n                  }\n else                   if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                  }\n else                   if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                    MediaFormat newFormat=decoder.getOutputFormat();\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"newFormat = \" + newFormat);\n                    }\n                  }\n else                   if (decoderStatus < 0) {\n                    throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n                  }\n else {\n                    boolean doRender=info.size != 0;\n                    long originalPresentationTime=info.presentationTimeUs;\n                    if (endTime > 0 && originalPresentationTime >= endTime) {\n                      inputDone=true;\n                      decoderDone=true;\n                      doRender=false;\n                      info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                    }\n                    boolean flushed=false;\n                    if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                      if (startTime > 0) {\n                        extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                      }\n else {\n                        extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                      }\n                      additionalPresentationTime=minPresentationTime + frameDelta;\n                      endTime=avatarStartTime;\n                      avatarStartTime=-1;\n                      inputDone=false;\n                      decoderDone=false;\n                      doRender=false;\n                      info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                      decoder.flush();\n                      flushed=true;\n                    }\n                    trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                    if (trueStartTime > 0 && videoTime == -1) {\n                      if (originalPresentationTime < trueStartTime) {\n                        doRender=false;\n                        if (BuildVars.LOGS_ENABLED) {\n                          FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                        }\n                      }\n else {\n                        videoTime=info.presentationTimeUs;\n                        if (minPresentationTime != Integer.MIN_VALUE) {\n                          additionalPresentationTime-=videoTime;\n                        }\n                      }\n                    }\n                    if (flushed) {\n                      videoTime=-1;\n                    }\n else {\n                      if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                        info.presentationTimeUs+=additionalPresentationTime;\n                      }\n                      decoder.releaseOutputBuffer(decoderStatus,doRender);\n                    }\n                    if (doRender) {\n                      if (avatarStartTime >= 0) {\n                        minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                      }\n                      boolean errorWait=false;\n                      try {\n                        outputSurface.awaitNewImage();\n                      }\n catch (                      Exception e) {\n                        errorWait=true;\n                        FileLog.e(e);\n                      }\n                      if (!errorWait) {\n                        outputSurface.drawImage();\n                        inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                        inputSurface.swapBuffers();\n                      }\n                    }\n                    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                      decoderOutputAvailable=false;\n                      if (BuildVars.LOGS_ENABLED) {\n                        FileLog.d(\"decoder stream end\");\n                      }\n                      encoder.signalEndOfInputStream();\n                    }\n                  }\n                }\n              }\n            }\n          }\n catch (          Exception e) {\n            if (e instanceof IllegalStateException && !increaseTimeout) {\n              repeatWithIncreasedTimeout=true;\n            }\n            FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n            FileLog.e(e);\n            error=true;\n          }\n          extractor.unselectTrack(videoIndex);\n          if (decoder != null) {\n            decoder.stop();\n            decoder.release();\n          }\n        }\n        if (outputSurface != null) {\n          outputSurface.release();\n        }\n        if (inputSurface != null) {\n          inputSurface.release();\n        }\n        if (encoder != null) {\n          encoder.stop();\n          encoder.release();\n        }\n        if (audioRecoder != null) {\n          audioRecoder.release();\n        }\n        checkConversionCanceled();\n      }\n else {\n        readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n      }\n    }\n  }\n catch (  Exception e) {\n    error=true;\n    FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n    FileLog.e(e);\n  }\n finally {\n    if (extractor != null) {\n      extractor.release();\n    }\n    if (mediaMuxer != null) {\n      try {\n        mediaMuxer.finishMovie();\n        endPresentationTime=mediaMuxer.getLastFrameTimestamp(videoTrackIndex);\n      }\n catch (      Exception e) {\n        FileLog.e(e);\n      }\n    }\n  }\n  if (repeatWithIncreasedTimeout) {\n    return convertVideoInternal(videoPath,cacheFile,rotationValue,isSecret,resultWidth,resultHeight,framerate,bitrate,originalBitrate,startTime,endTime,avatarStartTime,duration,needCompress,true,savedFilterState,paintPath,mediaEntities,isPhoto,cropState);\n  }\n  return error;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 3601,
      "astHeight" : 39
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 190,
        "startColumnNumber" : 36,
        "endLineNumber" : 190,
        "endColumnNumber" : 117
      },
      "nodeContext" : "throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n",
      "nodeType" : "ThrowStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  }, {
    "nodeContext" : "\"encoderOutputBuffer \"",
    "nodeType" : "StringLiteral",
    "nodePosition" : {
      "charLength" : 22,
      "startLineNumber" : 550,
      "startColumnNumber" : 71,
      "endLineNumber" : 550,
      "endColumnNumber" : 93
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 550,
        "startColumnNumber" : 71,
        "endLineNumber" : 550,
        "endColumnNumber" : 123
      },
      "nodeContext" : "\"encoderOutputBuffer \" + encoderStatus + \" was null\"",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ThrowStatement,expression]",
      "nodePosition" : {
        "charLength" : 74,
        "startLineNumber" : 550,
        "startColumnNumber" : 50,
        "endLineNumber" : 550,
        "endColumnNumber" : 124
      },
      "nodeContext" : "new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\")",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 550,
        "startColumnNumber" : 44,
        "endLineNumber" : 550,
        "endColumnNumber" : 125
      },
      "nodeContext" : "throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n",
      "nodeType" : "ThrowStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 169,
        "startLineNumber" : 549,
        "startColumnNumber" : 65,
        "endLineNumber" : 551,
        "endColumnNumber" : 41
      },
      "nodeContext" : "{\n  throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 9,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 194,
        "startLineNumber" : 549,
        "startColumnNumber" : 40,
        "endLineNumber" : 551,
        "endColumnNumber" : 41
      },
      "nodeContext" : "if (encodedData == null) {\n  throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 13,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 6008,
        "startLineNumber" : 542,
        "startColumnNumber" : 43,
        "endLineNumber" : 617,
        "endColumnNumber" : 37
      },
      "nodeContext" : "{\n  ByteBuffer encodedData;\n  if (Build.VERSION.SDK_INT < 21) {\n    encodedData=encoderOutputBuffers[encoderStatus];\n  }\n else {\n    encodedData=encoder.getOutputBuffer(encoderStatus);\n  }\n  if (encodedData == null) {\n    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n  }\n  if (info.size > 1) {\n    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        info.offset+=prependHeaderSize;\n        info.size-=prependHeaderSize;\n      }\n      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        if (info.size > 100) {\n          encodedData.position(info.offset);\n          byte[] temp=new byte[100];\n          encodedData.get(temp);\n          int nalCount=0;\n          for (int a=0; a < temp.length - 4; a++) {\n            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n              nalCount++;\n              if (nalCount > 1) {\n                info.offset+=a;\n                info.size-=a;\n                break;\n              }\n            }\n          }\n        }\n        firstEncode=false;\n      }\n      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n      if (availableSize != 0) {\n        if (callback != null) {\n          if (info.presentationTimeUs - startTime > currentPts) {\n            currentPts=info.presentationTimeUs - startTime;\n          }\n          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n        }\n      }\n    }\n else     if (videoTrackIndex == -5) {\n      byte[] csd=new byte[info.size];\n      encodedData.limit(info.offset + info.size);\n      encodedData.position(info.offset);\n      encodedData.get(csd);\n      ByteBuffer sps=null;\n      ByteBuffer pps=null;\n      for (int a=info.size - 1; a >= 0; a--) {\n        if (a > 3) {\n          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n            sps=ByteBuffer.allocate(a - 3);\n            pps=ByteBuffer.allocate(info.size - (a - 3));\n            sps.put(csd,0,a - 3).position(0);\n            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n            break;\n          }\n        }\n else {\n          break;\n        }\n      }\n      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n      if (sps != null && pps != null) {\n        newFormat.setByteBuffer(\"csd-0\",sps);\n        newFormat.setByteBuffer(\"csd-1\",pps);\n      }\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    }\n  }\n  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n  encoder.releaseOutputBuffer(encoderStatus,false);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 483,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 6216,
        "startLineNumber" : 540,
        "startColumnNumber" : 43,
        "endLineNumber" : 617,
        "endColumnNumber" : 37
      },
      "nodeContext" : "if (encoderStatus < 0) {\n  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n}\n else {\n  ByteBuffer encodedData;\n  if (Build.VERSION.SDK_INT < 21) {\n    encodedData=encoderOutputBuffers[encoderStatus];\n  }\n else {\n    encodedData=encoder.getOutputBuffer(encoderStatus);\n  }\n  if (encodedData == null) {\n    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n  }\n  if (info.size > 1) {\n    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        info.offset+=prependHeaderSize;\n        info.size-=prependHeaderSize;\n      }\n      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        if (info.size > 100) {\n          encodedData.position(info.offset);\n          byte[] temp=new byte[100];\n          encodedData.get(temp);\n          int nalCount=0;\n          for (int a=0; a < temp.length - 4; a++) {\n            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n              nalCount++;\n              if (nalCount > 1) {\n                info.offset+=a;\n                info.size-=a;\n                break;\n              }\n            }\n          }\n        }\n        firstEncode=false;\n      }\n      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n      if (availableSize != 0) {\n        if (callback != null) {\n          if (info.presentationTimeUs - startTime > currentPts) {\n            currentPts=info.presentationTimeUs - startTime;\n          }\n          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n        }\n      }\n    }\n else     if (videoTrackIndex == -5) {\n      byte[] csd=new byte[info.size];\n      encodedData.limit(info.offset + info.size);\n      encodedData.position(info.offset);\n      encodedData.get(csd);\n      ByteBuffer sps=null;\n      ByteBuffer pps=null;\n      for (int a=info.size - 1; a >= 0; a--) {\n        if (a > 3) {\n          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n            sps=ByteBuffer.allocate(a - 3);\n            pps=ByteBuffer.allocate(info.size - (a - 3));\n            sps.put(csd,0,a - 3).position(0);\n            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n            break;\n          }\n        }\n else {\n          break;\n        }\n      }\n      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n      if (sps != null && pps != null) {\n        newFormat.setByteBuffer(\"csd-0\",sps);\n        newFormat.setByteBuffer(\"csd-1\",pps);\n      }\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    }\n  }\n  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n  encoder.releaseOutputBuffer(encoderStatus,false);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 495,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 7196,
        "startLineNumber" : 530,
        "startColumnNumber" : 43,
        "endLineNumber" : 617,
        "endColumnNumber" : 37
      },
      "nodeContext" : "if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n  MediaFormat newFormat=encoder.getOutputFormat();\n  if (videoTrackIndex == -5 && newFormat != null) {\n    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n      ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n      ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n      prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n    }\n  }\n}\n else if (encoderStatus < 0) {\n  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n}\n else {\n  ByteBuffer encodedData;\n  if (Build.VERSION.SDK_INT < 21) {\n    encodedData=encoderOutputBuffers[encoderStatus];\n  }\n else {\n    encodedData=encoder.getOutputBuffer(encoderStatus);\n  }\n  if (encodedData == null) {\n    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n  }\n  if (info.size > 1) {\n    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        info.offset+=prependHeaderSize;\n        info.size-=prependHeaderSize;\n      }\n      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        if (info.size > 100) {\n          encodedData.position(info.offset);\n          byte[] temp=new byte[100];\n          encodedData.get(temp);\n          int nalCount=0;\n          for (int a=0; a < temp.length - 4; a++) {\n            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n              nalCount++;\n              if (nalCount > 1) {\n                info.offset+=a;\n                info.size-=a;\n                break;\n              }\n            }\n          }\n        }\n        firstEncode=false;\n      }\n      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n      if (availableSize != 0) {\n        if (callback != null) {\n          if (info.presentationTimeUs - startTime > currentPts) {\n            currentPts=info.presentationTimeUs - startTime;\n          }\n          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n        }\n      }\n    }\n else     if (videoTrackIndex == -5) {\n      byte[] csd=new byte[info.size];\n      encodedData.limit(info.offset + info.size);\n      encodedData.position(info.offset);\n      encodedData.get(csd);\n      ByteBuffer sps=null;\n      ByteBuffer pps=null;\n      for (int a=info.size - 1; a >= 0; a--) {\n        if (a > 3) {\n          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n            sps=ByteBuffer.allocate(a - 3);\n            pps=ByteBuffer.allocate(info.size - (a - 3));\n            sps.put(csd,0,a - 3).position(0);\n            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n            break;\n          }\n        }\n else {\n          break;\n        }\n      }\n      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n      if (sps != null && pps != null) {\n        newFormat.setByteBuffer(\"csd-0\",sps);\n        newFormat.setByteBuffer(\"csd-1\",pps);\n      }\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    }\n  }\n  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n  encoder.releaseOutputBuffer(encoderStatus,false);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 573,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 7513,
        "startLineNumber" : 526,
        "startColumnNumber" : 43,
        "endLineNumber" : 617,
        "endColumnNumber" : 37
      },
      "nodeContext" : "if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n  if (Build.VERSION.SDK_INT < 21) {\n    encoderOutputBuffers=encoder.getOutputBuffers();\n  }\n}\n else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n  MediaFormat newFormat=encoder.getOutputFormat();\n  if (videoTrackIndex == -5 && newFormat != null) {\n    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n      ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n      ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n      prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n    }\n  }\n}\n else if (encoderStatus < 0) {\n  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n}\n else {\n  ByteBuffer encodedData;\n  if (Build.VERSION.SDK_INT < 21) {\n    encodedData=encoderOutputBuffers[encoderStatus];\n  }\n else {\n    encodedData=encoder.getOutputBuffer(encoderStatus);\n  }\n  if (encodedData == null) {\n    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n  }\n  if (info.size > 1) {\n    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        info.offset+=prependHeaderSize;\n        info.size-=prependHeaderSize;\n      }\n      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        if (info.size > 100) {\n          encodedData.position(info.offset);\n          byte[] temp=new byte[100];\n          encodedData.get(temp);\n          int nalCount=0;\n          for (int a=0; a < temp.length - 4; a++) {\n            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n              nalCount++;\n              if (nalCount > 1) {\n                info.offset+=a;\n                info.size-=a;\n                break;\n              }\n            }\n          }\n        }\n        firstEncode=false;\n      }\n      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n      if (availableSize != 0) {\n        if (callback != null) {\n          if (info.presentationTimeUs - startTime > currentPts) {\n            currentPts=info.presentationTimeUs - startTime;\n          }\n          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n        }\n      }\n    }\n else     if (videoTrackIndex == -5) {\n      byte[] csd=new byte[info.size];\n      encodedData.limit(info.offset + info.size);\n      encodedData.position(info.offset);\n      encodedData.get(csd);\n      ByteBuffer sps=null;\n      ByteBuffer pps=null;\n      for (int a=info.size - 1; a >= 0; a--) {\n        if (a > 3) {\n          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n            sps=ByteBuffer.allocate(a - 3);\n            pps=ByteBuffer.allocate(info.size - (a - 3));\n            sps.put(csd,0,a - 3).position(0);\n            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n            break;\n          }\n        }\n else {\n          break;\n        }\n      }\n      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n      if (sps != null && pps != null) {\n        newFormat.setByteBuffer(\"csd-0\",sps);\n        newFormat.setByteBuffer(\"csd-1\",pps);\n      }\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    }\n  }\n  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n  encoder.releaseOutputBuffer(encoderStatus,false);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 595,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 7684,
        "startLineNumber" : 524,
        "startColumnNumber" : 36,
        "endLineNumber" : 617,
        "endColumnNumber" : 37
      },
      "nodeContext" : "if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n  encoderOutputAvailable=false;\n}\n else if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n  if (Build.VERSION.SDK_INT < 21) {\n    encoderOutputBuffers=encoder.getOutputBuffers();\n  }\n}\n else if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n  MediaFormat newFormat=encoder.getOutputFormat();\n  if (videoTrackIndex == -5 && newFormat != null) {\n    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n      ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n      ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n      prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n    }\n  }\n}\n else if (encoderStatus < 0) {\n  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n}\n else {\n  ByteBuffer encodedData;\n  if (Build.VERSION.SDK_INT < 21) {\n    encodedData=encoderOutputBuffers[encoderStatus];\n  }\n else {\n    encodedData=encoder.getOutputBuffer(encoderStatus);\n  }\n  if (encodedData == null) {\n    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n  }\n  if (info.size > 1) {\n    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        info.offset+=prependHeaderSize;\n        info.size-=prependHeaderSize;\n      }\n      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n        if (info.size > 100) {\n          encodedData.position(info.offset);\n          byte[] temp=new byte[100];\n          encodedData.get(temp);\n          int nalCount=0;\n          for (int a=0; a < temp.length - 4; a++) {\n            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n              nalCount++;\n              if (nalCount > 1) {\n                info.offset+=a;\n                info.size-=a;\n                break;\n              }\n            }\n          }\n        }\n        firstEncode=false;\n      }\n      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n      if (availableSize != 0) {\n        if (callback != null) {\n          if (info.presentationTimeUs - startTime > currentPts) {\n            currentPts=info.presentationTimeUs - startTime;\n          }\n          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n        }\n      }\n    }\n else     if (videoTrackIndex == -5) {\n      byte[] csd=new byte[info.size];\n      encodedData.limit(info.offset + info.size);\n      encodedData.position(info.offset);\n      encodedData.get(csd);\n      ByteBuffer sps=null;\n      ByteBuffer pps=null;\n      for (int a=info.size - 1; a >= 0; a--) {\n        if (a > 3) {\n          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n            sps=ByteBuffer.allocate(a - 3);\n            pps=ByteBuffer.allocate(info.size - (a - 3));\n            sps.put(csd,0,a - 3).position(0);\n            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n            break;\n          }\n        }\n else {\n          break;\n        }\n      }\n      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n      if (sps != null && pps != null) {\n        newFormat.setByteBuffer(\"csd-0\",sps);\n        newFormat.setByteBuffer(\"csd-1\",pps);\n      }\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n    }\n  }\n  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n  encoder.releaseOutputBuffer(encoderStatus,false);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 606,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 14917,
        "startLineNumber" : 521,
        "startColumnNumber" : 89,
        "endLineNumber" : 709,
        "endColumnNumber" : 33
      },
      "nodeContext" : "{\n  checkConversionCanceled();\n  int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n  if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n    encoderOutputAvailable=false;\n  }\n else   if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n    if (Build.VERSION.SDK_INT < 21) {\n      encoderOutputBuffers=encoder.getOutputBuffers();\n    }\n  }\n else   if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n    MediaFormat newFormat=encoder.getOutputFormat();\n    if (videoTrackIndex == -5 && newFormat != null) {\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n      if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n        ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n        ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n        prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n      }\n    }\n  }\n else   if (encoderStatus < 0) {\n    throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n  }\n else {\n    ByteBuffer encodedData;\n    if (Build.VERSION.SDK_INT < 21) {\n      encodedData=encoderOutputBuffers[encoderStatus];\n    }\n else {\n      encodedData=encoder.getOutputBuffer(encoderStatus);\n    }\n    if (encodedData == null) {\n      throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n    }\n    if (info.size > 1) {\n      if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n        if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n          info.offset+=prependHeaderSize;\n          info.size-=prependHeaderSize;\n        }\n        if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n          if (info.size > 100) {\n            encodedData.position(info.offset);\n            byte[] temp=new byte[100];\n            encodedData.get(temp);\n            int nalCount=0;\n            for (int a=0; a < temp.length - 4; a++) {\n              if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                nalCount++;\n                if (nalCount > 1) {\n                  info.offset+=a;\n                  info.size-=a;\n                  break;\n                }\n              }\n            }\n          }\n          firstEncode=false;\n        }\n        long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n        if (availableSize != 0) {\n          if (callback != null) {\n            if (info.presentationTimeUs - startTime > currentPts) {\n              currentPts=info.presentationTimeUs - startTime;\n            }\n            callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n          }\n        }\n      }\n else       if (videoTrackIndex == -5) {\n        byte[] csd=new byte[info.size];\n        encodedData.limit(info.offset + info.size);\n        encodedData.position(info.offset);\n        encodedData.get(csd);\n        ByteBuffer sps=null;\n        ByteBuffer pps=null;\n        for (int a=info.size - 1; a >= 0; a--) {\n          if (a > 3) {\n            if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n              sps=ByteBuffer.allocate(a - 3);\n              pps=ByteBuffer.allocate(info.size - (a - 3));\n              sps.put(csd,0,a - 3).position(0);\n              pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n              break;\n            }\n          }\n else {\n            break;\n          }\n        }\n        MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n        if (sps != null && pps != null) {\n          newFormat.setByteBuffer(\"csd-0\",sps);\n          newFormat.setByteBuffer(\"csd-1\",pps);\n        }\n        videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n      }\n    }\n    outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n    encoder.releaseOutputBuffer(encoderStatus,false);\n  }\n  if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n    continue;\n  }\n  if (!decoderDone) {\n    int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n    if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n      decoderOutputAvailable=false;\n    }\n else     if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n    }\n else     if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n      MediaFormat newFormat=decoder.getOutputFormat();\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"newFormat = \" + newFormat);\n      }\n    }\n else     if (decoderStatus < 0) {\n      throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n    }\n else {\n      boolean doRender=info.size != 0;\n      long originalPresentationTime=info.presentationTimeUs;\n      if (endTime > 0 && originalPresentationTime >= endTime) {\n        inputDone=true;\n        decoderDone=true;\n        doRender=false;\n        info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n      }\n      boolean flushed=false;\n      if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n        if (startTime > 0) {\n          extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else {\n          extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n        additionalPresentationTime=minPresentationTime + frameDelta;\n        endTime=avatarStartTime;\n        avatarStartTime=-1;\n        inputDone=false;\n        decoderDone=false;\n        doRender=false;\n        info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n        decoder.flush();\n        flushed=true;\n      }\n      trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n      if (trueStartTime > 0 && videoTime == -1) {\n        if (originalPresentationTime < trueStartTime) {\n          doRender=false;\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n          }\n        }\n else {\n          videoTime=info.presentationTimeUs;\n          if (minPresentationTime != Integer.MIN_VALUE) {\n            additionalPresentationTime-=videoTime;\n          }\n        }\n      }\n      if (flushed) {\n        videoTime=-1;\n      }\n else {\n        if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n          info.presentationTimeUs+=additionalPresentationTime;\n        }\n        decoder.releaseOutputBuffer(decoderStatus,doRender);\n      }\n      if (doRender) {\n        if (avatarStartTime >= 0) {\n          minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n        }\n        boolean errorWait=false;\n        try {\n          outputSurface.awaitNewImage();\n        }\n catch (        Exception e) {\n          errorWait=true;\n          FileLog.e(e);\n        }\n        if (!errorWait) {\n          outputSurface.drawImage();\n          inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n          inputSurface.swapBuffers();\n        }\n      }\n      if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n        decoderOutputAvailable=false;\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"decoder stream end\");\n        }\n        encoder.signalEndOfInputStream();\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1032,
      "astHeight" : 24
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 14974,
        "startLineNumber" : 521,
        "startColumnNumber" : 32,
        "endLineNumber" : 709,
        "endColumnNumber" : 33
      },
      "nodeContext" : "while (decoderOutputAvailable || encoderOutputAvailable) {\n  checkConversionCanceled();\n  int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n  if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n    encoderOutputAvailable=false;\n  }\n else   if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n    if (Build.VERSION.SDK_INT < 21) {\n      encoderOutputBuffers=encoder.getOutputBuffers();\n    }\n  }\n else   if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n    MediaFormat newFormat=encoder.getOutputFormat();\n    if (videoTrackIndex == -5 && newFormat != null) {\n      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n      if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n        ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n        ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n        prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n      }\n    }\n  }\n else   if (encoderStatus < 0) {\n    throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n  }\n else {\n    ByteBuffer encodedData;\n    if (Build.VERSION.SDK_INT < 21) {\n      encodedData=encoderOutputBuffers[encoderStatus];\n    }\n else {\n      encodedData=encoder.getOutputBuffer(encoderStatus);\n    }\n    if (encodedData == null) {\n      throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n    }\n    if (info.size > 1) {\n      if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n        if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n          info.offset+=prependHeaderSize;\n          info.size-=prependHeaderSize;\n        }\n        if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n          if (info.size > 100) {\n            encodedData.position(info.offset);\n            byte[] temp=new byte[100];\n            encodedData.get(temp);\n            int nalCount=0;\n            for (int a=0; a < temp.length - 4; a++) {\n              if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                nalCount++;\n                if (nalCount > 1) {\n                  info.offset+=a;\n                  info.size-=a;\n                  break;\n                }\n              }\n            }\n          }\n          firstEncode=false;\n        }\n        long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n        if (availableSize != 0) {\n          if (callback != null) {\n            if (info.presentationTimeUs - startTime > currentPts) {\n              currentPts=info.presentationTimeUs - startTime;\n            }\n            callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n          }\n        }\n      }\n else       if (videoTrackIndex == -5) {\n        byte[] csd=new byte[info.size];\n        encodedData.limit(info.offset + info.size);\n        encodedData.position(info.offset);\n        encodedData.get(csd);\n        ByteBuffer sps=null;\n        ByteBuffer pps=null;\n        for (int a=info.size - 1; a >= 0; a--) {\n          if (a > 3) {\n            if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n              sps=ByteBuffer.allocate(a - 3);\n              pps=ByteBuffer.allocate(info.size - (a - 3));\n              sps.put(csd,0,a - 3).position(0);\n              pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n              break;\n            }\n          }\n else {\n            break;\n          }\n        }\n        MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n        if (sps != null && pps != null) {\n          newFormat.setByteBuffer(\"csd-0\",sps);\n          newFormat.setByteBuffer(\"csd-1\",pps);\n        }\n        videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n      }\n    }\n    outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n    encoder.releaseOutputBuffer(encoderStatus,false);\n  }\n  if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n    continue;\n  }\n  if (!decoderDone) {\n    int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n    if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n      decoderOutputAvailable=false;\n    }\n else     if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n    }\n else     if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n      MediaFormat newFormat=decoder.getOutputFormat();\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"newFormat = \" + newFormat);\n      }\n    }\n else     if (decoderStatus < 0) {\n      throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n    }\n else {\n      boolean doRender=info.size != 0;\n      long originalPresentationTime=info.presentationTimeUs;\n      if (endTime > 0 && originalPresentationTime >= endTime) {\n        inputDone=true;\n        decoderDone=true;\n        doRender=false;\n        info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n      }\n      boolean flushed=false;\n      if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n        if (startTime > 0) {\n          extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else {\n          extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n        additionalPresentationTime=minPresentationTime + frameDelta;\n        endTime=avatarStartTime;\n        avatarStartTime=-1;\n        inputDone=false;\n        decoderDone=false;\n        doRender=false;\n        info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n        decoder.flush();\n        flushed=true;\n      }\n      trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n      if (trueStartTime > 0 && videoTime == -1) {\n        if (originalPresentationTime < trueStartTime) {\n          doRender=false;\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n          }\n        }\n else {\n          videoTime=info.presentationTimeUs;\n          if (minPresentationTime != Integer.MIN_VALUE) {\n            additionalPresentationTime-=videoTime;\n          }\n        }\n      }\n      if (flushed) {\n        videoTime=-1;\n      }\n else {\n        if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n          info.presentationTimeUs+=additionalPresentationTime;\n        }\n        decoder.releaseOutputBuffer(decoderStatus,doRender);\n      }\n      if (doRender) {\n        if (avatarStartTime >= 0) {\n          minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n        }\n        boolean errorWait=false;\n        try {\n          outputSurface.awaitNewImage();\n        }\n catch (        Exception e) {\n          errorWait=true;\n          FileLog.e(e);\n        }\n        if (!errorWait) {\n          outputSurface.drawImage();\n          inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n          inputSurface.swapBuffers();\n        }\n      }\n      if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n        decoderOutputAvailable=false;\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"decoder stream end\");\n        }\n        encoder.signalEndOfInputStream();\n      }\n    }\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 1036,
      "astHeight" : 25
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 19702,
        "startLineNumber" : 453,
        "startColumnNumber" : 91,
        "endLineNumber" : 710,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  checkConversionCanceled();\n  if (!copyAudioBuffer && audioRecoder != null) {\n    audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n  }\n  if (!inputDone) {\n    boolean eof=false;\n    int index=extractor.getSampleTrackIndex();\n    if (index == videoIndex) {\n      int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n      if (inputBufIndex >= 0) {\n        ByteBuffer inputBuf;\n        if (Build.VERSION.SDK_INT < 21) {\n          inputBuf=decoderInputBuffers[inputBufIndex];\n        }\n else {\n          inputBuf=decoder.getInputBuffer(inputBufIndex);\n        }\n        int chunkSize=extractor.readSampleData(inputBuf,0);\n        if (chunkSize < 0) {\n          decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n          inputDone=true;\n        }\n else {\n          decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n          extractor.advance();\n        }\n      }\n    }\n else     if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n      info.size=extractor.readSampleData(audioBuffer,0);\n      if (Build.VERSION.SDK_INT < 21) {\n        audioBuffer.position(0);\n        audioBuffer.limit(info.size);\n      }\n      if (info.size >= 0) {\n        info.presentationTimeUs=extractor.getSampleTime();\n        extractor.advance();\n      }\n else {\n        info.size=0;\n        inputDone=true;\n      }\n      if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n        info.offset=0;\n        info.flags=extractor.getSampleFlags();\n        long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n        if (availableSize != 0) {\n          if (callback != null) {\n            if (info.presentationTimeUs - startTime > currentPts) {\n              currentPts=info.presentationTimeUs - startTime;\n            }\n            callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n          }\n        }\n      }\n    }\n else     if (index == -1) {\n      eof=true;\n    }\n    if (eof) {\n      int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n      if (inputBufIndex >= 0) {\n        decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n        inputDone=true;\n      }\n    }\n  }\n  boolean decoderOutputAvailable=!decoderDone;\n  boolean encoderOutputAvailable=true;\n  while (decoderOutputAvailable || encoderOutputAvailable) {\n    checkConversionCanceled();\n    int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n    if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n      encoderOutputAvailable=false;\n    }\n else     if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n      if (Build.VERSION.SDK_INT < 21) {\n        encoderOutputBuffers=encoder.getOutputBuffers();\n      }\n    }\n else     if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n      MediaFormat newFormat=encoder.getOutputFormat();\n      if (videoTrackIndex == -5 && newFormat != null) {\n        videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n        if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n          ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n          ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n          prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n        }\n      }\n    }\n else     if (encoderStatus < 0) {\n      throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n    }\n else {\n      ByteBuffer encodedData;\n      if (Build.VERSION.SDK_INT < 21) {\n        encodedData=encoderOutputBuffers[encoderStatus];\n      }\n else {\n        encodedData=encoder.getOutputBuffer(encoderStatus);\n      }\n      if (encodedData == null) {\n        throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n      }\n      if (info.size > 1) {\n        if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n          if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n            info.offset+=prependHeaderSize;\n            info.size-=prependHeaderSize;\n          }\n          if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n            if (info.size > 100) {\n              encodedData.position(info.offset);\n              byte[] temp=new byte[100];\n              encodedData.get(temp);\n              int nalCount=0;\n              for (int a=0; a < temp.length - 4; a++) {\n                if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                  nalCount++;\n                  if (nalCount > 1) {\n                    info.offset+=a;\n                    info.size-=a;\n                    break;\n                  }\n                }\n              }\n            }\n            firstEncode=false;\n          }\n          long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n          if (availableSize != 0) {\n            if (callback != null) {\n              if (info.presentationTimeUs - startTime > currentPts) {\n                currentPts=info.presentationTimeUs - startTime;\n              }\n              callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n            }\n          }\n        }\n else         if (videoTrackIndex == -5) {\n          byte[] csd=new byte[info.size];\n          encodedData.limit(info.offset + info.size);\n          encodedData.position(info.offset);\n          encodedData.get(csd);\n          ByteBuffer sps=null;\n          ByteBuffer pps=null;\n          for (int a=info.size - 1; a >= 0; a--) {\n            if (a > 3) {\n              if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                sps=ByteBuffer.allocate(a - 3);\n                pps=ByteBuffer.allocate(info.size - (a - 3));\n                sps.put(csd,0,a - 3).position(0);\n                pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                break;\n              }\n            }\n else {\n              break;\n            }\n          }\n          MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n          if (sps != null && pps != null) {\n            newFormat.setByteBuffer(\"csd-0\",sps);\n            newFormat.setByteBuffer(\"csd-1\",pps);\n          }\n          videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n        }\n      }\n      outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n      encoder.releaseOutputBuffer(encoderStatus,false);\n    }\n    if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n      continue;\n    }\n    if (!decoderDone) {\n      int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n      if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n        decoderOutputAvailable=false;\n      }\n else       if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n      }\n else       if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n        MediaFormat newFormat=decoder.getOutputFormat();\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"newFormat = \" + newFormat);\n        }\n      }\n else       if (decoderStatus < 0) {\n        throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n      }\n else {\n        boolean doRender=info.size != 0;\n        long originalPresentationTime=info.presentationTimeUs;\n        if (endTime > 0 && originalPresentationTime >= endTime) {\n          inputDone=true;\n          decoderDone=true;\n          doRender=false;\n          info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n        }\n        boolean flushed=false;\n        if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n          if (startTime > 0) {\n            extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else {\n            extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n          additionalPresentationTime=minPresentationTime + frameDelta;\n          endTime=avatarStartTime;\n          avatarStartTime=-1;\n          inputDone=false;\n          decoderDone=false;\n          doRender=false;\n          info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n          decoder.flush();\n          flushed=true;\n        }\n        trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n        if (trueStartTime > 0 && videoTime == -1) {\n          if (originalPresentationTime < trueStartTime) {\n            doRender=false;\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n            }\n          }\n else {\n            videoTime=info.presentationTimeUs;\n            if (minPresentationTime != Integer.MIN_VALUE) {\n              additionalPresentationTime-=videoTime;\n            }\n          }\n        }\n        if (flushed) {\n          videoTime=-1;\n        }\n else {\n          if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n            info.presentationTimeUs+=additionalPresentationTime;\n          }\n          decoder.releaseOutputBuffer(decoderStatus,doRender);\n        }\n        if (doRender) {\n          if (avatarStartTime >= 0) {\n            minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n          }\n          boolean errorWait=false;\n          try {\n            outputSurface.awaitNewImage();\n          }\n catch (          Exception e) {\n            errorWait=true;\n            FileLog.e(e);\n          }\n          if (!errorWait) {\n            outputSurface.drawImage();\n            inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n            inputSurface.swapBuffers();\n          }\n        }\n        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n          decoderOutputAvailable=false;\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"decoder stream end\");\n          }\n          encoder.signalEndOfInputStream();\n        }\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1369,
      "astHeight" : 26
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 19765,
        "startLineNumber" : 453,
        "startColumnNumber" : 28,
        "endLineNumber" : 710,
        "endColumnNumber" : 29
      },
      "nodeContext" : "while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n  checkConversionCanceled();\n  if (!copyAudioBuffer && audioRecoder != null) {\n    audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n  }\n  if (!inputDone) {\n    boolean eof=false;\n    int index=extractor.getSampleTrackIndex();\n    if (index == videoIndex) {\n      int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n      if (inputBufIndex >= 0) {\n        ByteBuffer inputBuf;\n        if (Build.VERSION.SDK_INT < 21) {\n          inputBuf=decoderInputBuffers[inputBufIndex];\n        }\n else {\n          inputBuf=decoder.getInputBuffer(inputBufIndex);\n        }\n        int chunkSize=extractor.readSampleData(inputBuf,0);\n        if (chunkSize < 0) {\n          decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n          inputDone=true;\n        }\n else {\n          decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n          extractor.advance();\n        }\n      }\n    }\n else     if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n      info.size=extractor.readSampleData(audioBuffer,0);\n      if (Build.VERSION.SDK_INT < 21) {\n        audioBuffer.position(0);\n        audioBuffer.limit(info.size);\n      }\n      if (info.size >= 0) {\n        info.presentationTimeUs=extractor.getSampleTime();\n        extractor.advance();\n      }\n else {\n        info.size=0;\n        inputDone=true;\n      }\n      if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n        info.offset=0;\n        info.flags=extractor.getSampleFlags();\n        long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n        if (availableSize != 0) {\n          if (callback != null) {\n            if (info.presentationTimeUs - startTime > currentPts) {\n              currentPts=info.presentationTimeUs - startTime;\n            }\n            callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n          }\n        }\n      }\n    }\n else     if (index == -1) {\n      eof=true;\n    }\n    if (eof) {\n      int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n      if (inputBufIndex >= 0) {\n        decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n        inputDone=true;\n      }\n    }\n  }\n  boolean decoderOutputAvailable=!decoderDone;\n  boolean encoderOutputAvailable=true;\n  while (decoderOutputAvailable || encoderOutputAvailable) {\n    checkConversionCanceled();\n    int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n    if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n      encoderOutputAvailable=false;\n    }\n else     if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n      if (Build.VERSION.SDK_INT < 21) {\n        encoderOutputBuffers=encoder.getOutputBuffers();\n      }\n    }\n else     if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n      MediaFormat newFormat=encoder.getOutputFormat();\n      if (videoTrackIndex == -5 && newFormat != null) {\n        videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n        if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n          ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n          ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n          prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n        }\n      }\n    }\n else     if (encoderStatus < 0) {\n      throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n    }\n else {\n      ByteBuffer encodedData;\n      if (Build.VERSION.SDK_INT < 21) {\n        encodedData=encoderOutputBuffers[encoderStatus];\n      }\n else {\n        encodedData=encoder.getOutputBuffer(encoderStatus);\n      }\n      if (encodedData == null) {\n        throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n      }\n      if (info.size > 1) {\n        if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n          if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n            info.offset+=prependHeaderSize;\n            info.size-=prependHeaderSize;\n          }\n          if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n            if (info.size > 100) {\n              encodedData.position(info.offset);\n              byte[] temp=new byte[100];\n              encodedData.get(temp);\n              int nalCount=0;\n              for (int a=0; a < temp.length - 4; a++) {\n                if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                  nalCount++;\n                  if (nalCount > 1) {\n                    info.offset+=a;\n                    info.size-=a;\n                    break;\n                  }\n                }\n              }\n            }\n            firstEncode=false;\n          }\n          long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n          if (availableSize != 0) {\n            if (callback != null) {\n              if (info.presentationTimeUs - startTime > currentPts) {\n                currentPts=info.presentationTimeUs - startTime;\n              }\n              callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n            }\n          }\n        }\n else         if (videoTrackIndex == -5) {\n          byte[] csd=new byte[info.size];\n          encodedData.limit(info.offset + info.size);\n          encodedData.position(info.offset);\n          encodedData.get(csd);\n          ByteBuffer sps=null;\n          ByteBuffer pps=null;\n          for (int a=info.size - 1; a >= 0; a--) {\n            if (a > 3) {\n              if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                sps=ByteBuffer.allocate(a - 3);\n                pps=ByteBuffer.allocate(info.size - (a - 3));\n                sps.put(csd,0,a - 3).position(0);\n                pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                break;\n              }\n            }\n else {\n              break;\n            }\n          }\n          MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n          if (sps != null && pps != null) {\n            newFormat.setByteBuffer(\"csd-0\",sps);\n            newFormat.setByteBuffer(\"csd-1\",pps);\n          }\n          videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n        }\n      }\n      outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n      encoder.releaseOutputBuffer(encoderStatus,false);\n    }\n    if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n      continue;\n    }\n    if (!decoderDone) {\n      int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n      if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n        decoderOutputAvailable=false;\n      }\n else       if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n      }\n else       if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n        MediaFormat newFormat=decoder.getOutputFormat();\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"newFormat = \" + newFormat);\n        }\n      }\n else       if (decoderStatus < 0) {\n        throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n      }\n else {\n        boolean doRender=info.size != 0;\n        long originalPresentationTime=info.presentationTimeUs;\n        if (endTime > 0 && originalPresentationTime >= endTime) {\n          inputDone=true;\n          decoderDone=true;\n          doRender=false;\n          info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n        }\n        boolean flushed=false;\n        if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n          if (startTime > 0) {\n            extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else {\n            extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n          additionalPresentationTime=minPresentationTime + frameDelta;\n          endTime=avatarStartTime;\n          avatarStartTime=-1;\n          inputDone=false;\n          decoderDone=false;\n          doRender=false;\n          info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n          decoder.flush();\n          flushed=true;\n        }\n        trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n        if (trueStartTime > 0 && videoTime == -1) {\n          if (originalPresentationTime < trueStartTime) {\n            doRender=false;\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n            }\n          }\n else {\n            videoTime=info.presentationTimeUs;\n            if (minPresentationTime != Integer.MIN_VALUE) {\n              additionalPresentationTime-=videoTime;\n            }\n          }\n        }\n        if (flushed) {\n          videoTime=-1;\n        }\n else {\n          if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n            info.presentationTimeUs+=additionalPresentationTime;\n          }\n          decoder.releaseOutputBuffer(decoderStatus,doRender);\n        }\n        if (doRender) {\n          if (avatarStartTime >= 0) {\n            minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n          }\n          boolean errorWait=false;\n          try {\n            outputSurface.awaitNewImage();\n          }\n catch (          Exception e) {\n            errorWait=true;\n            FileLog.e(e);\n          }\n          if (!errorWait) {\n            outputSurface.drawImage();\n            inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n            inputSurface.swapBuffers();\n          }\n        }\n        if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n          decoderOutputAvailable=false;\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"decoder stream end\");\n          }\n          encoder.signalEndOfInputStream();\n        }\n      }\n    }\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 1379,
      "astHeight" : 27
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 27844,
        "startLineNumber" : 316,
        "startColumnNumber" : 28,
        "endLineNumber" : 711,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  long videoTime=-1;\n  boolean outputDone=false;\n  boolean inputDone=false;\n  boolean decoderDone=false;\n  int swapUV=0;\n  int audioTrackIndex=-5;\n  long additionalPresentationTime=0;\n  long minPresentationTime=Integer.MIN_VALUE;\n  long frameDelta=1000 / framerate * 1000;\n  extractor.selectTrack(videoIndex);\n  MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n  if (avatarStartTime >= 0) {\n    if (durationS <= 2000) {\n      bitrate=2600000;\n    }\n else     if (durationS <= 5000) {\n      bitrate=2200000;\n    }\n else {\n      bitrate=1560000;\n    }\n    avatarStartTime=0;\n  }\n else   if (bitrate <= 0) {\n    bitrate=921600;\n  }\n  if (originalBitrate > 0) {\n    bitrate=Math.min(originalBitrate,bitrate);\n  }\n  long trueStartTime;\n  if (avatarStartTime >= 0) {\n    avatarStartTime=-1;\n  }\n  if (avatarStartTime >= 0) {\n    extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n  }\n else   if (startTime > 0) {\n    extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n  }\n else {\n    extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n  }\n  int w;\n  int h;\n  if (cropState != null) {\n    if (rotationValue == 90 || rotationValue == 270) {\n      w=cropState.transformHeight;\n      h=cropState.transformWidth;\n    }\n else {\n      w=cropState.transformWidth;\n      h=cropState.transformHeight;\n    }\n  }\n else {\n    w=resultWidth;\n    h=resultHeight;\n  }\n  if (BuildVars.LOGS_ENABLED) {\n    FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n  }\n  MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n  outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n  outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n  outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n  outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n  if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n    if (bitrate > 921600) {\n      bitrate=921600;\n    }\n    outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n  }\n  encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n  encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n  inputSurface=new InputSurface(encoder.createInputSurface());\n  inputSurface.makeCurrent();\n  encoder.start();\n  decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n  outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n  decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n  decoder.start();\n  ByteBuffer[] decoderInputBuffers=null;\n  ByteBuffer[] encoderOutputBuffers=null;\n  ByteBuffer[] encoderInputBuffers=null;\n  if (Build.VERSION.SDK_INT < 21) {\n    decoderInputBuffers=decoder.getInputBuffers();\n    encoderOutputBuffers=encoder.getOutputBuffers();\n  }\n  if (audioIndex >= 0) {\n    MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n    copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n    if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n      audioIndex=-1;\n    }\n    if (audioIndex >= 0) {\n      if (copyAudioBuffer) {\n        audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n        extractor.selectTrack(audioIndex);\n        int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n        audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n        if (startTime > 0) {\n          extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else {\n          extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n      }\n else {\n        MediaExtractor audioExtractor=new MediaExtractor();\n        audioExtractor.setDataSource(videoPath);\n        audioExtractor.selectTrack(audioIndex);\n        if (startTime > 0) {\n          audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else {\n          audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n        audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n        audioRecoder.startTime=startTime;\n        audioRecoder.endTime=endTime;\n        audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n      }\n    }\n  }\n  boolean audioEncoderDone=audioIndex < 0;\n  boolean firstEncode=true;\n  checkConversionCanceled();\n  while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n    checkConversionCanceled();\n    if (!copyAudioBuffer && audioRecoder != null) {\n      audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n    }\n    if (!inputDone) {\n      boolean eof=false;\n      int index=extractor.getSampleTrackIndex();\n      if (index == videoIndex) {\n        int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n        if (inputBufIndex >= 0) {\n          ByteBuffer inputBuf;\n          if (Build.VERSION.SDK_INT < 21) {\n            inputBuf=decoderInputBuffers[inputBufIndex];\n          }\n else {\n            inputBuf=decoder.getInputBuffer(inputBufIndex);\n          }\n          int chunkSize=extractor.readSampleData(inputBuf,0);\n          if (chunkSize < 0) {\n            decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n            inputDone=true;\n          }\n else {\n            decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n            extractor.advance();\n          }\n        }\n      }\n else       if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n        info.size=extractor.readSampleData(audioBuffer,0);\n        if (Build.VERSION.SDK_INT < 21) {\n          audioBuffer.position(0);\n          audioBuffer.limit(info.size);\n        }\n        if (info.size >= 0) {\n          info.presentationTimeUs=extractor.getSampleTime();\n          extractor.advance();\n        }\n else {\n          info.size=0;\n          inputDone=true;\n        }\n        if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n          info.offset=0;\n          info.flags=extractor.getSampleFlags();\n          long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n          if (availableSize != 0) {\n            if (callback != null) {\n              if (info.presentationTimeUs - startTime > currentPts) {\n                currentPts=info.presentationTimeUs - startTime;\n              }\n              callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n            }\n          }\n        }\n      }\n else       if (index == -1) {\n        eof=true;\n      }\n      if (eof) {\n        int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n        if (inputBufIndex >= 0) {\n          decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n          inputDone=true;\n        }\n      }\n    }\n    boolean decoderOutputAvailable=!decoderDone;\n    boolean encoderOutputAvailable=true;\n    while (decoderOutputAvailable || encoderOutputAvailable) {\n      checkConversionCanceled();\n      int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n      if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n        encoderOutputAvailable=false;\n      }\n else       if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n        if (Build.VERSION.SDK_INT < 21) {\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n      }\n else       if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n        MediaFormat newFormat=encoder.getOutputFormat();\n        if (videoTrackIndex == -5 && newFormat != null) {\n          videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n          if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n            ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n            ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n            prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n          }\n        }\n      }\n else       if (encoderStatus < 0) {\n        throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n      }\n else {\n        ByteBuffer encodedData;\n        if (Build.VERSION.SDK_INT < 21) {\n          encodedData=encoderOutputBuffers[encoderStatus];\n        }\n else {\n          encodedData=encoder.getOutputBuffer(encoderStatus);\n        }\n        if (encodedData == null) {\n          throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n        }\n        if (info.size > 1) {\n          if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n            if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n              info.offset+=prependHeaderSize;\n              info.size-=prependHeaderSize;\n            }\n            if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n              if (info.size > 100) {\n                encodedData.position(info.offset);\n                byte[] temp=new byte[100];\n                encodedData.get(temp);\n                int nalCount=0;\n                for (int a=0; a < temp.length - 4; a++) {\n                  if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                    nalCount++;\n                    if (nalCount > 1) {\n                      info.offset+=a;\n                      info.size-=a;\n                      break;\n                    }\n                  }\n                }\n              }\n              firstEncode=false;\n            }\n            long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n            if (availableSize != 0) {\n              if (callback != null) {\n                if (info.presentationTimeUs - startTime > currentPts) {\n                  currentPts=info.presentationTimeUs - startTime;\n                }\n                callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n              }\n            }\n          }\n else           if (videoTrackIndex == -5) {\n            byte[] csd=new byte[info.size];\n            encodedData.limit(info.offset + info.size);\n            encodedData.position(info.offset);\n            encodedData.get(csd);\n            ByteBuffer sps=null;\n            ByteBuffer pps=null;\n            for (int a=info.size - 1; a >= 0; a--) {\n              if (a > 3) {\n                if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                  sps=ByteBuffer.allocate(a - 3);\n                  pps=ByteBuffer.allocate(info.size - (a - 3));\n                  sps.put(csd,0,a - 3).position(0);\n                  pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                  break;\n                }\n              }\n else {\n                break;\n              }\n            }\n            MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n            if (sps != null && pps != null) {\n              newFormat.setByteBuffer(\"csd-0\",sps);\n              newFormat.setByteBuffer(\"csd-1\",pps);\n            }\n            videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n          }\n        }\n        outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n        encoder.releaseOutputBuffer(encoderStatus,false);\n      }\n      if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n        continue;\n      }\n      if (!decoderDone) {\n        int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n        if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n          decoderOutputAvailable=false;\n        }\n else         if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n        }\n else         if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n          MediaFormat newFormat=decoder.getOutputFormat();\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"newFormat = \" + newFormat);\n          }\n        }\n else         if (decoderStatus < 0) {\n          throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n        }\n else {\n          boolean doRender=info.size != 0;\n          long originalPresentationTime=info.presentationTimeUs;\n          if (endTime > 0 && originalPresentationTime >= endTime) {\n            inputDone=true;\n            decoderDone=true;\n            doRender=false;\n            info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n          }\n          boolean flushed=false;\n          if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n            if (startTime > 0) {\n              extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else {\n              extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n            additionalPresentationTime=minPresentationTime + frameDelta;\n            endTime=avatarStartTime;\n            avatarStartTime=-1;\n            inputDone=false;\n            decoderDone=false;\n            doRender=false;\n            info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n            decoder.flush();\n            flushed=true;\n          }\n          trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n          if (trueStartTime > 0 && videoTime == -1) {\n            if (originalPresentationTime < trueStartTime) {\n              doRender=false;\n              if (BuildVars.LOGS_ENABLED) {\n                FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n              }\n            }\n else {\n              videoTime=info.presentationTimeUs;\n              if (minPresentationTime != Integer.MIN_VALUE) {\n                additionalPresentationTime-=videoTime;\n              }\n            }\n          }\n          if (flushed) {\n            videoTime=-1;\n          }\n else {\n            if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n              info.presentationTimeUs+=additionalPresentationTime;\n            }\n            decoder.releaseOutputBuffer(decoderStatus,doRender);\n          }\n          if (doRender) {\n            if (avatarStartTime >= 0) {\n              minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n            }\n            boolean errorWait=false;\n            try {\n              outputSurface.awaitNewImage();\n            }\n catch (            Exception e) {\n              errorWait=true;\n              FileLog.e(e);\n            }\n            if (!errorWait) {\n              outputSurface.drawImage();\n              inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n              inputSurface.swapBuffers();\n            }\n          }\n          if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n            decoderOutputAvailable=false;\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"decoder stream end\");\n            }\n            encoder.signalEndOfInputStream();\n          }\n        }\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2027,
      "astHeight" : 28
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 28525,
        "startLineNumber" : 316,
        "startColumnNumber" : 24,
        "endLineNumber" : 721,
        "endColumnNumber" : 25
      },
      "nodeContext" : "try {\n  long videoTime=-1;\n  boolean outputDone=false;\n  boolean inputDone=false;\n  boolean decoderDone=false;\n  int swapUV=0;\n  int audioTrackIndex=-5;\n  long additionalPresentationTime=0;\n  long minPresentationTime=Integer.MIN_VALUE;\n  long frameDelta=1000 / framerate * 1000;\n  extractor.selectTrack(videoIndex);\n  MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n  if (avatarStartTime >= 0) {\n    if (durationS <= 2000) {\n      bitrate=2600000;\n    }\n else     if (durationS <= 5000) {\n      bitrate=2200000;\n    }\n else {\n      bitrate=1560000;\n    }\n    avatarStartTime=0;\n  }\n else   if (bitrate <= 0) {\n    bitrate=921600;\n  }\n  if (originalBitrate > 0) {\n    bitrate=Math.min(originalBitrate,bitrate);\n  }\n  long trueStartTime;\n  if (avatarStartTime >= 0) {\n    avatarStartTime=-1;\n  }\n  if (avatarStartTime >= 0) {\n    extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n  }\n else   if (startTime > 0) {\n    extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n  }\n else {\n    extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n  }\n  int w;\n  int h;\n  if (cropState != null) {\n    if (rotationValue == 90 || rotationValue == 270) {\n      w=cropState.transformHeight;\n      h=cropState.transformWidth;\n    }\n else {\n      w=cropState.transformWidth;\n      h=cropState.transformHeight;\n    }\n  }\n else {\n    w=resultWidth;\n    h=resultHeight;\n  }\n  if (BuildVars.LOGS_ENABLED) {\n    FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n  }\n  MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n  outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n  outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n  outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n  outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n  if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n    if (bitrate > 921600) {\n      bitrate=921600;\n    }\n    outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n  }\n  encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n  encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n  inputSurface=new InputSurface(encoder.createInputSurface());\n  inputSurface.makeCurrent();\n  encoder.start();\n  decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n  outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n  decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n  decoder.start();\n  ByteBuffer[] decoderInputBuffers=null;\n  ByteBuffer[] encoderOutputBuffers=null;\n  ByteBuffer[] encoderInputBuffers=null;\n  if (Build.VERSION.SDK_INT < 21) {\n    decoderInputBuffers=decoder.getInputBuffers();\n    encoderOutputBuffers=encoder.getOutputBuffers();\n  }\n  if (audioIndex >= 0) {\n    MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n    copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n    if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n      audioIndex=-1;\n    }\n    if (audioIndex >= 0) {\n      if (copyAudioBuffer) {\n        audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n        extractor.selectTrack(audioIndex);\n        int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n        audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n        if (startTime > 0) {\n          extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else {\n          extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n      }\n else {\n        MediaExtractor audioExtractor=new MediaExtractor();\n        audioExtractor.setDataSource(videoPath);\n        audioExtractor.selectTrack(audioIndex);\n        if (startTime > 0) {\n          audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else {\n          audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n        audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n        audioRecoder.startTime=startTime;\n        audioRecoder.endTime=endTime;\n        audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n      }\n    }\n  }\n  boolean audioEncoderDone=audioIndex < 0;\n  boolean firstEncode=true;\n  checkConversionCanceled();\n  while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n    checkConversionCanceled();\n    if (!copyAudioBuffer && audioRecoder != null) {\n      audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n    }\n    if (!inputDone) {\n      boolean eof=false;\n      int index=extractor.getSampleTrackIndex();\n      if (index == videoIndex) {\n        int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n        if (inputBufIndex >= 0) {\n          ByteBuffer inputBuf;\n          if (Build.VERSION.SDK_INT < 21) {\n            inputBuf=decoderInputBuffers[inputBufIndex];\n          }\n else {\n            inputBuf=decoder.getInputBuffer(inputBufIndex);\n          }\n          int chunkSize=extractor.readSampleData(inputBuf,0);\n          if (chunkSize < 0) {\n            decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n            inputDone=true;\n          }\n else {\n            decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n            extractor.advance();\n          }\n        }\n      }\n else       if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n        info.size=extractor.readSampleData(audioBuffer,0);\n        if (Build.VERSION.SDK_INT < 21) {\n          audioBuffer.position(0);\n          audioBuffer.limit(info.size);\n        }\n        if (info.size >= 0) {\n          info.presentationTimeUs=extractor.getSampleTime();\n          extractor.advance();\n        }\n else {\n          info.size=0;\n          inputDone=true;\n        }\n        if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n          info.offset=0;\n          info.flags=extractor.getSampleFlags();\n          long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n          if (availableSize != 0) {\n            if (callback != null) {\n              if (info.presentationTimeUs - startTime > currentPts) {\n                currentPts=info.presentationTimeUs - startTime;\n              }\n              callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n            }\n          }\n        }\n      }\n else       if (index == -1) {\n        eof=true;\n      }\n      if (eof) {\n        int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n        if (inputBufIndex >= 0) {\n          decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n          inputDone=true;\n        }\n      }\n    }\n    boolean decoderOutputAvailable=!decoderDone;\n    boolean encoderOutputAvailable=true;\n    while (decoderOutputAvailable || encoderOutputAvailable) {\n      checkConversionCanceled();\n      int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n      if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n        encoderOutputAvailable=false;\n      }\n else       if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n        if (Build.VERSION.SDK_INT < 21) {\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n      }\n else       if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n        MediaFormat newFormat=encoder.getOutputFormat();\n        if (videoTrackIndex == -5 && newFormat != null) {\n          videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n          if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n            ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n            ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n            prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n          }\n        }\n      }\n else       if (encoderStatus < 0) {\n        throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n      }\n else {\n        ByteBuffer encodedData;\n        if (Build.VERSION.SDK_INT < 21) {\n          encodedData=encoderOutputBuffers[encoderStatus];\n        }\n else {\n          encodedData=encoder.getOutputBuffer(encoderStatus);\n        }\n        if (encodedData == null) {\n          throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n        }\n        if (info.size > 1) {\n          if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n            if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n              info.offset+=prependHeaderSize;\n              info.size-=prependHeaderSize;\n            }\n            if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n              if (info.size > 100) {\n                encodedData.position(info.offset);\n                byte[] temp=new byte[100];\n                encodedData.get(temp);\n                int nalCount=0;\n                for (int a=0; a < temp.length - 4; a++) {\n                  if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                    nalCount++;\n                    if (nalCount > 1) {\n                      info.offset+=a;\n                      info.size-=a;\n                      break;\n                    }\n                  }\n                }\n              }\n              firstEncode=false;\n            }\n            long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n            if (availableSize != 0) {\n              if (callback != null) {\n                if (info.presentationTimeUs - startTime > currentPts) {\n                  currentPts=info.presentationTimeUs - startTime;\n                }\n                callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n              }\n            }\n          }\n else           if (videoTrackIndex == -5) {\n            byte[] csd=new byte[info.size];\n            encodedData.limit(info.offset + info.size);\n            encodedData.position(info.offset);\n            encodedData.get(csd);\n            ByteBuffer sps=null;\n            ByteBuffer pps=null;\n            for (int a=info.size - 1; a >= 0; a--) {\n              if (a > 3) {\n                if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                  sps=ByteBuffer.allocate(a - 3);\n                  pps=ByteBuffer.allocate(info.size - (a - 3));\n                  sps.put(csd,0,a - 3).position(0);\n                  pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                  break;\n                }\n              }\n else {\n                break;\n              }\n            }\n            MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n            if (sps != null && pps != null) {\n              newFormat.setByteBuffer(\"csd-0\",sps);\n              newFormat.setByteBuffer(\"csd-1\",pps);\n            }\n            videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n          }\n        }\n        outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n        encoder.releaseOutputBuffer(encoderStatus,false);\n      }\n      if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n        continue;\n      }\n      if (!decoderDone) {\n        int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n        if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n          decoderOutputAvailable=false;\n        }\n else         if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n        }\n else         if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n          MediaFormat newFormat=decoder.getOutputFormat();\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"newFormat = \" + newFormat);\n          }\n        }\n else         if (decoderStatus < 0) {\n          throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n        }\n else {\n          boolean doRender=info.size != 0;\n          long originalPresentationTime=info.presentationTimeUs;\n          if (endTime > 0 && originalPresentationTime >= endTime) {\n            inputDone=true;\n            decoderDone=true;\n            doRender=false;\n            info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n          }\n          boolean flushed=false;\n          if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n            if (startTime > 0) {\n              extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else {\n              extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n            additionalPresentationTime=minPresentationTime + frameDelta;\n            endTime=avatarStartTime;\n            avatarStartTime=-1;\n            inputDone=false;\n            decoderDone=false;\n            doRender=false;\n            info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n            decoder.flush();\n            flushed=true;\n          }\n          trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n          if (trueStartTime > 0 && videoTime == -1) {\n            if (originalPresentationTime < trueStartTime) {\n              doRender=false;\n              if (BuildVars.LOGS_ENABLED) {\n                FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n              }\n            }\n else {\n              videoTime=info.presentationTimeUs;\n              if (minPresentationTime != Integer.MIN_VALUE) {\n                additionalPresentationTime-=videoTime;\n              }\n            }\n          }\n          if (flushed) {\n            videoTime=-1;\n          }\n else {\n            if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n              info.presentationTimeUs+=additionalPresentationTime;\n            }\n            decoder.releaseOutputBuffer(decoderStatus,doRender);\n          }\n          if (doRender) {\n            if (avatarStartTime >= 0) {\n              minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n            }\n            boolean errorWait=false;\n            try {\n              outputSurface.awaitNewImage();\n            }\n catch (            Exception e) {\n              errorWait=true;\n              FileLog.e(e);\n            }\n            if (!errorWait) {\n              outputSurface.drawImage();\n              inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n              inputSurface.swapBuffers();\n            }\n          }\n          if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n            decoderOutputAvailable=false;\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"decoder stream end\");\n            }\n            encoder.signalEndOfInputStream();\n          }\n        }\n      }\n    }\n  }\n}\n catch (Exception e) {\n  if (e instanceof IllegalStateException && !increaseTimeout) {\n    repeatWithIncreasedTimeout=true;\n  }\n  FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n  FileLog.e(e);\n  error=true;\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 2069,
      "astHeight" : 29
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 28851,
        "startLineNumber" : 313,
        "startColumnNumber" : 41,
        "endLineNumber" : 728,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  MediaCodec decoder=null;\n  try {\n    long videoTime=-1;\n    boolean outputDone=false;\n    boolean inputDone=false;\n    boolean decoderDone=false;\n    int swapUV=0;\n    int audioTrackIndex=-5;\n    long additionalPresentationTime=0;\n    long minPresentationTime=Integer.MIN_VALUE;\n    long frameDelta=1000 / framerate * 1000;\n    extractor.selectTrack(videoIndex);\n    MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n    if (avatarStartTime >= 0) {\n      if (durationS <= 2000) {\n        bitrate=2600000;\n      }\n else       if (durationS <= 5000) {\n        bitrate=2200000;\n      }\n else {\n        bitrate=1560000;\n      }\n      avatarStartTime=0;\n    }\n else     if (bitrate <= 0) {\n      bitrate=921600;\n    }\n    if (originalBitrate > 0) {\n      bitrate=Math.min(originalBitrate,bitrate);\n    }\n    long trueStartTime;\n    if (avatarStartTime >= 0) {\n      avatarStartTime=-1;\n    }\n    if (avatarStartTime >= 0) {\n      extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n    }\n else     if (startTime > 0) {\n      extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n    }\n else {\n      extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n    }\n    int w;\n    int h;\n    if (cropState != null) {\n      if (rotationValue == 90 || rotationValue == 270) {\n        w=cropState.transformHeight;\n        h=cropState.transformWidth;\n      }\n else {\n        w=cropState.transformWidth;\n        h=cropState.transformHeight;\n      }\n    }\n else {\n      w=resultWidth;\n      h=resultHeight;\n    }\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n    }\n    MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n    outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n    outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n    outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n    outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n    if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n      if (bitrate > 921600) {\n        bitrate=921600;\n      }\n      outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n    }\n    encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n    encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n    inputSurface=new InputSurface(encoder.createInputSurface());\n    inputSurface.makeCurrent();\n    encoder.start();\n    decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n    outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n    decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n    decoder.start();\n    ByteBuffer[] decoderInputBuffers=null;\n    ByteBuffer[] encoderOutputBuffers=null;\n    ByteBuffer[] encoderInputBuffers=null;\n    if (Build.VERSION.SDK_INT < 21) {\n      decoderInputBuffers=decoder.getInputBuffers();\n      encoderOutputBuffers=encoder.getOutputBuffers();\n    }\n    if (audioIndex >= 0) {\n      MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n      copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n      if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n        audioIndex=-1;\n      }\n      if (audioIndex >= 0) {\n        if (copyAudioBuffer) {\n          audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n          extractor.selectTrack(audioIndex);\n          int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n          audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n          if (startTime > 0) {\n            extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else {\n            extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n        }\n else {\n          MediaExtractor audioExtractor=new MediaExtractor();\n          audioExtractor.setDataSource(videoPath);\n          audioExtractor.selectTrack(audioIndex);\n          if (startTime > 0) {\n            audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else {\n            audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n          audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n          audioRecoder.startTime=startTime;\n          audioRecoder.endTime=endTime;\n          audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n        }\n      }\n    }\n    boolean audioEncoderDone=audioIndex < 0;\n    boolean firstEncode=true;\n    checkConversionCanceled();\n    while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n      checkConversionCanceled();\n      if (!copyAudioBuffer && audioRecoder != null) {\n        audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n      }\n      if (!inputDone) {\n        boolean eof=false;\n        int index=extractor.getSampleTrackIndex();\n        if (index == videoIndex) {\n          int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n          if (inputBufIndex >= 0) {\n            ByteBuffer inputBuf;\n            if (Build.VERSION.SDK_INT < 21) {\n              inputBuf=decoderInputBuffers[inputBufIndex];\n            }\n else {\n              inputBuf=decoder.getInputBuffer(inputBufIndex);\n            }\n            int chunkSize=extractor.readSampleData(inputBuf,0);\n            if (chunkSize < 0) {\n              decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n              inputDone=true;\n            }\n else {\n              decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n              extractor.advance();\n            }\n          }\n        }\n else         if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n          info.size=extractor.readSampleData(audioBuffer,0);\n          if (Build.VERSION.SDK_INT < 21) {\n            audioBuffer.position(0);\n            audioBuffer.limit(info.size);\n          }\n          if (info.size >= 0) {\n            info.presentationTimeUs=extractor.getSampleTime();\n            extractor.advance();\n          }\n else {\n            info.size=0;\n            inputDone=true;\n          }\n          if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n            info.offset=0;\n            info.flags=extractor.getSampleFlags();\n            long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n            if (availableSize != 0) {\n              if (callback != null) {\n                if (info.presentationTimeUs - startTime > currentPts) {\n                  currentPts=info.presentationTimeUs - startTime;\n                }\n                callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n              }\n            }\n          }\n        }\n else         if (index == -1) {\n          eof=true;\n        }\n        if (eof) {\n          int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n          if (inputBufIndex >= 0) {\n            decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n            inputDone=true;\n          }\n        }\n      }\n      boolean decoderOutputAvailable=!decoderDone;\n      boolean encoderOutputAvailable=true;\n      while (decoderOutputAvailable || encoderOutputAvailable) {\n        checkConversionCanceled();\n        int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n        if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n          encoderOutputAvailable=false;\n        }\n else         if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n          if (Build.VERSION.SDK_INT < 21) {\n            encoderOutputBuffers=encoder.getOutputBuffers();\n          }\n        }\n else         if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n          MediaFormat newFormat=encoder.getOutputFormat();\n          if (videoTrackIndex == -5 && newFormat != null) {\n            videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n            if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n              ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n              ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n              prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n            }\n          }\n        }\n else         if (encoderStatus < 0) {\n          throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n        }\n else {\n          ByteBuffer encodedData;\n          if (Build.VERSION.SDK_INT < 21) {\n            encodedData=encoderOutputBuffers[encoderStatus];\n          }\n else {\n            encodedData=encoder.getOutputBuffer(encoderStatus);\n          }\n          if (encodedData == null) {\n            throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n          }\n          if (info.size > 1) {\n            if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n              if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                info.offset+=prependHeaderSize;\n                info.size-=prependHeaderSize;\n              }\n              if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                if (info.size > 100) {\n                  encodedData.position(info.offset);\n                  byte[] temp=new byte[100];\n                  encodedData.get(temp);\n                  int nalCount=0;\n                  for (int a=0; a < temp.length - 4; a++) {\n                    if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                      nalCount++;\n                      if (nalCount > 1) {\n                        info.offset+=a;\n                        info.size-=a;\n                        break;\n                      }\n                    }\n                  }\n                }\n                firstEncode=false;\n              }\n              long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n              if (availableSize != 0) {\n                if (callback != null) {\n                  if (info.presentationTimeUs - startTime > currentPts) {\n                    currentPts=info.presentationTimeUs - startTime;\n                  }\n                  callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                }\n              }\n            }\n else             if (videoTrackIndex == -5) {\n              byte[] csd=new byte[info.size];\n              encodedData.limit(info.offset + info.size);\n              encodedData.position(info.offset);\n              encodedData.get(csd);\n              ByteBuffer sps=null;\n              ByteBuffer pps=null;\n              for (int a=info.size - 1; a >= 0; a--) {\n                if (a > 3) {\n                  if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                    sps=ByteBuffer.allocate(a - 3);\n                    pps=ByteBuffer.allocate(info.size - (a - 3));\n                    sps.put(csd,0,a - 3).position(0);\n                    pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                    break;\n                  }\n                }\n else {\n                  break;\n                }\n              }\n              MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n              if (sps != null && pps != null) {\n                newFormat.setByteBuffer(\"csd-0\",sps);\n                newFormat.setByteBuffer(\"csd-1\",pps);\n              }\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n            }\n          }\n          outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n          encoder.releaseOutputBuffer(encoderStatus,false);\n        }\n        if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n          continue;\n        }\n        if (!decoderDone) {\n          int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n          if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n            decoderOutputAvailable=false;\n          }\n else           if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n          }\n else           if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n            MediaFormat newFormat=decoder.getOutputFormat();\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"newFormat = \" + newFormat);\n            }\n          }\n else           if (decoderStatus < 0) {\n            throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n          }\n else {\n            boolean doRender=info.size != 0;\n            long originalPresentationTime=info.presentationTimeUs;\n            if (endTime > 0 && originalPresentationTime >= endTime) {\n              inputDone=true;\n              decoderDone=true;\n              doRender=false;\n              info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n            }\n            boolean flushed=false;\n            if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n              if (startTime > 0) {\n                extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n else {\n                extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n              additionalPresentationTime=minPresentationTime + frameDelta;\n              endTime=avatarStartTime;\n              avatarStartTime=-1;\n              inputDone=false;\n              decoderDone=false;\n              doRender=false;\n              info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n              decoder.flush();\n              flushed=true;\n            }\n            trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n            if (trueStartTime > 0 && videoTime == -1) {\n              if (originalPresentationTime < trueStartTime) {\n                doRender=false;\n                if (BuildVars.LOGS_ENABLED) {\n                  FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                }\n              }\n else {\n                videoTime=info.presentationTimeUs;\n                if (minPresentationTime != Integer.MIN_VALUE) {\n                  additionalPresentationTime-=videoTime;\n                }\n              }\n            }\n            if (flushed) {\n              videoTime=-1;\n            }\n else {\n              if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                info.presentationTimeUs+=additionalPresentationTime;\n              }\n              decoder.releaseOutputBuffer(decoderStatus,doRender);\n            }\n            if (doRender) {\n              if (avatarStartTime >= 0) {\n                minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n              }\n              boolean errorWait=false;\n              try {\n                outputSurface.awaitNewImage();\n              }\n catch (              Exception e) {\n                errorWait=true;\n                FileLog.e(e);\n              }\n              if (!errorWait) {\n                outputSurface.drawImage();\n                inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                inputSurface.swapBuffers();\n              }\n            }\n            if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n              decoderOutputAvailable=false;\n              if (BuildVars.LOGS_ENABLED) {\n                FileLog.d(\"decoder stream end\");\n              }\n              encoder.signalEndOfInputStream();\n            }\n          }\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    if (e instanceof IllegalStateException && !increaseTimeout) {\n      repeatWithIncreasedTimeout=true;\n    }\n    FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n    FileLog.e(e);\n    error=true;\n  }\n  extractor.unselectTrack(videoIndex);\n  if (decoder != null) {\n    decoder.stop();\n    decoder.release();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2094,
      "astHeight" : 30
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 28872,
        "startLineNumber" : 313,
        "startColumnNumber" : 20,
        "endLineNumber" : 728,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (videoIndex >= 0) {\n  MediaCodec decoder=null;\n  try {\n    long videoTime=-1;\n    boolean outputDone=false;\n    boolean inputDone=false;\n    boolean decoderDone=false;\n    int swapUV=0;\n    int audioTrackIndex=-5;\n    long additionalPresentationTime=0;\n    long minPresentationTime=Integer.MIN_VALUE;\n    long frameDelta=1000 / framerate * 1000;\n    extractor.selectTrack(videoIndex);\n    MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n    if (avatarStartTime >= 0) {\n      if (durationS <= 2000) {\n        bitrate=2600000;\n      }\n else       if (durationS <= 5000) {\n        bitrate=2200000;\n      }\n else {\n        bitrate=1560000;\n      }\n      avatarStartTime=0;\n    }\n else     if (bitrate <= 0) {\n      bitrate=921600;\n    }\n    if (originalBitrate > 0) {\n      bitrate=Math.min(originalBitrate,bitrate);\n    }\n    long trueStartTime;\n    if (avatarStartTime >= 0) {\n      avatarStartTime=-1;\n    }\n    if (avatarStartTime >= 0) {\n      extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n    }\n else     if (startTime > 0) {\n      extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n    }\n else {\n      extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n    }\n    int w;\n    int h;\n    if (cropState != null) {\n      if (rotationValue == 90 || rotationValue == 270) {\n        w=cropState.transformHeight;\n        h=cropState.transformWidth;\n      }\n else {\n        w=cropState.transformWidth;\n        h=cropState.transformHeight;\n      }\n    }\n else {\n      w=resultWidth;\n      h=resultHeight;\n    }\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n    }\n    MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n    outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n    outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n    outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n    outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n    if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n      if (bitrate > 921600) {\n        bitrate=921600;\n      }\n      outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n    }\n    encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n    encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n    inputSurface=new InputSurface(encoder.createInputSurface());\n    inputSurface.makeCurrent();\n    encoder.start();\n    decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n    outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n    decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n    decoder.start();\n    ByteBuffer[] decoderInputBuffers=null;\n    ByteBuffer[] encoderOutputBuffers=null;\n    ByteBuffer[] encoderInputBuffers=null;\n    if (Build.VERSION.SDK_INT < 21) {\n      decoderInputBuffers=decoder.getInputBuffers();\n      encoderOutputBuffers=encoder.getOutputBuffers();\n    }\n    if (audioIndex >= 0) {\n      MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n      copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n      if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n        audioIndex=-1;\n      }\n      if (audioIndex >= 0) {\n        if (copyAudioBuffer) {\n          audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n          extractor.selectTrack(audioIndex);\n          int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n          audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n          if (startTime > 0) {\n            extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else {\n            extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n        }\n else {\n          MediaExtractor audioExtractor=new MediaExtractor();\n          audioExtractor.setDataSource(videoPath);\n          audioExtractor.selectTrack(audioIndex);\n          if (startTime > 0) {\n            audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else {\n            audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n          audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n          audioRecoder.startTime=startTime;\n          audioRecoder.endTime=endTime;\n          audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n        }\n      }\n    }\n    boolean audioEncoderDone=audioIndex < 0;\n    boolean firstEncode=true;\n    checkConversionCanceled();\n    while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n      checkConversionCanceled();\n      if (!copyAudioBuffer && audioRecoder != null) {\n        audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n      }\n      if (!inputDone) {\n        boolean eof=false;\n        int index=extractor.getSampleTrackIndex();\n        if (index == videoIndex) {\n          int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n          if (inputBufIndex >= 0) {\n            ByteBuffer inputBuf;\n            if (Build.VERSION.SDK_INT < 21) {\n              inputBuf=decoderInputBuffers[inputBufIndex];\n            }\n else {\n              inputBuf=decoder.getInputBuffer(inputBufIndex);\n            }\n            int chunkSize=extractor.readSampleData(inputBuf,0);\n            if (chunkSize < 0) {\n              decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n              inputDone=true;\n            }\n else {\n              decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n              extractor.advance();\n            }\n          }\n        }\n else         if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n          info.size=extractor.readSampleData(audioBuffer,0);\n          if (Build.VERSION.SDK_INT < 21) {\n            audioBuffer.position(0);\n            audioBuffer.limit(info.size);\n          }\n          if (info.size >= 0) {\n            info.presentationTimeUs=extractor.getSampleTime();\n            extractor.advance();\n          }\n else {\n            info.size=0;\n            inputDone=true;\n          }\n          if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n            info.offset=0;\n            info.flags=extractor.getSampleFlags();\n            long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n            if (availableSize != 0) {\n              if (callback != null) {\n                if (info.presentationTimeUs - startTime > currentPts) {\n                  currentPts=info.presentationTimeUs - startTime;\n                }\n                callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n              }\n            }\n          }\n        }\n else         if (index == -1) {\n          eof=true;\n        }\n        if (eof) {\n          int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n          if (inputBufIndex >= 0) {\n            decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n            inputDone=true;\n          }\n        }\n      }\n      boolean decoderOutputAvailable=!decoderDone;\n      boolean encoderOutputAvailable=true;\n      while (decoderOutputAvailable || encoderOutputAvailable) {\n        checkConversionCanceled();\n        int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n        if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n          encoderOutputAvailable=false;\n        }\n else         if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n          if (Build.VERSION.SDK_INT < 21) {\n            encoderOutputBuffers=encoder.getOutputBuffers();\n          }\n        }\n else         if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n          MediaFormat newFormat=encoder.getOutputFormat();\n          if (videoTrackIndex == -5 && newFormat != null) {\n            videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n            if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n              ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n              ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n              prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n            }\n          }\n        }\n else         if (encoderStatus < 0) {\n          throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n        }\n else {\n          ByteBuffer encodedData;\n          if (Build.VERSION.SDK_INT < 21) {\n            encodedData=encoderOutputBuffers[encoderStatus];\n          }\n else {\n            encodedData=encoder.getOutputBuffer(encoderStatus);\n          }\n          if (encodedData == null) {\n            throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n          }\n          if (info.size > 1) {\n            if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n              if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                info.offset+=prependHeaderSize;\n                info.size-=prependHeaderSize;\n              }\n              if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                if (info.size > 100) {\n                  encodedData.position(info.offset);\n                  byte[] temp=new byte[100];\n                  encodedData.get(temp);\n                  int nalCount=0;\n                  for (int a=0; a < temp.length - 4; a++) {\n                    if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                      nalCount++;\n                      if (nalCount > 1) {\n                        info.offset+=a;\n                        info.size-=a;\n                        break;\n                      }\n                    }\n                  }\n                }\n                firstEncode=false;\n              }\n              long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n              if (availableSize != 0) {\n                if (callback != null) {\n                  if (info.presentationTimeUs - startTime > currentPts) {\n                    currentPts=info.presentationTimeUs - startTime;\n                  }\n                  callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                }\n              }\n            }\n else             if (videoTrackIndex == -5) {\n              byte[] csd=new byte[info.size];\n              encodedData.limit(info.offset + info.size);\n              encodedData.position(info.offset);\n              encodedData.get(csd);\n              ByteBuffer sps=null;\n              ByteBuffer pps=null;\n              for (int a=info.size - 1; a >= 0; a--) {\n                if (a > 3) {\n                  if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                    sps=ByteBuffer.allocate(a - 3);\n                    pps=ByteBuffer.allocate(info.size - (a - 3));\n                    sps.put(csd,0,a - 3).position(0);\n                    pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                    break;\n                  }\n                }\n else {\n                  break;\n                }\n              }\n              MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n              if (sps != null && pps != null) {\n                newFormat.setByteBuffer(\"csd-0\",sps);\n                newFormat.setByteBuffer(\"csd-1\",pps);\n              }\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n            }\n          }\n          outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n          encoder.releaseOutputBuffer(encoderStatus,false);\n        }\n        if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n          continue;\n        }\n        if (!decoderDone) {\n          int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n          if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n            decoderOutputAvailable=false;\n          }\n else           if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n          }\n else           if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n            MediaFormat newFormat=decoder.getOutputFormat();\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"newFormat = \" + newFormat);\n            }\n          }\n else           if (decoderStatus < 0) {\n            throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n          }\n else {\n            boolean doRender=info.size != 0;\n            long originalPresentationTime=info.presentationTimeUs;\n            if (endTime > 0 && originalPresentationTime >= endTime) {\n              inputDone=true;\n              decoderDone=true;\n              doRender=false;\n              info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n            }\n            boolean flushed=false;\n            if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n              if (startTime > 0) {\n                extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n else {\n                extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n              additionalPresentationTime=minPresentationTime + frameDelta;\n              endTime=avatarStartTime;\n              avatarStartTime=-1;\n              inputDone=false;\n              decoderDone=false;\n              doRender=false;\n              info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n              decoder.flush();\n              flushed=true;\n            }\n            trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n            if (trueStartTime > 0 && videoTime == -1) {\n              if (originalPresentationTime < trueStartTime) {\n                doRender=false;\n                if (BuildVars.LOGS_ENABLED) {\n                  FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                }\n              }\n else {\n                videoTime=info.presentationTimeUs;\n                if (minPresentationTime != Integer.MIN_VALUE) {\n                  additionalPresentationTime-=videoTime;\n                }\n              }\n            }\n            if (flushed) {\n              videoTime=-1;\n            }\n else {\n              if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                info.presentationTimeUs+=additionalPresentationTime;\n              }\n              decoder.releaseOutputBuffer(decoderStatus,doRender);\n            }\n            if (doRender) {\n              if (avatarStartTime >= 0) {\n                minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n              }\n              boolean errorWait=false;\n              try {\n                outputSurface.awaitNewImage();\n              }\n catch (              Exception e) {\n                errorWait=true;\n                FileLog.e(e);\n              }\n              if (!errorWait) {\n                outputSurface.drawImage();\n                inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                inputSurface.swapBuffers();\n              }\n            }\n            if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n              decoderOutputAvailable=false;\n              if (BuildVars.LOGS_ENABLED) {\n                FileLog.d(\"decoder stream end\");\n              }\n              encoder.signalEndOfInputStream();\n            }\n          }\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    if (e instanceof IllegalStateException && !increaseTimeout) {\n      repeatWithIncreasedTimeout=true;\n    }\n    FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n    FileLog.e(e);\n    error=true;\n  }\n  extractor.unselectTrack(videoIndex);\n  if (decoder != null) {\n    decoder.stop();\n    decoder.release();\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2098,
      "astHeight" : 31
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 29621,
        "startLineNumber" : 308,
        "startColumnNumber" : 54,
        "endLineNumber" : 743,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  AudioRecoder audioRecoder=null;\n  ByteBuffer audioBuffer=null;\n  boolean copyAudioBuffer=true;\n  if (videoIndex >= 0) {\n    MediaCodec decoder=null;\n    try {\n      long videoTime=-1;\n      boolean outputDone=false;\n      boolean inputDone=false;\n      boolean decoderDone=false;\n      int swapUV=0;\n      int audioTrackIndex=-5;\n      long additionalPresentationTime=0;\n      long minPresentationTime=Integer.MIN_VALUE;\n      long frameDelta=1000 / framerate * 1000;\n      extractor.selectTrack(videoIndex);\n      MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n      if (avatarStartTime >= 0) {\n        if (durationS <= 2000) {\n          bitrate=2600000;\n        }\n else         if (durationS <= 5000) {\n          bitrate=2200000;\n        }\n else {\n          bitrate=1560000;\n        }\n        avatarStartTime=0;\n      }\n else       if (bitrate <= 0) {\n        bitrate=921600;\n      }\n      if (originalBitrate > 0) {\n        bitrate=Math.min(originalBitrate,bitrate);\n      }\n      long trueStartTime;\n      if (avatarStartTime >= 0) {\n        avatarStartTime=-1;\n      }\n      if (avatarStartTime >= 0) {\n        extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n      }\n else       if (startTime > 0) {\n        extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n      }\n else {\n        extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n      }\n      int w;\n      int h;\n      if (cropState != null) {\n        if (rotationValue == 90 || rotationValue == 270) {\n          w=cropState.transformHeight;\n          h=cropState.transformWidth;\n        }\n else {\n          w=cropState.transformWidth;\n          h=cropState.transformHeight;\n        }\n      }\n else {\n        w=resultWidth;\n        h=resultHeight;\n      }\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n      }\n      MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n      outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n      outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n      outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n      outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n      if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n        if (bitrate > 921600) {\n          bitrate=921600;\n        }\n        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n      }\n      encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n      encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n      inputSurface=new InputSurface(encoder.createInputSurface());\n      inputSurface.makeCurrent();\n      encoder.start();\n      decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n      outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n      decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n      decoder.start();\n      ByteBuffer[] decoderInputBuffers=null;\n      ByteBuffer[] encoderOutputBuffers=null;\n      ByteBuffer[] encoderInputBuffers=null;\n      if (Build.VERSION.SDK_INT < 21) {\n        decoderInputBuffers=decoder.getInputBuffers();\n        encoderOutputBuffers=encoder.getOutputBuffers();\n      }\n      if (audioIndex >= 0) {\n        MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n        copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n        if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n          audioIndex=-1;\n        }\n        if (audioIndex >= 0) {\n          if (copyAudioBuffer) {\n            audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n            extractor.selectTrack(audioIndex);\n            int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n            audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n            if (startTime > 0) {\n              extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else {\n              extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n          }\n else {\n            MediaExtractor audioExtractor=new MediaExtractor();\n            audioExtractor.setDataSource(videoPath);\n            audioExtractor.selectTrack(audioIndex);\n            if (startTime > 0) {\n              audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else {\n              audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n            audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n            audioRecoder.startTime=startTime;\n            audioRecoder.endTime=endTime;\n            audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n          }\n        }\n      }\n      boolean audioEncoderDone=audioIndex < 0;\n      boolean firstEncode=true;\n      checkConversionCanceled();\n      while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n        checkConversionCanceled();\n        if (!copyAudioBuffer && audioRecoder != null) {\n          audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n        }\n        if (!inputDone) {\n          boolean eof=false;\n          int index=extractor.getSampleTrackIndex();\n          if (index == videoIndex) {\n            int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n            if (inputBufIndex >= 0) {\n              ByteBuffer inputBuf;\n              if (Build.VERSION.SDK_INT < 21) {\n                inputBuf=decoderInputBuffers[inputBufIndex];\n              }\n else {\n                inputBuf=decoder.getInputBuffer(inputBufIndex);\n              }\n              int chunkSize=extractor.readSampleData(inputBuf,0);\n              if (chunkSize < 0) {\n                decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                inputDone=true;\n              }\n else {\n                decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                extractor.advance();\n              }\n            }\n          }\n else           if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n            info.size=extractor.readSampleData(audioBuffer,0);\n            if (Build.VERSION.SDK_INT < 21) {\n              audioBuffer.position(0);\n              audioBuffer.limit(info.size);\n            }\n            if (info.size >= 0) {\n              info.presentationTimeUs=extractor.getSampleTime();\n              extractor.advance();\n            }\n else {\n              info.size=0;\n              inputDone=true;\n            }\n            if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n              info.offset=0;\n              info.flags=extractor.getSampleFlags();\n              long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n              if (availableSize != 0) {\n                if (callback != null) {\n                  if (info.presentationTimeUs - startTime > currentPts) {\n                    currentPts=info.presentationTimeUs - startTime;\n                  }\n                  callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                }\n              }\n            }\n          }\n else           if (index == -1) {\n            eof=true;\n          }\n          if (eof) {\n            int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n            if (inputBufIndex >= 0) {\n              decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n              inputDone=true;\n            }\n          }\n        }\n        boolean decoderOutputAvailable=!decoderDone;\n        boolean encoderOutputAvailable=true;\n        while (decoderOutputAvailable || encoderOutputAvailable) {\n          checkConversionCanceled();\n          int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n          if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n            encoderOutputAvailable=false;\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n            if (Build.VERSION.SDK_INT < 21) {\n              encoderOutputBuffers=encoder.getOutputBuffers();\n            }\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n            MediaFormat newFormat=encoder.getOutputFormat();\n            if (videoTrackIndex == -5 && newFormat != null) {\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n              }\n            }\n          }\n else           if (encoderStatus < 0) {\n            throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n          }\n else {\n            ByteBuffer encodedData;\n            if (Build.VERSION.SDK_INT < 21) {\n              encodedData=encoderOutputBuffers[encoderStatus];\n            }\n else {\n              encodedData=encoder.getOutputBuffer(encoderStatus);\n            }\n            if (encodedData == null) {\n              throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n            }\n            if (info.size > 1) {\n              if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  info.offset+=prependHeaderSize;\n                  info.size-=prependHeaderSize;\n                }\n                if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  if (info.size > 100) {\n                    encodedData.position(info.offset);\n                    byte[] temp=new byte[100];\n                    encodedData.get(temp);\n                    int nalCount=0;\n                    for (int a=0; a < temp.length - 4; a++) {\n                      if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                        nalCount++;\n                        if (nalCount > 1) {\n                          info.offset+=a;\n                          info.size-=a;\n                          break;\n                        }\n                      }\n                    }\n                  }\n                  firstEncode=false;\n                }\n                long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                if (availableSize != 0) {\n                  if (callback != null) {\n                    if (info.presentationTimeUs - startTime > currentPts) {\n                      currentPts=info.presentationTimeUs - startTime;\n                    }\n                    callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                  }\n                }\n              }\n else               if (videoTrackIndex == -5) {\n                byte[] csd=new byte[info.size];\n                encodedData.limit(info.offset + info.size);\n                encodedData.position(info.offset);\n                encodedData.get(csd);\n                ByteBuffer sps=null;\n                ByteBuffer pps=null;\n                for (int a=info.size - 1; a >= 0; a--) {\n                  if (a > 3) {\n                    if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                      sps=ByteBuffer.allocate(a - 3);\n                      pps=ByteBuffer.allocate(info.size - (a - 3));\n                      sps.put(csd,0,a - 3).position(0);\n                      pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                      break;\n                    }\n                  }\n else {\n                    break;\n                  }\n                }\n                MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                if (sps != null && pps != null) {\n                  newFormat.setByteBuffer(\"csd-0\",sps);\n                  newFormat.setByteBuffer(\"csd-1\",pps);\n                }\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              }\n            }\n            outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n            encoder.releaseOutputBuffer(encoderStatus,false);\n          }\n          if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n            continue;\n          }\n          if (!decoderDone) {\n            int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n            if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n              decoderOutputAvailable=false;\n            }\n else             if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n            }\n else             if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n              MediaFormat newFormat=decoder.getOutputFormat();\n              if (BuildVars.LOGS_ENABLED) {\n                FileLog.d(\"newFormat = \" + newFormat);\n              }\n            }\n else             if (decoderStatus < 0) {\n              throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n            }\n else {\n              boolean doRender=info.size != 0;\n              long originalPresentationTime=info.presentationTimeUs;\n              if (endTime > 0 && originalPresentationTime >= endTime) {\n                inputDone=true;\n                decoderDone=true;\n                doRender=false;\n                info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n              }\n              boolean flushed=false;\n              if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                if (startTime > 0) {\n                  extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n else {\n                  extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n                additionalPresentationTime=minPresentationTime + frameDelta;\n                endTime=avatarStartTime;\n                avatarStartTime=-1;\n                inputDone=false;\n                decoderDone=false;\n                doRender=false;\n                info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                decoder.flush();\n                flushed=true;\n              }\n              trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n              if (trueStartTime > 0 && videoTime == -1) {\n                if (originalPresentationTime < trueStartTime) {\n                  doRender=false;\n                  if (BuildVars.LOGS_ENABLED) {\n                    FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                  }\n                }\n else {\n                  videoTime=info.presentationTimeUs;\n                  if (minPresentationTime != Integer.MIN_VALUE) {\n                    additionalPresentationTime-=videoTime;\n                  }\n                }\n              }\n              if (flushed) {\n                videoTime=-1;\n              }\n else {\n                if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                  info.presentationTimeUs+=additionalPresentationTime;\n                }\n                decoder.releaseOutputBuffer(decoderStatus,doRender);\n              }\n              if (doRender) {\n                if (avatarStartTime >= 0) {\n                  minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                }\n                boolean errorWait=false;\n                try {\n                  outputSurface.awaitNewImage();\n                }\n catch (                Exception e) {\n                  errorWait=true;\n                  FileLog.e(e);\n                }\n                if (!errorWait) {\n                  outputSurface.drawImage();\n                  inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                  inputSurface.swapBuffers();\n                }\n              }\n              if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                decoderOutputAvailable=false;\n                if (BuildVars.LOGS_ENABLED) {\n                  FileLog.d(\"decoder stream end\");\n                }\n                encoder.signalEndOfInputStream();\n              }\n            }\n          }\n        }\n      }\n    }\n catch (    Exception e) {\n      if (e instanceof IllegalStateException && !increaseTimeout) {\n        repeatWithIncreasedTimeout=true;\n      }\n      FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n      FileLog.e(e);\n      error=true;\n    }\n    extractor.unselectTrack(videoIndex);\n    if (decoder != null) {\n      decoder.stop();\n      decoder.release();\n    }\n  }\n  if (outputSurface != null) {\n    outputSurface.release();\n  }\n  if (inputSurface != null) {\n    inputSurface.release();\n  }\n  if (encoder != null) {\n    encoder.stop();\n    encoder.release();\n  }\n  if (audioRecoder != null) {\n    audioRecoder.release();\n  }\n  checkConversionCanceled();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2159,
      "astHeight" : 32
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 29809,
        "startLineNumber" : 308,
        "startColumnNumber" : 16,
        "endLineNumber" : 745,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (needCompress || needConvertVideo) {\n  AudioRecoder audioRecoder=null;\n  ByteBuffer audioBuffer=null;\n  boolean copyAudioBuffer=true;\n  if (videoIndex >= 0) {\n    MediaCodec decoder=null;\n    try {\n      long videoTime=-1;\n      boolean outputDone=false;\n      boolean inputDone=false;\n      boolean decoderDone=false;\n      int swapUV=0;\n      int audioTrackIndex=-5;\n      long additionalPresentationTime=0;\n      long minPresentationTime=Integer.MIN_VALUE;\n      long frameDelta=1000 / framerate * 1000;\n      extractor.selectTrack(videoIndex);\n      MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n      if (avatarStartTime >= 0) {\n        if (durationS <= 2000) {\n          bitrate=2600000;\n        }\n else         if (durationS <= 5000) {\n          bitrate=2200000;\n        }\n else {\n          bitrate=1560000;\n        }\n        avatarStartTime=0;\n      }\n else       if (bitrate <= 0) {\n        bitrate=921600;\n      }\n      if (originalBitrate > 0) {\n        bitrate=Math.min(originalBitrate,bitrate);\n      }\n      long trueStartTime;\n      if (avatarStartTime >= 0) {\n        avatarStartTime=-1;\n      }\n      if (avatarStartTime >= 0) {\n        extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n      }\n else       if (startTime > 0) {\n        extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n      }\n else {\n        extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n      }\n      int w;\n      int h;\n      if (cropState != null) {\n        if (rotationValue == 90 || rotationValue == 270) {\n          w=cropState.transformHeight;\n          h=cropState.transformWidth;\n        }\n else {\n          w=cropState.transformWidth;\n          h=cropState.transformHeight;\n        }\n      }\n else {\n        w=resultWidth;\n        h=resultHeight;\n      }\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n      }\n      MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n      outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n      outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n      outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n      outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n      if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n        if (bitrate > 921600) {\n          bitrate=921600;\n        }\n        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n      }\n      encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n      encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n      inputSurface=new InputSurface(encoder.createInputSurface());\n      inputSurface.makeCurrent();\n      encoder.start();\n      decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n      outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n      decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n      decoder.start();\n      ByteBuffer[] decoderInputBuffers=null;\n      ByteBuffer[] encoderOutputBuffers=null;\n      ByteBuffer[] encoderInputBuffers=null;\n      if (Build.VERSION.SDK_INT < 21) {\n        decoderInputBuffers=decoder.getInputBuffers();\n        encoderOutputBuffers=encoder.getOutputBuffers();\n      }\n      if (audioIndex >= 0) {\n        MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n        copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n        if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n          audioIndex=-1;\n        }\n        if (audioIndex >= 0) {\n          if (copyAudioBuffer) {\n            audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n            extractor.selectTrack(audioIndex);\n            int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n            audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n            if (startTime > 0) {\n              extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else {\n              extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n          }\n else {\n            MediaExtractor audioExtractor=new MediaExtractor();\n            audioExtractor.setDataSource(videoPath);\n            audioExtractor.selectTrack(audioIndex);\n            if (startTime > 0) {\n              audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else {\n              audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n            audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n            audioRecoder.startTime=startTime;\n            audioRecoder.endTime=endTime;\n            audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n          }\n        }\n      }\n      boolean audioEncoderDone=audioIndex < 0;\n      boolean firstEncode=true;\n      checkConversionCanceled();\n      while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n        checkConversionCanceled();\n        if (!copyAudioBuffer && audioRecoder != null) {\n          audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n        }\n        if (!inputDone) {\n          boolean eof=false;\n          int index=extractor.getSampleTrackIndex();\n          if (index == videoIndex) {\n            int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n            if (inputBufIndex >= 0) {\n              ByteBuffer inputBuf;\n              if (Build.VERSION.SDK_INT < 21) {\n                inputBuf=decoderInputBuffers[inputBufIndex];\n              }\n else {\n                inputBuf=decoder.getInputBuffer(inputBufIndex);\n              }\n              int chunkSize=extractor.readSampleData(inputBuf,0);\n              if (chunkSize < 0) {\n                decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                inputDone=true;\n              }\n else {\n                decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                extractor.advance();\n              }\n            }\n          }\n else           if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n            info.size=extractor.readSampleData(audioBuffer,0);\n            if (Build.VERSION.SDK_INT < 21) {\n              audioBuffer.position(0);\n              audioBuffer.limit(info.size);\n            }\n            if (info.size >= 0) {\n              info.presentationTimeUs=extractor.getSampleTime();\n              extractor.advance();\n            }\n else {\n              info.size=0;\n              inputDone=true;\n            }\n            if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n              info.offset=0;\n              info.flags=extractor.getSampleFlags();\n              long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n              if (availableSize != 0) {\n                if (callback != null) {\n                  if (info.presentationTimeUs - startTime > currentPts) {\n                    currentPts=info.presentationTimeUs - startTime;\n                  }\n                  callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                }\n              }\n            }\n          }\n else           if (index == -1) {\n            eof=true;\n          }\n          if (eof) {\n            int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n            if (inputBufIndex >= 0) {\n              decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n              inputDone=true;\n            }\n          }\n        }\n        boolean decoderOutputAvailable=!decoderDone;\n        boolean encoderOutputAvailable=true;\n        while (decoderOutputAvailable || encoderOutputAvailable) {\n          checkConversionCanceled();\n          int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n          if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n            encoderOutputAvailable=false;\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n            if (Build.VERSION.SDK_INT < 21) {\n              encoderOutputBuffers=encoder.getOutputBuffers();\n            }\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n            MediaFormat newFormat=encoder.getOutputFormat();\n            if (videoTrackIndex == -5 && newFormat != null) {\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n              }\n            }\n          }\n else           if (encoderStatus < 0) {\n            throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n          }\n else {\n            ByteBuffer encodedData;\n            if (Build.VERSION.SDK_INT < 21) {\n              encodedData=encoderOutputBuffers[encoderStatus];\n            }\n else {\n              encodedData=encoder.getOutputBuffer(encoderStatus);\n            }\n            if (encodedData == null) {\n              throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n            }\n            if (info.size > 1) {\n              if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  info.offset+=prependHeaderSize;\n                  info.size-=prependHeaderSize;\n                }\n                if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  if (info.size > 100) {\n                    encodedData.position(info.offset);\n                    byte[] temp=new byte[100];\n                    encodedData.get(temp);\n                    int nalCount=0;\n                    for (int a=0; a < temp.length - 4; a++) {\n                      if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                        nalCount++;\n                        if (nalCount > 1) {\n                          info.offset+=a;\n                          info.size-=a;\n                          break;\n                        }\n                      }\n                    }\n                  }\n                  firstEncode=false;\n                }\n                long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                if (availableSize != 0) {\n                  if (callback != null) {\n                    if (info.presentationTimeUs - startTime > currentPts) {\n                      currentPts=info.presentationTimeUs - startTime;\n                    }\n                    callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                  }\n                }\n              }\n else               if (videoTrackIndex == -5) {\n                byte[] csd=new byte[info.size];\n                encodedData.limit(info.offset + info.size);\n                encodedData.position(info.offset);\n                encodedData.get(csd);\n                ByteBuffer sps=null;\n                ByteBuffer pps=null;\n                for (int a=info.size - 1; a >= 0; a--) {\n                  if (a > 3) {\n                    if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                      sps=ByteBuffer.allocate(a - 3);\n                      pps=ByteBuffer.allocate(info.size - (a - 3));\n                      sps.put(csd,0,a - 3).position(0);\n                      pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                      break;\n                    }\n                  }\n else {\n                    break;\n                  }\n                }\n                MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                if (sps != null && pps != null) {\n                  newFormat.setByteBuffer(\"csd-0\",sps);\n                  newFormat.setByteBuffer(\"csd-1\",pps);\n                }\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              }\n            }\n            outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n            encoder.releaseOutputBuffer(encoderStatus,false);\n          }\n          if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n            continue;\n          }\n          if (!decoderDone) {\n            int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n            if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n              decoderOutputAvailable=false;\n            }\n else             if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n            }\n else             if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n              MediaFormat newFormat=decoder.getOutputFormat();\n              if (BuildVars.LOGS_ENABLED) {\n                FileLog.d(\"newFormat = \" + newFormat);\n              }\n            }\n else             if (decoderStatus < 0) {\n              throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n            }\n else {\n              boolean doRender=info.size != 0;\n              long originalPresentationTime=info.presentationTimeUs;\n              if (endTime > 0 && originalPresentationTime >= endTime) {\n                inputDone=true;\n                decoderDone=true;\n                doRender=false;\n                info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n              }\n              boolean flushed=false;\n              if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                if (startTime > 0) {\n                  extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n else {\n                  extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n                additionalPresentationTime=minPresentationTime + frameDelta;\n                endTime=avatarStartTime;\n                avatarStartTime=-1;\n                inputDone=false;\n                decoderDone=false;\n                doRender=false;\n                info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                decoder.flush();\n                flushed=true;\n              }\n              trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n              if (trueStartTime > 0 && videoTime == -1) {\n                if (originalPresentationTime < trueStartTime) {\n                  doRender=false;\n                  if (BuildVars.LOGS_ENABLED) {\n                    FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                  }\n                }\n else {\n                  videoTime=info.presentationTimeUs;\n                  if (minPresentationTime != Integer.MIN_VALUE) {\n                    additionalPresentationTime-=videoTime;\n                  }\n                }\n              }\n              if (flushed) {\n                videoTime=-1;\n              }\n else {\n                if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                  info.presentationTimeUs+=additionalPresentationTime;\n                }\n                decoder.releaseOutputBuffer(decoderStatus,doRender);\n              }\n              if (doRender) {\n                if (avatarStartTime >= 0) {\n                  minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                }\n                boolean errorWait=false;\n                try {\n                  outputSurface.awaitNewImage();\n                }\n catch (                Exception e) {\n                  errorWait=true;\n                  FileLog.e(e);\n                }\n                if (!errorWait) {\n                  outputSurface.drawImage();\n                  inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                  inputSurface.swapBuffers();\n                }\n              }\n              if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                decoderOutputAvailable=false;\n                if (BuildVars.LOGS_ENABLED) {\n                  FileLog.d(\"decoder stream end\");\n                }\n                encoder.signalEndOfInputStream();\n              }\n            }\n          }\n        }\n      }\n    }\n catch (    Exception e) {\n      if (e instanceof IllegalStateException && !increaseTimeout) {\n        repeatWithIncreasedTimeout=true;\n      }\n      FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n      FileLog.e(e);\n      error=true;\n    }\n    extractor.unselectTrack(videoIndex);\n    if (decoder != null) {\n      decoder.stop();\n      decoder.release();\n    }\n  }\n  if (outputSurface != null) {\n    outputSurface.release();\n  }\n  if (inputSurface != null) {\n    inputSurface.release();\n  }\n  if (encoder != null) {\n    encoder.stop();\n    encoder.release();\n  }\n  if (audioRecoder != null) {\n    audioRecoder.release();\n  }\n  checkConversionCanceled();\n}\n else {\n  readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 2178,
      "astHeight" : 33
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 30386,
        "startLineNumber" : 297,
        "startColumnNumber" : 19,
        "endLineNumber" : 746,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  extractor=new MediaExtractor();\n  extractor.setDataSource(videoPath);\n  int videoIndex=MediaController.findTrack(extractor,false);\n  int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n  boolean needConvertVideo=false;\n  if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n    needConvertVideo=true;\n  }\n  if (needCompress || needConvertVideo) {\n    AudioRecoder audioRecoder=null;\n    ByteBuffer audioBuffer=null;\n    boolean copyAudioBuffer=true;\n    if (videoIndex >= 0) {\n      MediaCodec decoder=null;\n      try {\n        long videoTime=-1;\n        boolean outputDone=false;\n        boolean inputDone=false;\n        boolean decoderDone=false;\n        int swapUV=0;\n        int audioTrackIndex=-5;\n        long additionalPresentationTime=0;\n        long minPresentationTime=Integer.MIN_VALUE;\n        long frameDelta=1000 / framerate * 1000;\n        extractor.selectTrack(videoIndex);\n        MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n        if (avatarStartTime >= 0) {\n          if (durationS <= 2000) {\n            bitrate=2600000;\n          }\n else           if (durationS <= 5000) {\n            bitrate=2200000;\n          }\n else {\n            bitrate=1560000;\n          }\n          avatarStartTime=0;\n        }\n else         if (bitrate <= 0) {\n          bitrate=921600;\n        }\n        if (originalBitrate > 0) {\n          bitrate=Math.min(originalBitrate,bitrate);\n        }\n        long trueStartTime;\n        if (avatarStartTime >= 0) {\n          avatarStartTime=-1;\n        }\n        if (avatarStartTime >= 0) {\n          extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else         if (startTime > 0) {\n          extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else {\n          extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n        int w;\n        int h;\n        if (cropState != null) {\n          if (rotationValue == 90 || rotationValue == 270) {\n            w=cropState.transformHeight;\n            h=cropState.transformWidth;\n          }\n else {\n            w=cropState.transformWidth;\n            h=cropState.transformHeight;\n          }\n        }\n else {\n          w=resultWidth;\n          h=resultHeight;\n        }\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n        }\n        MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n        if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n          if (bitrate > 921600) {\n            bitrate=921600;\n          }\n          outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n        }\n        encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n        encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n        inputSurface=new InputSurface(encoder.createInputSurface());\n        inputSurface.makeCurrent();\n        encoder.start();\n        decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n        outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n        decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n        decoder.start();\n        ByteBuffer[] decoderInputBuffers=null;\n        ByteBuffer[] encoderOutputBuffers=null;\n        ByteBuffer[] encoderInputBuffers=null;\n        if (Build.VERSION.SDK_INT < 21) {\n          decoderInputBuffers=decoder.getInputBuffers();\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n        if (audioIndex >= 0) {\n          MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n          copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n          if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n            audioIndex=-1;\n          }\n          if (audioIndex >= 0) {\n            if (copyAudioBuffer) {\n              audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n              extractor.selectTrack(audioIndex);\n              int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n              audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n              if (startTime > 0) {\n                extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n else {\n                extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n            }\n else {\n              MediaExtractor audioExtractor=new MediaExtractor();\n              audioExtractor.setDataSource(videoPath);\n              audioExtractor.selectTrack(audioIndex);\n              if (startTime > 0) {\n                audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n else {\n                audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n              audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n              audioRecoder.startTime=startTime;\n              audioRecoder.endTime=endTime;\n              audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n            }\n          }\n        }\n        boolean audioEncoderDone=audioIndex < 0;\n        boolean firstEncode=true;\n        checkConversionCanceled();\n        while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n          checkConversionCanceled();\n          if (!copyAudioBuffer && audioRecoder != null) {\n            audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n          }\n          if (!inputDone) {\n            boolean eof=false;\n            int index=extractor.getSampleTrackIndex();\n            if (index == videoIndex) {\n              int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n              if (inputBufIndex >= 0) {\n                ByteBuffer inputBuf;\n                if (Build.VERSION.SDK_INT < 21) {\n                  inputBuf=decoderInputBuffers[inputBufIndex];\n                }\n else {\n                  inputBuf=decoder.getInputBuffer(inputBufIndex);\n                }\n                int chunkSize=extractor.readSampleData(inputBuf,0);\n                if (chunkSize < 0) {\n                  decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                  inputDone=true;\n                }\n else {\n                  decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                  extractor.advance();\n                }\n              }\n            }\n else             if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n              info.size=extractor.readSampleData(audioBuffer,0);\n              if (Build.VERSION.SDK_INT < 21) {\n                audioBuffer.position(0);\n                audioBuffer.limit(info.size);\n              }\n              if (info.size >= 0) {\n                info.presentationTimeUs=extractor.getSampleTime();\n                extractor.advance();\n              }\n else {\n                info.size=0;\n                inputDone=true;\n              }\n              if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                info.offset=0;\n                info.flags=extractor.getSampleFlags();\n                long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                if (availableSize != 0) {\n                  if (callback != null) {\n                    if (info.presentationTimeUs - startTime > currentPts) {\n                      currentPts=info.presentationTimeUs - startTime;\n                    }\n                    callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                  }\n                }\n              }\n            }\n else             if (index == -1) {\n              eof=true;\n            }\n            if (eof) {\n              int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n              if (inputBufIndex >= 0) {\n                decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                inputDone=true;\n              }\n            }\n          }\n          boolean decoderOutputAvailable=!decoderDone;\n          boolean encoderOutputAvailable=true;\n          while (decoderOutputAvailable || encoderOutputAvailable) {\n            checkConversionCanceled();\n            int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n            if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n              encoderOutputAvailable=false;\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n              if (Build.VERSION.SDK_INT < 21) {\n                encoderOutputBuffers=encoder.getOutputBuffers();\n              }\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n              MediaFormat newFormat=encoder.getOutputFormat();\n              if (videoTrackIndex == -5 && newFormat != null) {\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                  ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                  ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                  prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                }\n              }\n            }\n else             if (encoderStatus < 0) {\n              throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n            }\n else {\n              ByteBuffer encodedData;\n              if (Build.VERSION.SDK_INT < 21) {\n                encodedData=encoderOutputBuffers[encoderStatus];\n              }\n else {\n                encodedData=encoder.getOutputBuffer(encoderStatus);\n              }\n              if (encodedData == null) {\n                throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n              }\n              if (info.size > 1) {\n                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                  if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    info.offset+=prependHeaderSize;\n                    info.size-=prependHeaderSize;\n                  }\n                  if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    if (info.size > 100) {\n                      encodedData.position(info.offset);\n                      byte[] temp=new byte[100];\n                      encodedData.get(temp);\n                      int nalCount=0;\n                      for (int a=0; a < temp.length - 4; a++) {\n                        if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                          nalCount++;\n                          if (nalCount > 1) {\n                            info.offset+=a;\n                            info.size-=a;\n                            break;\n                          }\n                        }\n                      }\n                    }\n                    firstEncode=false;\n                  }\n                  long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      if (info.presentationTimeUs - startTime > currentPts) {\n                        currentPts=info.presentationTimeUs - startTime;\n                      }\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n else                 if (videoTrackIndex == -5) {\n                  byte[] csd=new byte[info.size];\n                  encodedData.limit(info.offset + info.size);\n                  encodedData.position(info.offset);\n                  encodedData.get(csd);\n                  ByteBuffer sps=null;\n                  ByteBuffer pps=null;\n                  for (int a=info.size - 1; a >= 0; a--) {\n                    if (a > 3) {\n                      if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                        sps=ByteBuffer.allocate(a - 3);\n                        pps=ByteBuffer.allocate(info.size - (a - 3));\n                        sps.put(csd,0,a - 3).position(0);\n                        pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                        break;\n                      }\n                    }\n else {\n                      break;\n                    }\n                  }\n                  MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                  if (sps != null && pps != null) {\n                    newFormat.setByteBuffer(\"csd-0\",sps);\n                    newFormat.setByteBuffer(\"csd-1\",pps);\n                  }\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                }\n              }\n              outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n              encoder.releaseOutputBuffer(encoderStatus,false);\n            }\n            if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n              continue;\n            }\n            if (!decoderDone) {\n              int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n              if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                decoderOutputAvailable=false;\n              }\n else               if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n              }\n else               if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                MediaFormat newFormat=decoder.getOutputFormat();\n                if (BuildVars.LOGS_ENABLED) {\n                  FileLog.d(\"newFormat = \" + newFormat);\n                }\n              }\n else               if (decoderStatus < 0) {\n                throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n              }\n else {\n                boolean doRender=info.size != 0;\n                long originalPresentationTime=info.presentationTimeUs;\n                if (endTime > 0 && originalPresentationTime >= endTime) {\n                  inputDone=true;\n                  decoderDone=true;\n                  doRender=false;\n                  info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                }\n                boolean flushed=false;\n                if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                  if (startTime > 0) {\n                    extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                  additionalPresentationTime=minPresentationTime + frameDelta;\n                  endTime=avatarStartTime;\n                  avatarStartTime=-1;\n                  inputDone=false;\n                  decoderDone=false;\n                  doRender=false;\n                  info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                  decoder.flush();\n                  flushed=true;\n                }\n                trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                if (trueStartTime > 0 && videoTime == -1) {\n                  if (originalPresentationTime < trueStartTime) {\n                    doRender=false;\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                    }\n                  }\n else {\n                    videoTime=info.presentationTimeUs;\n                    if (minPresentationTime != Integer.MIN_VALUE) {\n                      additionalPresentationTime-=videoTime;\n                    }\n                  }\n                }\n                if (flushed) {\n                  videoTime=-1;\n                }\n else {\n                  if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                    info.presentationTimeUs+=additionalPresentationTime;\n                  }\n                  decoder.releaseOutputBuffer(decoderStatus,doRender);\n                }\n                if (doRender) {\n                  if (avatarStartTime >= 0) {\n                    minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                  }\n                  boolean errorWait=false;\n                  try {\n                    outputSurface.awaitNewImage();\n                  }\n catch (                  Exception e) {\n                    errorWait=true;\n                    FileLog.e(e);\n                  }\n                  if (!errorWait) {\n                    outputSurface.drawImage();\n                    inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                    inputSurface.swapBuffers();\n                  }\n                }\n                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                  decoderOutputAvailable=false;\n                  if (BuildVars.LOGS_ENABLED) {\n                    FileLog.d(\"decoder stream end\");\n                  }\n                  encoder.signalEndOfInputStream();\n                }\n              }\n            }\n          }\n        }\n      }\n catch (      Exception e) {\n        if (e instanceof IllegalStateException && !increaseTimeout) {\n          repeatWithIncreasedTimeout=true;\n        }\n        FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n        FileLog.e(e);\n        error=true;\n      }\n      extractor.unselectTrack(videoIndex);\n      if (decoder != null) {\n        decoder.stop();\n        decoder.release();\n      }\n    }\n    if (outputSurface != null) {\n      outputSurface.release();\n    }\n    if (inputSurface != null) {\n      inputSurface.release();\n    }\n    if (encoder != null) {\n      encoder.stop();\n      encoder.release();\n    }\n    if (audioRecoder != null) {\n      audioRecoder.release();\n    }\n    checkConversionCanceled();\n  }\n else {\n    readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 2245,
      "astHeight" : 34
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 42785,
        "startLineNumber" : 94,
        "startColumnNumber" : 12,
        "endLineNumber" : 746,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (isPhoto) {\n  try {\n    boolean outputDone=false;\n    boolean decoderDone=false;\n    int framesCount=0;\n    if (avatarStartTime >= 0) {\n      if (durationS <= 2000) {\n        bitrate=2600000;\n      }\n else       if (durationS <= 5000) {\n        bitrate=2200000;\n      }\n else {\n        bitrate=1560000;\n      }\n    }\n else     if (bitrate <= 0) {\n      bitrate=921600;\n    }\n    if (resultWidth % 16 != 0) {\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n      }\n      resultWidth=Math.round(resultWidth / 16.0f) * 16;\n    }\n    if (resultHeight % 16 != 0) {\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n      }\n      resultHeight=Math.round(resultHeight / 16.0f) * 16;\n    }\n    if (BuildVars.LOGS_ENABLED) {\n      FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n    }\n    MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n    outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n    outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n    outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n    outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n    encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n    encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n    inputSurface=new InputSurface(encoder.createInputSurface());\n    inputSurface.makeCurrent();\n    encoder.start();\n    outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n    ByteBuffer[] encoderOutputBuffers=null;\n    ByteBuffer[] encoderInputBuffers=null;\n    if (Build.VERSION.SDK_INT < 21) {\n      encoderOutputBuffers=encoder.getOutputBuffers();\n    }\n    boolean firstEncode=true;\n    checkConversionCanceled();\n    while (!outputDone) {\n      checkConversionCanceled();\n      boolean decoderOutputAvailable=!decoderDone;\n      boolean encoderOutputAvailable=true;\n      while (decoderOutputAvailable || encoderOutputAvailable) {\n        checkConversionCanceled();\n        int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n        if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n          encoderOutputAvailable=false;\n        }\n else         if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n          if (Build.VERSION.SDK_INT < 21) {\n            encoderOutputBuffers=encoder.getOutputBuffers();\n          }\n        }\n else         if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n          MediaFormat newFormat=encoder.getOutputFormat();\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"photo encoder new format \" + newFormat);\n          }\n          if (videoTrackIndex == -5 && newFormat != null) {\n            videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n            if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n              ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n              ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n              prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n            }\n          }\n        }\n else         if (encoderStatus < 0) {\n          throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n        }\n else {\n          ByteBuffer encodedData;\n          if (Build.VERSION.SDK_INT < 21) {\n            encodedData=encoderOutputBuffers[encoderStatus];\n          }\n else {\n            encodedData=encoder.getOutputBuffer(encoderStatus);\n          }\n          if (encodedData == null) {\n            throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n          }\n          if (info.size > 1) {\n            if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n              if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                info.offset+=prependHeaderSize;\n                info.size-=prependHeaderSize;\n              }\n              if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                if (info.size > 100) {\n                  encodedData.position(info.offset);\n                  byte[] temp=new byte[100];\n                  encodedData.get(temp);\n                  int nalCount=0;\n                  for (int a=0; a < temp.length - 4; a++) {\n                    if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                      nalCount++;\n                      if (nalCount > 1) {\n                        info.offset+=a;\n                        info.size-=a;\n                        break;\n                      }\n                    }\n                  }\n                }\n                firstEncode=false;\n              }\n              long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n              if (availableSize != 0) {\n                if (callback != null) {\n                  callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                }\n              }\n            }\n else             if (videoTrackIndex == -5) {\n              byte[] csd=new byte[info.size];\n              encodedData.limit(info.offset + info.size);\n              encodedData.position(info.offset);\n              encodedData.get(csd);\n              ByteBuffer sps=null;\n              ByteBuffer pps=null;\n              for (int a=info.size - 1; a >= 0; a--) {\n                if (a > 3) {\n                  if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                    sps=ByteBuffer.allocate(a - 3);\n                    pps=ByteBuffer.allocate(info.size - (a - 3));\n                    sps.put(csd,0,a - 3).position(0);\n                    pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                    break;\n                  }\n                }\n else {\n                  break;\n                }\n              }\n              MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n              if (sps != null && pps != null) {\n                newFormat.setByteBuffer(\"csd-0\",sps);\n                newFormat.setByteBuffer(\"csd-1\",pps);\n              }\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n            }\n          }\n          outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n          encoder.releaseOutputBuffer(encoderStatus,false);\n        }\n        if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n          continue;\n        }\n        if (!decoderDone) {\n          outputSurface.drawImage();\n          long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n          inputSurface.setPresentationTime(presentationTime);\n          inputSurface.swapBuffers();\n          framesCount++;\n          if (framesCount >= duration / 1000.0f * 30) {\n            decoderDone=true;\n            decoderOutputAvailable=false;\n            encoder.signalEndOfInputStream();\n          }\n        }\n      }\n    }\n  }\n catch (  Exception e) {\n    if (e instanceof IllegalStateException && !increaseTimeout) {\n      repeatWithIncreasedTimeout=true;\n    }\n    FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n    FileLog.e(e);\n    error=true;\n  }\n  if (outputSurface != null) {\n    outputSurface.release();\n  }\n  if (inputSurface != null) {\n    inputSurface.release();\n  }\n  if (encoder != null) {\n    encoder.stop();\n    encoder.release();\n  }\n  checkConversionCanceled();\n}\n else {\n  extractor=new MediaExtractor();\n  extractor.setDataSource(videoPath);\n  int videoIndex=MediaController.findTrack(extractor,false);\n  int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n  boolean needConvertVideo=false;\n  if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n    needConvertVideo=true;\n  }\n  if (needCompress || needConvertVideo) {\n    AudioRecoder audioRecoder=null;\n    ByteBuffer audioBuffer=null;\n    boolean copyAudioBuffer=true;\n    if (videoIndex >= 0) {\n      MediaCodec decoder=null;\n      try {\n        long videoTime=-1;\n        boolean outputDone=false;\n        boolean inputDone=false;\n        boolean decoderDone=false;\n        int swapUV=0;\n        int audioTrackIndex=-5;\n        long additionalPresentationTime=0;\n        long minPresentationTime=Integer.MIN_VALUE;\n        long frameDelta=1000 / framerate * 1000;\n        extractor.selectTrack(videoIndex);\n        MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n        if (avatarStartTime >= 0) {\n          if (durationS <= 2000) {\n            bitrate=2600000;\n          }\n else           if (durationS <= 5000) {\n            bitrate=2200000;\n          }\n else {\n            bitrate=1560000;\n          }\n          avatarStartTime=0;\n        }\n else         if (bitrate <= 0) {\n          bitrate=921600;\n        }\n        if (originalBitrate > 0) {\n          bitrate=Math.min(originalBitrate,bitrate);\n        }\n        long trueStartTime;\n        if (avatarStartTime >= 0) {\n          avatarStartTime=-1;\n        }\n        if (avatarStartTime >= 0) {\n          extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else         if (startTime > 0) {\n          extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n else {\n          extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n        }\n        int w;\n        int h;\n        if (cropState != null) {\n          if (rotationValue == 90 || rotationValue == 270) {\n            w=cropState.transformHeight;\n            h=cropState.transformWidth;\n          }\n else {\n            w=cropState.transformWidth;\n            h=cropState.transformHeight;\n          }\n        }\n else {\n          w=resultWidth;\n          h=resultHeight;\n        }\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n        }\n        MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n        if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n          if (bitrate > 921600) {\n            bitrate=921600;\n          }\n          outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n        }\n        encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n        encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n        inputSurface=new InputSurface(encoder.createInputSurface());\n        inputSurface.makeCurrent();\n        encoder.start();\n        decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n        outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n        decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n        decoder.start();\n        ByteBuffer[] decoderInputBuffers=null;\n        ByteBuffer[] encoderOutputBuffers=null;\n        ByteBuffer[] encoderInputBuffers=null;\n        if (Build.VERSION.SDK_INT < 21) {\n          decoderInputBuffers=decoder.getInputBuffers();\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n        if (audioIndex >= 0) {\n          MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n          copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n          if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n            audioIndex=-1;\n          }\n          if (audioIndex >= 0) {\n            if (copyAudioBuffer) {\n              audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n              extractor.selectTrack(audioIndex);\n              int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n              audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n              if (startTime > 0) {\n                extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n else {\n                extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n            }\n else {\n              MediaExtractor audioExtractor=new MediaExtractor();\n              audioExtractor.setDataSource(videoPath);\n              audioExtractor.selectTrack(audioIndex);\n              if (startTime > 0) {\n                audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n else {\n                audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n              }\n              audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n              audioRecoder.startTime=startTime;\n              audioRecoder.endTime=endTime;\n              audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n            }\n          }\n        }\n        boolean audioEncoderDone=audioIndex < 0;\n        boolean firstEncode=true;\n        checkConversionCanceled();\n        while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n          checkConversionCanceled();\n          if (!copyAudioBuffer && audioRecoder != null) {\n            audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n          }\n          if (!inputDone) {\n            boolean eof=false;\n            int index=extractor.getSampleTrackIndex();\n            if (index == videoIndex) {\n              int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n              if (inputBufIndex >= 0) {\n                ByteBuffer inputBuf;\n                if (Build.VERSION.SDK_INT < 21) {\n                  inputBuf=decoderInputBuffers[inputBufIndex];\n                }\n else {\n                  inputBuf=decoder.getInputBuffer(inputBufIndex);\n                }\n                int chunkSize=extractor.readSampleData(inputBuf,0);\n                if (chunkSize < 0) {\n                  decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                  inputDone=true;\n                }\n else {\n                  decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                  extractor.advance();\n                }\n              }\n            }\n else             if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n              info.size=extractor.readSampleData(audioBuffer,0);\n              if (Build.VERSION.SDK_INT < 21) {\n                audioBuffer.position(0);\n                audioBuffer.limit(info.size);\n              }\n              if (info.size >= 0) {\n                info.presentationTimeUs=extractor.getSampleTime();\n                extractor.advance();\n              }\n else {\n                info.size=0;\n                inputDone=true;\n              }\n              if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                info.offset=0;\n                info.flags=extractor.getSampleFlags();\n                long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                if (availableSize != 0) {\n                  if (callback != null) {\n                    if (info.presentationTimeUs - startTime > currentPts) {\n                      currentPts=info.presentationTimeUs - startTime;\n                    }\n                    callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                  }\n                }\n              }\n            }\n else             if (index == -1) {\n              eof=true;\n            }\n            if (eof) {\n              int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n              if (inputBufIndex >= 0) {\n                decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                inputDone=true;\n              }\n            }\n          }\n          boolean decoderOutputAvailable=!decoderDone;\n          boolean encoderOutputAvailable=true;\n          while (decoderOutputAvailable || encoderOutputAvailable) {\n            checkConversionCanceled();\n            int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n            if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n              encoderOutputAvailable=false;\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n              if (Build.VERSION.SDK_INT < 21) {\n                encoderOutputBuffers=encoder.getOutputBuffers();\n              }\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n              MediaFormat newFormat=encoder.getOutputFormat();\n              if (videoTrackIndex == -5 && newFormat != null) {\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                  ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                  ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                  prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                }\n              }\n            }\n else             if (encoderStatus < 0) {\n              throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n            }\n else {\n              ByteBuffer encodedData;\n              if (Build.VERSION.SDK_INT < 21) {\n                encodedData=encoderOutputBuffers[encoderStatus];\n              }\n else {\n                encodedData=encoder.getOutputBuffer(encoderStatus);\n              }\n              if (encodedData == null) {\n                throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n              }\n              if (info.size > 1) {\n                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                  if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    info.offset+=prependHeaderSize;\n                    info.size-=prependHeaderSize;\n                  }\n                  if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    if (info.size > 100) {\n                      encodedData.position(info.offset);\n                      byte[] temp=new byte[100];\n                      encodedData.get(temp);\n                      int nalCount=0;\n                      for (int a=0; a < temp.length - 4; a++) {\n                        if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                          nalCount++;\n                          if (nalCount > 1) {\n                            info.offset+=a;\n                            info.size-=a;\n                            break;\n                          }\n                        }\n                      }\n                    }\n                    firstEncode=false;\n                  }\n                  long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      if (info.presentationTimeUs - startTime > currentPts) {\n                        currentPts=info.presentationTimeUs - startTime;\n                      }\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n else                 if (videoTrackIndex == -5) {\n                  byte[] csd=new byte[info.size];\n                  encodedData.limit(info.offset + info.size);\n                  encodedData.position(info.offset);\n                  encodedData.get(csd);\n                  ByteBuffer sps=null;\n                  ByteBuffer pps=null;\n                  for (int a=info.size - 1; a >= 0; a--) {\n                    if (a > 3) {\n                      if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                        sps=ByteBuffer.allocate(a - 3);\n                        pps=ByteBuffer.allocate(info.size - (a - 3));\n                        sps.put(csd,0,a - 3).position(0);\n                        pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                        break;\n                      }\n                    }\n else {\n                      break;\n                    }\n                  }\n                  MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                  if (sps != null && pps != null) {\n                    newFormat.setByteBuffer(\"csd-0\",sps);\n                    newFormat.setByteBuffer(\"csd-1\",pps);\n                  }\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                }\n              }\n              outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n              encoder.releaseOutputBuffer(encoderStatus,false);\n            }\n            if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n              continue;\n            }\n            if (!decoderDone) {\n              int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n              if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                decoderOutputAvailable=false;\n              }\n else               if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n              }\n else               if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                MediaFormat newFormat=decoder.getOutputFormat();\n                if (BuildVars.LOGS_ENABLED) {\n                  FileLog.d(\"newFormat = \" + newFormat);\n                }\n              }\n else               if (decoderStatus < 0) {\n                throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n              }\n else {\n                boolean doRender=info.size != 0;\n                long originalPresentationTime=info.presentationTimeUs;\n                if (endTime > 0 && originalPresentationTime >= endTime) {\n                  inputDone=true;\n                  decoderDone=true;\n                  doRender=false;\n                  info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                }\n                boolean flushed=false;\n                if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                  if (startTime > 0) {\n                    extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                  additionalPresentationTime=minPresentationTime + frameDelta;\n                  endTime=avatarStartTime;\n                  avatarStartTime=-1;\n                  inputDone=false;\n                  decoderDone=false;\n                  doRender=false;\n                  info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                  decoder.flush();\n                  flushed=true;\n                }\n                trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                if (trueStartTime > 0 && videoTime == -1) {\n                  if (originalPresentationTime < trueStartTime) {\n                    doRender=false;\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                    }\n                  }\n else {\n                    videoTime=info.presentationTimeUs;\n                    if (minPresentationTime != Integer.MIN_VALUE) {\n                      additionalPresentationTime-=videoTime;\n                    }\n                  }\n                }\n                if (flushed) {\n                  videoTime=-1;\n                }\n else {\n                  if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                    info.presentationTimeUs+=additionalPresentationTime;\n                  }\n                  decoder.releaseOutputBuffer(decoderStatus,doRender);\n                }\n                if (doRender) {\n                  if (avatarStartTime >= 0) {\n                    minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                  }\n                  boolean errorWait=false;\n                  try {\n                    outputSurface.awaitNewImage();\n                  }\n catch (                  Exception e) {\n                    errorWait=true;\n                    FileLog.e(e);\n                  }\n                  if (!errorWait) {\n                    outputSurface.drawImage();\n                    inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                    inputSurface.swapBuffers();\n                  }\n                }\n                if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                  decoderOutputAvailable=false;\n                  if (BuildVars.LOGS_ENABLED) {\n                    FileLog.d(\"decoder stream end\");\n                  }\n                  encoder.signalEndOfInputStream();\n                }\n              }\n            }\n          }\n        }\n      }\n catch (      Exception e) {\n        if (e instanceof IllegalStateException && !increaseTimeout) {\n          repeatWithIncreasedTimeout=true;\n        }\n        FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n        FileLog.e(e);\n        error=true;\n      }\n      extractor.unselectTrack(videoIndex);\n      if (decoder != null) {\n        decoder.stop();\n        decoder.release();\n      }\n    }\n    if (outputSurface != null) {\n      outputSurface.release();\n    }\n    if (inputSurface != null) {\n      inputSurface.release();\n    }\n    if (encoder != null) {\n      encoder.stop();\n      encoder.release();\n    }\n    if (audioRecoder != null) {\n      audioRecoder.release();\n    }\n    checkConversionCanceled();\n  }\n else {\n    readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 3315,
      "astHeight" : 35
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 43472,
        "startLineNumber" : 77,
        "startColumnNumber" : 12,
        "endLineNumber" : 747,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  MediaCodec.BufferInfo info=new MediaCodec.BufferInfo();\n  Mp4Movie movie=new Mp4Movie();\n  movie.setCacheFile(cacheFile);\n  movie.setRotation(0);\n  movie.setSize(resultWidth,resultHeight);\n  mediaMuxer=new MP4Builder().createMovie(movie,isSecret);\n  long currentPts=0;\n  float durationS=duration / 1000f;\n  MediaCodec encoder=null;\n  InputSurface inputSurface=null;\n  OutputSurface outputSurface=null;\n  int prependHeaderSize=0;\n  endPresentationTime=duration * 1000;\n  checkConversionCanceled();\n  if (isPhoto) {\n    try {\n      boolean outputDone=false;\n      boolean decoderDone=false;\n      int framesCount=0;\n      if (avatarStartTime >= 0) {\n        if (durationS <= 2000) {\n          bitrate=2600000;\n        }\n else         if (durationS <= 5000) {\n          bitrate=2200000;\n        }\n else {\n          bitrate=1560000;\n        }\n      }\n else       if (bitrate <= 0) {\n        bitrate=921600;\n      }\n      if (resultWidth % 16 != 0) {\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n        }\n        resultWidth=Math.round(resultWidth / 16.0f) * 16;\n      }\n      if (resultHeight % 16 != 0) {\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n        }\n        resultHeight=Math.round(resultHeight / 16.0f) * 16;\n      }\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n      }\n      MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n      outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n      outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n      outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n      outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n      encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n      encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n      inputSurface=new InputSurface(encoder.createInputSurface());\n      inputSurface.makeCurrent();\n      encoder.start();\n      outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n      ByteBuffer[] encoderOutputBuffers=null;\n      ByteBuffer[] encoderInputBuffers=null;\n      if (Build.VERSION.SDK_INT < 21) {\n        encoderOutputBuffers=encoder.getOutputBuffers();\n      }\n      boolean firstEncode=true;\n      checkConversionCanceled();\n      while (!outputDone) {\n        checkConversionCanceled();\n        boolean decoderOutputAvailable=!decoderDone;\n        boolean encoderOutputAvailable=true;\n        while (decoderOutputAvailable || encoderOutputAvailable) {\n          checkConversionCanceled();\n          int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n          if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n            encoderOutputAvailable=false;\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n            if (Build.VERSION.SDK_INT < 21) {\n              encoderOutputBuffers=encoder.getOutputBuffers();\n            }\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n            MediaFormat newFormat=encoder.getOutputFormat();\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"photo encoder new format \" + newFormat);\n            }\n            if (videoTrackIndex == -5 && newFormat != null) {\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n              }\n            }\n          }\n else           if (encoderStatus < 0) {\n            throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n          }\n else {\n            ByteBuffer encodedData;\n            if (Build.VERSION.SDK_INT < 21) {\n              encodedData=encoderOutputBuffers[encoderStatus];\n            }\n else {\n              encodedData=encoder.getOutputBuffer(encoderStatus);\n            }\n            if (encodedData == null) {\n              throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n            }\n            if (info.size > 1) {\n              if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  info.offset+=prependHeaderSize;\n                  info.size-=prependHeaderSize;\n                }\n                if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  if (info.size > 100) {\n                    encodedData.position(info.offset);\n                    byte[] temp=new byte[100];\n                    encodedData.get(temp);\n                    int nalCount=0;\n                    for (int a=0; a < temp.length - 4; a++) {\n                      if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                        nalCount++;\n                        if (nalCount > 1) {\n                          info.offset+=a;\n                          info.size-=a;\n                          break;\n                        }\n                      }\n                    }\n                  }\n                  firstEncode=false;\n                }\n                long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                if (availableSize != 0) {\n                  if (callback != null) {\n                    callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                  }\n                }\n              }\n else               if (videoTrackIndex == -5) {\n                byte[] csd=new byte[info.size];\n                encodedData.limit(info.offset + info.size);\n                encodedData.position(info.offset);\n                encodedData.get(csd);\n                ByteBuffer sps=null;\n                ByteBuffer pps=null;\n                for (int a=info.size - 1; a >= 0; a--) {\n                  if (a > 3) {\n                    if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                      sps=ByteBuffer.allocate(a - 3);\n                      pps=ByteBuffer.allocate(info.size - (a - 3));\n                      sps.put(csd,0,a - 3).position(0);\n                      pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                      break;\n                    }\n                  }\n else {\n                    break;\n                  }\n                }\n                MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n                if (sps != null && pps != null) {\n                  newFormat.setByteBuffer(\"csd-0\",sps);\n                  newFormat.setByteBuffer(\"csd-1\",pps);\n                }\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              }\n            }\n            outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n            encoder.releaseOutputBuffer(encoderStatus,false);\n          }\n          if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n            continue;\n          }\n          if (!decoderDone) {\n            outputSurface.drawImage();\n            long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n            inputSurface.setPresentationTime(presentationTime);\n            inputSurface.swapBuffers();\n            framesCount++;\n            if (framesCount >= duration / 1000.0f * 30) {\n              decoderDone=true;\n              decoderOutputAvailable=false;\n              encoder.signalEndOfInputStream();\n            }\n          }\n        }\n      }\n    }\n catch (    Exception e) {\n      if (e instanceof IllegalStateException && !increaseTimeout) {\n        repeatWithIncreasedTimeout=true;\n      }\n      FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n      FileLog.e(e);\n      error=true;\n    }\n    if (outputSurface != null) {\n      outputSurface.release();\n    }\n    if (inputSurface != null) {\n      inputSurface.release();\n    }\n    if (encoder != null) {\n      encoder.stop();\n      encoder.release();\n    }\n    checkConversionCanceled();\n  }\n else {\n    extractor=new MediaExtractor();\n    extractor.setDataSource(videoPath);\n    int videoIndex=MediaController.findTrack(extractor,false);\n    int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n    boolean needConvertVideo=false;\n    if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n      needConvertVideo=true;\n    }\n    if (needCompress || needConvertVideo) {\n      AudioRecoder audioRecoder=null;\n      ByteBuffer audioBuffer=null;\n      boolean copyAudioBuffer=true;\n      if (videoIndex >= 0) {\n        MediaCodec decoder=null;\n        try {\n          long videoTime=-1;\n          boolean outputDone=false;\n          boolean inputDone=false;\n          boolean decoderDone=false;\n          int swapUV=0;\n          int audioTrackIndex=-5;\n          long additionalPresentationTime=0;\n          long minPresentationTime=Integer.MIN_VALUE;\n          long frameDelta=1000 / framerate * 1000;\n          extractor.selectTrack(videoIndex);\n          MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n          if (avatarStartTime >= 0) {\n            if (durationS <= 2000) {\n              bitrate=2600000;\n            }\n else             if (durationS <= 5000) {\n              bitrate=2200000;\n            }\n else {\n              bitrate=1560000;\n            }\n            avatarStartTime=0;\n          }\n else           if (bitrate <= 0) {\n            bitrate=921600;\n          }\n          if (originalBitrate > 0) {\n            bitrate=Math.min(originalBitrate,bitrate);\n          }\n          long trueStartTime;\n          if (avatarStartTime >= 0) {\n            avatarStartTime=-1;\n          }\n          if (avatarStartTime >= 0) {\n            extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else           if (startTime > 0) {\n            extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else {\n            extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n          int w;\n          int h;\n          if (cropState != null) {\n            if (rotationValue == 90 || rotationValue == 270) {\n              w=cropState.transformHeight;\n              h=cropState.transformWidth;\n            }\n else {\n              w=cropState.transformWidth;\n              h=cropState.transformHeight;\n            }\n          }\n else {\n            w=resultWidth;\n            h=resultHeight;\n          }\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n          }\n          MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n          outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n          outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n          outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n          outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n          if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n            if (bitrate > 921600) {\n              bitrate=921600;\n            }\n            outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n          }\n          encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n          encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n          inputSurface=new InputSurface(encoder.createInputSurface());\n          inputSurface.makeCurrent();\n          encoder.start();\n          decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n          outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n          decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n          decoder.start();\n          ByteBuffer[] decoderInputBuffers=null;\n          ByteBuffer[] encoderOutputBuffers=null;\n          ByteBuffer[] encoderInputBuffers=null;\n          if (Build.VERSION.SDK_INT < 21) {\n            decoderInputBuffers=decoder.getInputBuffers();\n            encoderOutputBuffers=encoder.getOutputBuffers();\n          }\n          if (audioIndex >= 0) {\n            MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n            copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n            if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n              audioIndex=-1;\n            }\n            if (audioIndex >= 0) {\n              if (copyAudioBuffer) {\n                audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n                extractor.selectTrack(audioIndex);\n                int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n                audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n                if (startTime > 0) {\n                  extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n else {\n                  extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n              }\n else {\n                MediaExtractor audioExtractor=new MediaExtractor();\n                audioExtractor.setDataSource(videoPath);\n                audioExtractor.selectTrack(audioIndex);\n                if (startTime > 0) {\n                  audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n else {\n                  audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n                audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n                audioRecoder.startTime=startTime;\n                audioRecoder.endTime=endTime;\n                audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n              }\n            }\n          }\n          boolean audioEncoderDone=audioIndex < 0;\n          boolean firstEncode=true;\n          checkConversionCanceled();\n          while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n            checkConversionCanceled();\n            if (!copyAudioBuffer && audioRecoder != null) {\n              audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n            }\n            if (!inputDone) {\n              boolean eof=false;\n              int index=extractor.getSampleTrackIndex();\n              if (index == videoIndex) {\n                int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                if (inputBufIndex >= 0) {\n                  ByteBuffer inputBuf;\n                  if (Build.VERSION.SDK_INT < 21) {\n                    inputBuf=decoderInputBuffers[inputBufIndex];\n                  }\n else {\n                    inputBuf=decoder.getInputBuffer(inputBufIndex);\n                  }\n                  int chunkSize=extractor.readSampleData(inputBuf,0);\n                  if (chunkSize < 0) {\n                    decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                    inputDone=true;\n                  }\n else {\n                    decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                    extractor.advance();\n                  }\n                }\n              }\n else               if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n                info.size=extractor.readSampleData(audioBuffer,0);\n                if (Build.VERSION.SDK_INT < 21) {\n                  audioBuffer.position(0);\n                  audioBuffer.limit(info.size);\n                }\n                if (info.size >= 0) {\n                  info.presentationTimeUs=extractor.getSampleTime();\n                  extractor.advance();\n                }\n else {\n                  info.size=0;\n                  inputDone=true;\n                }\n                if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                  info.offset=0;\n                  info.flags=extractor.getSampleFlags();\n                  long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      if (info.presentationTimeUs - startTime > currentPts) {\n                        currentPts=info.presentationTimeUs - startTime;\n                      }\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n              }\n else               if (index == -1) {\n                eof=true;\n              }\n              if (eof) {\n                int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                if (inputBufIndex >= 0) {\n                  decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                  inputDone=true;\n                }\n              }\n            }\n            boolean decoderOutputAvailable=!decoderDone;\n            boolean encoderOutputAvailable=true;\n            while (decoderOutputAvailable || encoderOutputAvailable) {\n              checkConversionCanceled();\n              int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n              if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                encoderOutputAvailable=false;\n              }\n else               if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                if (Build.VERSION.SDK_INT < 21) {\n                  encoderOutputBuffers=encoder.getOutputBuffers();\n                }\n              }\n else               if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                MediaFormat newFormat=encoder.getOutputFormat();\n                if (videoTrackIndex == -5 && newFormat != null) {\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                  if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                    ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                    ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                    prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                  }\n                }\n              }\n else               if (encoderStatus < 0) {\n                throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n              }\n else {\n                ByteBuffer encodedData;\n                if (Build.VERSION.SDK_INT < 21) {\n                  encodedData=encoderOutputBuffers[encoderStatus];\n                }\n else {\n                  encodedData=encoder.getOutputBuffer(encoderStatus);\n                }\n                if (encodedData == null) {\n                  throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n                }\n                if (info.size > 1) {\n                  if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                    if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                      info.offset+=prependHeaderSize;\n                      info.size-=prependHeaderSize;\n                    }\n                    if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                      if (info.size > 100) {\n                        encodedData.position(info.offset);\n                        byte[] temp=new byte[100];\n                        encodedData.get(temp);\n                        int nalCount=0;\n                        for (int a=0; a < temp.length - 4; a++) {\n                          if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                            nalCount++;\n                            if (nalCount > 1) {\n                              info.offset+=a;\n                              info.size-=a;\n                              break;\n                            }\n                          }\n                        }\n                      }\n                      firstEncode=false;\n                    }\n                    long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                    if (availableSize != 0) {\n                      if (callback != null) {\n                        if (info.presentationTimeUs - startTime > currentPts) {\n                          currentPts=info.presentationTimeUs - startTime;\n                        }\n                        callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                      }\n                    }\n                  }\n else                   if (videoTrackIndex == -5) {\n                    byte[] csd=new byte[info.size];\n                    encodedData.limit(info.offset + info.size);\n                    encodedData.position(info.offset);\n                    encodedData.get(csd);\n                    ByteBuffer sps=null;\n                    ByteBuffer pps=null;\n                    for (int a=info.size - 1; a >= 0; a--) {\n                      if (a > 3) {\n                        if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                          sps=ByteBuffer.allocate(a - 3);\n                          pps=ByteBuffer.allocate(info.size - (a - 3));\n                          sps.put(csd,0,a - 3).position(0);\n                          pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                          break;\n                        }\n                      }\n else {\n                        break;\n                      }\n                    }\n                    MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                    if (sps != null && pps != null) {\n                      newFormat.setByteBuffer(\"csd-0\",sps);\n                      newFormat.setByteBuffer(\"csd-1\",pps);\n                    }\n                    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                  }\n                }\n                outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n                encoder.releaseOutputBuffer(encoderStatus,false);\n              }\n              if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n                continue;\n              }\n              if (!decoderDone) {\n                int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n                if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  decoderOutputAvailable=false;\n                }\n else                 if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                }\n else                 if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                  MediaFormat newFormat=decoder.getOutputFormat();\n                  if (BuildVars.LOGS_ENABLED) {\n                    FileLog.d(\"newFormat = \" + newFormat);\n                  }\n                }\n else                 if (decoderStatus < 0) {\n                  throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n                }\n else {\n                  boolean doRender=info.size != 0;\n                  long originalPresentationTime=info.presentationTimeUs;\n                  if (endTime > 0 && originalPresentationTime >= endTime) {\n                    inputDone=true;\n                    decoderDone=true;\n                    doRender=false;\n                    info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                  }\n                  boolean flushed=false;\n                  if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                    if (startTime > 0) {\n                      extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                    }\n else {\n                      extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                    }\n                    additionalPresentationTime=minPresentationTime + frameDelta;\n                    endTime=avatarStartTime;\n                    avatarStartTime=-1;\n                    inputDone=false;\n                    decoderDone=false;\n                    doRender=false;\n                    info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                    decoder.flush();\n                    flushed=true;\n                  }\n                  trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                  if (trueStartTime > 0 && videoTime == -1) {\n                    if (originalPresentationTime < trueStartTime) {\n                      doRender=false;\n                      if (BuildVars.LOGS_ENABLED) {\n                        FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                      }\n                    }\n else {\n                      videoTime=info.presentationTimeUs;\n                      if (minPresentationTime != Integer.MIN_VALUE) {\n                        additionalPresentationTime-=videoTime;\n                      }\n                    }\n                  }\n                  if (flushed) {\n                    videoTime=-1;\n                  }\n else {\n                    if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                      info.presentationTimeUs+=additionalPresentationTime;\n                    }\n                    decoder.releaseOutputBuffer(decoderStatus,doRender);\n                  }\n                  if (doRender) {\n                    if (avatarStartTime >= 0) {\n                      minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                    }\n                    boolean errorWait=false;\n                    try {\n                      outputSurface.awaitNewImage();\n                    }\n catch (                    Exception e) {\n                      errorWait=true;\n                      FileLog.e(e);\n                    }\n                    if (!errorWait) {\n                      outputSurface.drawImage();\n                      inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                      inputSurface.swapBuffers();\n                    }\n                  }\n                  if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                    decoderOutputAvailable=false;\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"decoder stream end\");\n                    }\n                    encoder.signalEndOfInputStream();\n                  }\n                }\n              }\n            }\n          }\n        }\n catch (        Exception e) {\n          if (e instanceof IllegalStateException && !increaseTimeout) {\n            repeatWithIncreasedTimeout=true;\n          }\n          FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n          FileLog.e(e);\n          error=true;\n        }\n        extractor.unselectTrack(videoIndex);\n        if (decoder != null) {\n          decoder.stop();\n          decoder.release();\n        }\n      }\n      if (outputSurface != null) {\n        outputSurface.release();\n      }\n      if (inputSurface != null) {\n        inputSurface.release();\n      }\n      if (encoder != null) {\n        encoder.stop();\n        encoder.release();\n      }\n      if (audioRecoder != null) {\n        audioRecoder.release();\n      }\n      checkConversionCanceled();\n    }\n else {\n      readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 3406,
      "astHeight" : 36
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 44095,
        "startLineNumber" : 77,
        "startColumnNumber" : 8,
        "endLineNumber" : 763,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try {\n  MediaCodec.BufferInfo info=new MediaCodec.BufferInfo();\n  Mp4Movie movie=new Mp4Movie();\n  movie.setCacheFile(cacheFile);\n  movie.setRotation(0);\n  movie.setSize(resultWidth,resultHeight);\n  mediaMuxer=new MP4Builder().createMovie(movie,isSecret);\n  long currentPts=0;\n  float durationS=duration / 1000f;\n  MediaCodec encoder=null;\n  InputSurface inputSurface=null;\n  OutputSurface outputSurface=null;\n  int prependHeaderSize=0;\n  endPresentationTime=duration * 1000;\n  checkConversionCanceled();\n  if (isPhoto) {\n    try {\n      boolean outputDone=false;\n      boolean decoderDone=false;\n      int framesCount=0;\n      if (avatarStartTime >= 0) {\n        if (durationS <= 2000) {\n          bitrate=2600000;\n        }\n else         if (durationS <= 5000) {\n          bitrate=2200000;\n        }\n else {\n          bitrate=1560000;\n        }\n      }\n else       if (bitrate <= 0) {\n        bitrate=921600;\n      }\n      if (resultWidth % 16 != 0) {\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n        }\n        resultWidth=Math.round(resultWidth / 16.0f) * 16;\n      }\n      if (resultHeight % 16 != 0) {\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n        }\n        resultHeight=Math.round(resultHeight / 16.0f) * 16;\n      }\n      if (BuildVars.LOGS_ENABLED) {\n        FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n      }\n      MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n      outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n      outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n      outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n      outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n      encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n      encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n      inputSurface=new InputSurface(encoder.createInputSurface());\n      inputSurface.makeCurrent();\n      encoder.start();\n      outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n      ByteBuffer[] encoderOutputBuffers=null;\n      ByteBuffer[] encoderInputBuffers=null;\n      if (Build.VERSION.SDK_INT < 21) {\n        encoderOutputBuffers=encoder.getOutputBuffers();\n      }\n      boolean firstEncode=true;\n      checkConversionCanceled();\n      while (!outputDone) {\n        checkConversionCanceled();\n        boolean decoderOutputAvailable=!decoderDone;\n        boolean encoderOutputAvailable=true;\n        while (decoderOutputAvailable || encoderOutputAvailable) {\n          checkConversionCanceled();\n          int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n          if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n            encoderOutputAvailable=false;\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n            if (Build.VERSION.SDK_INT < 21) {\n              encoderOutputBuffers=encoder.getOutputBuffers();\n            }\n          }\n else           if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n            MediaFormat newFormat=encoder.getOutputFormat();\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"photo encoder new format \" + newFormat);\n            }\n            if (videoTrackIndex == -5 && newFormat != null) {\n              videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n              }\n            }\n          }\n else           if (encoderStatus < 0) {\n            throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n          }\n else {\n            ByteBuffer encodedData;\n            if (Build.VERSION.SDK_INT < 21) {\n              encodedData=encoderOutputBuffers[encoderStatus];\n            }\n else {\n              encodedData=encoder.getOutputBuffer(encoderStatus);\n            }\n            if (encodedData == null) {\n              throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n            }\n            if (info.size > 1) {\n              if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  info.offset+=prependHeaderSize;\n                  info.size-=prependHeaderSize;\n                }\n                if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                  if (info.size > 100) {\n                    encodedData.position(info.offset);\n                    byte[] temp=new byte[100];\n                    encodedData.get(temp);\n                    int nalCount=0;\n                    for (int a=0; a < temp.length - 4; a++) {\n                      if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                        nalCount++;\n                        if (nalCount > 1) {\n                          info.offset+=a;\n                          info.size-=a;\n                          break;\n                        }\n                      }\n                    }\n                  }\n                  firstEncode=false;\n                }\n                long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                if (availableSize != 0) {\n                  if (callback != null) {\n                    callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                  }\n                }\n              }\n else               if (videoTrackIndex == -5) {\n                byte[] csd=new byte[info.size];\n                encodedData.limit(info.offset + info.size);\n                encodedData.position(info.offset);\n                encodedData.get(csd);\n                ByteBuffer sps=null;\n                ByteBuffer pps=null;\n                for (int a=info.size - 1; a >= 0; a--) {\n                  if (a > 3) {\n                    if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                      sps=ByteBuffer.allocate(a - 3);\n                      pps=ByteBuffer.allocate(info.size - (a - 3));\n                      sps.put(csd,0,a - 3).position(0);\n                      pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                      break;\n                    }\n                  }\n else {\n                    break;\n                  }\n                }\n                MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n                if (sps != null && pps != null) {\n                  newFormat.setByteBuffer(\"csd-0\",sps);\n                  newFormat.setByteBuffer(\"csd-1\",pps);\n                }\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n              }\n            }\n            outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n            encoder.releaseOutputBuffer(encoderStatus,false);\n          }\n          if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n            continue;\n          }\n          if (!decoderDone) {\n            outputSurface.drawImage();\n            long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n            inputSurface.setPresentationTime(presentationTime);\n            inputSurface.swapBuffers();\n            framesCount++;\n            if (framesCount >= duration / 1000.0f * 30) {\n              decoderDone=true;\n              decoderOutputAvailable=false;\n              encoder.signalEndOfInputStream();\n            }\n          }\n        }\n      }\n    }\n catch (    Exception e) {\n      if (e instanceof IllegalStateException && !increaseTimeout) {\n        repeatWithIncreasedTimeout=true;\n      }\n      FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n      FileLog.e(e);\n      error=true;\n    }\n    if (outputSurface != null) {\n      outputSurface.release();\n    }\n    if (inputSurface != null) {\n      inputSurface.release();\n    }\n    if (encoder != null) {\n      encoder.stop();\n      encoder.release();\n    }\n    checkConversionCanceled();\n  }\n else {\n    extractor=new MediaExtractor();\n    extractor.setDataSource(videoPath);\n    int videoIndex=MediaController.findTrack(extractor,false);\n    int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n    boolean needConvertVideo=false;\n    if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n      needConvertVideo=true;\n    }\n    if (needCompress || needConvertVideo) {\n      AudioRecoder audioRecoder=null;\n      ByteBuffer audioBuffer=null;\n      boolean copyAudioBuffer=true;\n      if (videoIndex >= 0) {\n        MediaCodec decoder=null;\n        try {\n          long videoTime=-1;\n          boolean outputDone=false;\n          boolean inputDone=false;\n          boolean decoderDone=false;\n          int swapUV=0;\n          int audioTrackIndex=-5;\n          long additionalPresentationTime=0;\n          long minPresentationTime=Integer.MIN_VALUE;\n          long frameDelta=1000 / framerate * 1000;\n          extractor.selectTrack(videoIndex);\n          MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n          if (avatarStartTime >= 0) {\n            if (durationS <= 2000) {\n              bitrate=2600000;\n            }\n else             if (durationS <= 5000) {\n              bitrate=2200000;\n            }\n else {\n              bitrate=1560000;\n            }\n            avatarStartTime=0;\n          }\n else           if (bitrate <= 0) {\n            bitrate=921600;\n          }\n          if (originalBitrate > 0) {\n            bitrate=Math.min(originalBitrate,bitrate);\n          }\n          long trueStartTime;\n          if (avatarStartTime >= 0) {\n            avatarStartTime=-1;\n          }\n          if (avatarStartTime >= 0) {\n            extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else           if (startTime > 0) {\n            extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n else {\n            extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n          }\n          int w;\n          int h;\n          if (cropState != null) {\n            if (rotationValue == 90 || rotationValue == 270) {\n              w=cropState.transformHeight;\n              h=cropState.transformWidth;\n            }\n else {\n              w=cropState.transformWidth;\n              h=cropState.transformHeight;\n            }\n          }\n else {\n            w=resultWidth;\n            h=resultHeight;\n          }\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n          }\n          MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n          outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n          outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n          outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n          outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n          if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n            if (bitrate > 921600) {\n              bitrate=921600;\n            }\n            outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n          }\n          encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n          encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n          inputSurface=new InputSurface(encoder.createInputSurface());\n          inputSurface.makeCurrent();\n          encoder.start();\n          decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n          outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n          decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n          decoder.start();\n          ByteBuffer[] decoderInputBuffers=null;\n          ByteBuffer[] encoderOutputBuffers=null;\n          ByteBuffer[] encoderInputBuffers=null;\n          if (Build.VERSION.SDK_INT < 21) {\n            decoderInputBuffers=decoder.getInputBuffers();\n            encoderOutputBuffers=encoder.getOutputBuffers();\n          }\n          if (audioIndex >= 0) {\n            MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n            copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n            if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n              audioIndex=-1;\n            }\n            if (audioIndex >= 0) {\n              if (copyAudioBuffer) {\n                audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n                extractor.selectTrack(audioIndex);\n                int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n                audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n                if (startTime > 0) {\n                  extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n else {\n                  extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n              }\n else {\n                MediaExtractor audioExtractor=new MediaExtractor();\n                audioExtractor.setDataSource(videoPath);\n                audioExtractor.selectTrack(audioIndex);\n                if (startTime > 0) {\n                  audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n else {\n                  audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                }\n                audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n                audioRecoder.startTime=startTime;\n                audioRecoder.endTime=endTime;\n                audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n              }\n            }\n          }\n          boolean audioEncoderDone=audioIndex < 0;\n          boolean firstEncode=true;\n          checkConversionCanceled();\n          while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n            checkConversionCanceled();\n            if (!copyAudioBuffer && audioRecoder != null) {\n              audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n            }\n            if (!inputDone) {\n              boolean eof=false;\n              int index=extractor.getSampleTrackIndex();\n              if (index == videoIndex) {\n                int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                if (inputBufIndex >= 0) {\n                  ByteBuffer inputBuf;\n                  if (Build.VERSION.SDK_INT < 21) {\n                    inputBuf=decoderInputBuffers[inputBufIndex];\n                  }\n else {\n                    inputBuf=decoder.getInputBuffer(inputBufIndex);\n                  }\n                  int chunkSize=extractor.readSampleData(inputBuf,0);\n                  if (chunkSize < 0) {\n                    decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                    inputDone=true;\n                  }\n else {\n                    decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                    extractor.advance();\n                  }\n                }\n              }\n else               if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n                info.size=extractor.readSampleData(audioBuffer,0);\n                if (Build.VERSION.SDK_INT < 21) {\n                  audioBuffer.position(0);\n                  audioBuffer.limit(info.size);\n                }\n                if (info.size >= 0) {\n                  info.presentationTimeUs=extractor.getSampleTime();\n                  extractor.advance();\n                }\n else {\n                  info.size=0;\n                  inputDone=true;\n                }\n                if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                  info.offset=0;\n                  info.flags=extractor.getSampleFlags();\n                  long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      if (info.presentationTimeUs - startTime > currentPts) {\n                        currentPts=info.presentationTimeUs - startTime;\n                      }\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n              }\n else               if (index == -1) {\n                eof=true;\n              }\n              if (eof) {\n                int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                if (inputBufIndex >= 0) {\n                  decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                  inputDone=true;\n                }\n              }\n            }\n            boolean decoderOutputAvailable=!decoderDone;\n            boolean encoderOutputAvailable=true;\n            while (decoderOutputAvailable || encoderOutputAvailable) {\n              checkConversionCanceled();\n              int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n              if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                encoderOutputAvailable=false;\n              }\n else               if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                if (Build.VERSION.SDK_INT < 21) {\n                  encoderOutputBuffers=encoder.getOutputBuffers();\n                }\n              }\n else               if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                MediaFormat newFormat=encoder.getOutputFormat();\n                if (videoTrackIndex == -5 && newFormat != null) {\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                  if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                    ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                    ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                    prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                  }\n                }\n              }\n else               if (encoderStatus < 0) {\n                throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n              }\n else {\n                ByteBuffer encodedData;\n                if (Build.VERSION.SDK_INT < 21) {\n                  encodedData=encoderOutputBuffers[encoderStatus];\n                }\n else {\n                  encodedData=encoder.getOutputBuffer(encoderStatus);\n                }\n                if (encodedData == null) {\n                  throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n                }\n                if (info.size > 1) {\n                  if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                    if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                      info.offset+=prependHeaderSize;\n                      info.size-=prependHeaderSize;\n                    }\n                    if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                      if (info.size > 100) {\n                        encodedData.position(info.offset);\n                        byte[] temp=new byte[100];\n                        encodedData.get(temp);\n                        int nalCount=0;\n                        for (int a=0; a < temp.length - 4; a++) {\n                          if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                            nalCount++;\n                            if (nalCount > 1) {\n                              info.offset+=a;\n                              info.size-=a;\n                              break;\n                            }\n                          }\n                        }\n                      }\n                      firstEncode=false;\n                    }\n                    long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                    if (availableSize != 0) {\n                      if (callback != null) {\n                        if (info.presentationTimeUs - startTime > currentPts) {\n                          currentPts=info.presentationTimeUs - startTime;\n                        }\n                        callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                      }\n                    }\n                  }\n else                   if (videoTrackIndex == -5) {\n                    byte[] csd=new byte[info.size];\n                    encodedData.limit(info.offset + info.size);\n                    encodedData.position(info.offset);\n                    encodedData.get(csd);\n                    ByteBuffer sps=null;\n                    ByteBuffer pps=null;\n                    for (int a=info.size - 1; a >= 0; a--) {\n                      if (a > 3) {\n                        if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                          sps=ByteBuffer.allocate(a - 3);\n                          pps=ByteBuffer.allocate(info.size - (a - 3));\n                          sps.put(csd,0,a - 3).position(0);\n                          pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                          break;\n                        }\n                      }\n else {\n                        break;\n                      }\n                    }\n                    MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                    if (sps != null && pps != null) {\n                      newFormat.setByteBuffer(\"csd-0\",sps);\n                      newFormat.setByteBuffer(\"csd-1\",pps);\n                    }\n                    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                  }\n                }\n                outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n                encoder.releaseOutputBuffer(encoderStatus,false);\n              }\n              if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n                continue;\n              }\n              if (!decoderDone) {\n                int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n                if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  decoderOutputAvailable=false;\n                }\n else                 if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                }\n else                 if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                  MediaFormat newFormat=decoder.getOutputFormat();\n                  if (BuildVars.LOGS_ENABLED) {\n                    FileLog.d(\"newFormat = \" + newFormat);\n                  }\n                }\n else                 if (decoderStatus < 0) {\n                  throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n                }\n else {\n                  boolean doRender=info.size != 0;\n                  long originalPresentationTime=info.presentationTimeUs;\n                  if (endTime > 0 && originalPresentationTime >= endTime) {\n                    inputDone=true;\n                    decoderDone=true;\n                    doRender=false;\n                    info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                  }\n                  boolean flushed=false;\n                  if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                    if (startTime > 0) {\n                      extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                    }\n else {\n                      extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                    }\n                    additionalPresentationTime=minPresentationTime + frameDelta;\n                    endTime=avatarStartTime;\n                    avatarStartTime=-1;\n                    inputDone=false;\n                    decoderDone=false;\n                    doRender=false;\n                    info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                    decoder.flush();\n                    flushed=true;\n                  }\n                  trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                  if (trueStartTime > 0 && videoTime == -1) {\n                    if (originalPresentationTime < trueStartTime) {\n                      doRender=false;\n                      if (BuildVars.LOGS_ENABLED) {\n                        FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                      }\n                    }\n else {\n                      videoTime=info.presentationTimeUs;\n                      if (minPresentationTime != Integer.MIN_VALUE) {\n                        additionalPresentationTime-=videoTime;\n                      }\n                    }\n                  }\n                  if (flushed) {\n                    videoTime=-1;\n                  }\n else {\n                    if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                      info.presentationTimeUs+=additionalPresentationTime;\n                    }\n                    decoder.releaseOutputBuffer(decoderStatus,doRender);\n                  }\n                  if (doRender) {\n                    if (avatarStartTime >= 0) {\n                      minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                    }\n                    boolean errorWait=false;\n                    try {\n                      outputSurface.awaitNewImage();\n                    }\n catch (                    Exception e) {\n                      errorWait=true;\n                      FileLog.e(e);\n                    }\n                    if (!errorWait) {\n                      outputSurface.drawImage();\n                      inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                      inputSurface.swapBuffers();\n                    }\n                  }\n                  if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                    decoderOutputAvailable=false;\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"decoder stream end\");\n                    }\n                    encoder.signalEndOfInputStream();\n                  }\n                }\n              }\n            }\n          }\n        }\n catch (        Exception e) {\n          if (e instanceof IllegalStateException && !increaseTimeout) {\n            repeatWithIncreasedTimeout=true;\n          }\n          FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n          FileLog.e(e);\n          error=true;\n        }\n        extractor.unselectTrack(videoIndex);\n        if (decoder != null) {\n          decoder.stop();\n          decoder.release();\n        }\n      }\n      if (outputSurface != null) {\n        outputSurface.release();\n      }\n      if (inputSurface != null) {\n        inputSurface.release();\n      }\n      if (encoder != null) {\n        encoder.stop();\n        encoder.release();\n      }\n      if (audioRecoder != null) {\n        audioRecoder.release();\n      }\n      checkConversionCanceled();\n    }\n else {\n      readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n    }\n  }\n}\n catch (Exception e) {\n  error=true;\n  FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n  FileLog.e(e);\n}\n finally {\n  if (extractor != null) {\n    extractor.release();\n  }\n  if (mediaMuxer != null) {\n    try {\n      mediaMuxer.finishMovie();\n      endPresentationTime=mediaMuxer.getLastFrameTimestamp(videoTrackIndex);\n    }\n catch (    Exception e) {\n      FileLog.e(e);\n    }\n  }\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 3474,
      "astHeight" : 37
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 44649,
        "startLineNumber" : 71,
        "startColumnNumber" : 78,
        "endLineNumber" : 773,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  boolean error=false;\n  boolean repeatWithIncreasedTimeout=false;\n  int videoTrackIndex=-5;\n  try {\n    MediaCodec.BufferInfo info=new MediaCodec.BufferInfo();\n    Mp4Movie movie=new Mp4Movie();\n    movie.setCacheFile(cacheFile);\n    movie.setRotation(0);\n    movie.setSize(resultWidth,resultHeight);\n    mediaMuxer=new MP4Builder().createMovie(movie,isSecret);\n    long currentPts=0;\n    float durationS=duration / 1000f;\n    MediaCodec encoder=null;\n    InputSurface inputSurface=null;\n    OutputSurface outputSurface=null;\n    int prependHeaderSize=0;\n    endPresentationTime=duration * 1000;\n    checkConversionCanceled();\n    if (isPhoto) {\n      try {\n        boolean outputDone=false;\n        boolean decoderDone=false;\n        int framesCount=0;\n        if (avatarStartTime >= 0) {\n          if (durationS <= 2000) {\n            bitrate=2600000;\n          }\n else           if (durationS <= 5000) {\n            bitrate=2200000;\n          }\n else {\n            bitrate=1560000;\n          }\n        }\n else         if (bitrate <= 0) {\n          bitrate=921600;\n        }\n        if (resultWidth % 16 != 0) {\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n          }\n          resultWidth=Math.round(resultWidth / 16.0f) * 16;\n        }\n        if (resultHeight % 16 != 0) {\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n          }\n          resultHeight=Math.round(resultHeight / 16.0f) * 16;\n        }\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n        }\n        MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n        encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n        encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n        inputSurface=new InputSurface(encoder.createInputSurface());\n        inputSurface.makeCurrent();\n        encoder.start();\n        outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n        ByteBuffer[] encoderOutputBuffers=null;\n        ByteBuffer[] encoderInputBuffers=null;\n        if (Build.VERSION.SDK_INT < 21) {\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n        boolean firstEncode=true;\n        checkConversionCanceled();\n        while (!outputDone) {\n          checkConversionCanceled();\n          boolean decoderOutputAvailable=!decoderDone;\n          boolean encoderOutputAvailable=true;\n          while (decoderOutputAvailable || encoderOutputAvailable) {\n            checkConversionCanceled();\n            int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n            if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n              encoderOutputAvailable=false;\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n              if (Build.VERSION.SDK_INT < 21) {\n                encoderOutputBuffers=encoder.getOutputBuffers();\n              }\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n              MediaFormat newFormat=encoder.getOutputFormat();\n              if (BuildVars.LOGS_ENABLED) {\n                FileLog.d(\"photo encoder new format \" + newFormat);\n              }\n              if (videoTrackIndex == -5 && newFormat != null) {\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                  ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                  ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                  prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                }\n              }\n            }\n else             if (encoderStatus < 0) {\n              throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n            }\n else {\n              ByteBuffer encodedData;\n              if (Build.VERSION.SDK_INT < 21) {\n                encodedData=encoderOutputBuffers[encoderStatus];\n              }\n else {\n                encodedData=encoder.getOutputBuffer(encoderStatus);\n              }\n              if (encodedData == null) {\n                throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n              }\n              if (info.size > 1) {\n                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                  if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    info.offset+=prependHeaderSize;\n                    info.size-=prependHeaderSize;\n                  }\n                  if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    if (info.size > 100) {\n                      encodedData.position(info.offset);\n                      byte[] temp=new byte[100];\n                      encodedData.get(temp);\n                      int nalCount=0;\n                      for (int a=0; a < temp.length - 4; a++) {\n                        if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                          nalCount++;\n                          if (nalCount > 1) {\n                            info.offset+=a;\n                            info.size-=a;\n                            break;\n                          }\n                        }\n                      }\n                    }\n                    firstEncode=false;\n                  }\n                  long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n else                 if (videoTrackIndex == -5) {\n                  byte[] csd=new byte[info.size];\n                  encodedData.limit(info.offset + info.size);\n                  encodedData.position(info.offset);\n                  encodedData.get(csd);\n                  ByteBuffer sps=null;\n                  ByteBuffer pps=null;\n                  for (int a=info.size - 1; a >= 0; a--) {\n                    if (a > 3) {\n                      if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                        sps=ByteBuffer.allocate(a - 3);\n                        pps=ByteBuffer.allocate(info.size - (a - 3));\n                        sps.put(csd,0,a - 3).position(0);\n                        pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                        break;\n                      }\n                    }\n else {\n                      break;\n                    }\n                  }\n                  MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n                  if (sps != null && pps != null) {\n                    newFormat.setByteBuffer(\"csd-0\",sps);\n                    newFormat.setByteBuffer(\"csd-1\",pps);\n                  }\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                }\n              }\n              outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n              encoder.releaseOutputBuffer(encoderStatus,false);\n            }\n            if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n              continue;\n            }\n            if (!decoderDone) {\n              outputSurface.drawImage();\n              long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n              inputSurface.setPresentationTime(presentationTime);\n              inputSurface.swapBuffers();\n              framesCount++;\n              if (framesCount >= duration / 1000.0f * 30) {\n                decoderDone=true;\n                decoderOutputAvailable=false;\n                encoder.signalEndOfInputStream();\n              }\n            }\n          }\n        }\n      }\n catch (      Exception e) {\n        if (e instanceof IllegalStateException && !increaseTimeout) {\n          repeatWithIncreasedTimeout=true;\n        }\n        FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n        FileLog.e(e);\n        error=true;\n      }\n      if (outputSurface != null) {\n        outputSurface.release();\n      }\n      if (inputSurface != null) {\n        inputSurface.release();\n      }\n      if (encoder != null) {\n        encoder.stop();\n        encoder.release();\n      }\n      checkConversionCanceled();\n    }\n else {\n      extractor=new MediaExtractor();\n      extractor.setDataSource(videoPath);\n      int videoIndex=MediaController.findTrack(extractor,false);\n      int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n      boolean needConvertVideo=false;\n      if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n        needConvertVideo=true;\n      }\n      if (needCompress || needConvertVideo) {\n        AudioRecoder audioRecoder=null;\n        ByteBuffer audioBuffer=null;\n        boolean copyAudioBuffer=true;\n        if (videoIndex >= 0) {\n          MediaCodec decoder=null;\n          try {\n            long videoTime=-1;\n            boolean outputDone=false;\n            boolean inputDone=false;\n            boolean decoderDone=false;\n            int swapUV=0;\n            int audioTrackIndex=-5;\n            long additionalPresentationTime=0;\n            long minPresentationTime=Integer.MIN_VALUE;\n            long frameDelta=1000 / framerate * 1000;\n            extractor.selectTrack(videoIndex);\n            MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n            if (avatarStartTime >= 0) {\n              if (durationS <= 2000) {\n                bitrate=2600000;\n              }\n else               if (durationS <= 5000) {\n                bitrate=2200000;\n              }\n else {\n                bitrate=1560000;\n              }\n              avatarStartTime=0;\n            }\n else             if (bitrate <= 0) {\n              bitrate=921600;\n            }\n            if (originalBitrate > 0) {\n              bitrate=Math.min(originalBitrate,bitrate);\n            }\n            long trueStartTime;\n            if (avatarStartTime >= 0) {\n              avatarStartTime=-1;\n            }\n            if (avatarStartTime >= 0) {\n              extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else             if (startTime > 0) {\n              extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else {\n              extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n            int w;\n            int h;\n            if (cropState != null) {\n              if (rotationValue == 90 || rotationValue == 270) {\n                w=cropState.transformHeight;\n                h=cropState.transformWidth;\n              }\n else {\n                w=cropState.transformWidth;\n                h=cropState.transformHeight;\n              }\n            }\n else {\n              w=resultWidth;\n              h=resultHeight;\n            }\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n            }\n            MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n            outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n            outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n            outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n            outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n            if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n              if (bitrate > 921600) {\n                bitrate=921600;\n              }\n              outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n            }\n            encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n            encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n            inputSurface=new InputSurface(encoder.createInputSurface());\n            inputSurface.makeCurrent();\n            encoder.start();\n            decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n            outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n            decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n            decoder.start();\n            ByteBuffer[] decoderInputBuffers=null;\n            ByteBuffer[] encoderOutputBuffers=null;\n            ByteBuffer[] encoderInputBuffers=null;\n            if (Build.VERSION.SDK_INT < 21) {\n              decoderInputBuffers=decoder.getInputBuffers();\n              encoderOutputBuffers=encoder.getOutputBuffers();\n            }\n            if (audioIndex >= 0) {\n              MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n              copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n              if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n                audioIndex=-1;\n              }\n              if (audioIndex >= 0) {\n                if (copyAudioBuffer) {\n                  audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n                  extractor.selectTrack(audioIndex);\n                  int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n                  audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n                  if (startTime > 0) {\n                    extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                }\n else {\n                  MediaExtractor audioExtractor=new MediaExtractor();\n                  audioExtractor.setDataSource(videoPath);\n                  audioExtractor.selectTrack(audioIndex);\n                  if (startTime > 0) {\n                    audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                  audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n                  audioRecoder.startTime=startTime;\n                  audioRecoder.endTime=endTime;\n                  audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n                }\n              }\n            }\n            boolean audioEncoderDone=audioIndex < 0;\n            boolean firstEncode=true;\n            checkConversionCanceled();\n            while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n              checkConversionCanceled();\n              if (!copyAudioBuffer && audioRecoder != null) {\n                audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n              }\n              if (!inputDone) {\n                boolean eof=false;\n                int index=extractor.getSampleTrackIndex();\n                if (index == videoIndex) {\n                  int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (inputBufIndex >= 0) {\n                    ByteBuffer inputBuf;\n                    if (Build.VERSION.SDK_INT < 21) {\n                      inputBuf=decoderInputBuffers[inputBufIndex];\n                    }\n else {\n                      inputBuf=decoder.getInputBuffer(inputBufIndex);\n                    }\n                    int chunkSize=extractor.readSampleData(inputBuf,0);\n                    if (chunkSize < 0) {\n                      decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                      inputDone=true;\n                    }\n else {\n                      decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                      extractor.advance();\n                    }\n                  }\n                }\n else                 if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n                  info.size=extractor.readSampleData(audioBuffer,0);\n                  if (Build.VERSION.SDK_INT < 21) {\n                    audioBuffer.position(0);\n                    audioBuffer.limit(info.size);\n                  }\n                  if (info.size >= 0) {\n                    info.presentationTimeUs=extractor.getSampleTime();\n                    extractor.advance();\n                  }\n else {\n                    info.size=0;\n                    inputDone=true;\n                  }\n                  if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                    info.offset=0;\n                    info.flags=extractor.getSampleFlags();\n                    long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                    if (availableSize != 0) {\n                      if (callback != null) {\n                        if (info.presentationTimeUs - startTime > currentPts) {\n                          currentPts=info.presentationTimeUs - startTime;\n                        }\n                        callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                      }\n                    }\n                  }\n                }\n else                 if (index == -1) {\n                  eof=true;\n                }\n                if (eof) {\n                  int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (inputBufIndex >= 0) {\n                    decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                    inputDone=true;\n                  }\n                }\n              }\n              boolean decoderOutputAvailable=!decoderDone;\n              boolean encoderOutputAvailable=true;\n              while (decoderOutputAvailable || encoderOutputAvailable) {\n                checkConversionCanceled();\n                int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n                if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  encoderOutputAvailable=false;\n                }\n else                 if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                  if (Build.VERSION.SDK_INT < 21) {\n                    encoderOutputBuffers=encoder.getOutputBuffers();\n                  }\n                }\n else                 if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                  MediaFormat newFormat=encoder.getOutputFormat();\n                  if (videoTrackIndex == -5 && newFormat != null) {\n                    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                    if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                      ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                      ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                      prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                    }\n                  }\n                }\n else                 if (encoderStatus < 0) {\n                  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n                }\n else {\n                  ByteBuffer encodedData;\n                  if (Build.VERSION.SDK_INT < 21) {\n                    encodedData=encoderOutputBuffers[encoderStatus];\n                  }\n else {\n                    encodedData=encoder.getOutputBuffer(encoderStatus);\n                  }\n                  if (encodedData == null) {\n                    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n                  }\n                  if (info.size > 1) {\n                    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                        info.offset+=prependHeaderSize;\n                        info.size-=prependHeaderSize;\n                      }\n                      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                        if (info.size > 100) {\n                          encodedData.position(info.offset);\n                          byte[] temp=new byte[100];\n                          encodedData.get(temp);\n                          int nalCount=0;\n                          for (int a=0; a < temp.length - 4; a++) {\n                            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                              nalCount++;\n                              if (nalCount > 1) {\n                                info.offset+=a;\n                                info.size-=a;\n                                break;\n                              }\n                            }\n                          }\n                        }\n                        firstEncode=false;\n                      }\n                      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                      if (availableSize != 0) {\n                        if (callback != null) {\n                          if (info.presentationTimeUs - startTime > currentPts) {\n                            currentPts=info.presentationTimeUs - startTime;\n                          }\n                          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                        }\n                      }\n                    }\n else                     if (videoTrackIndex == -5) {\n                      byte[] csd=new byte[info.size];\n                      encodedData.limit(info.offset + info.size);\n                      encodedData.position(info.offset);\n                      encodedData.get(csd);\n                      ByteBuffer sps=null;\n                      ByteBuffer pps=null;\n                      for (int a=info.size - 1; a >= 0; a--) {\n                        if (a > 3) {\n                          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                            sps=ByteBuffer.allocate(a - 3);\n                            pps=ByteBuffer.allocate(info.size - (a - 3));\n                            sps.put(csd,0,a - 3).position(0);\n                            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                            break;\n                          }\n                        }\n else {\n                          break;\n                        }\n                      }\n                      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                      if (sps != null && pps != null) {\n                        newFormat.setByteBuffer(\"csd-0\",sps);\n                        newFormat.setByteBuffer(\"csd-1\",pps);\n                      }\n                      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                    }\n                  }\n                  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n                  encoder.releaseOutputBuffer(encoderStatus,false);\n                }\n                if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  continue;\n                }\n                if (!decoderDone) {\n                  int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                    decoderOutputAvailable=false;\n                  }\n else                   if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                  }\n else                   if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                    MediaFormat newFormat=decoder.getOutputFormat();\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"newFormat = \" + newFormat);\n                    }\n                  }\n else                   if (decoderStatus < 0) {\n                    throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n                  }\n else {\n                    boolean doRender=info.size != 0;\n                    long originalPresentationTime=info.presentationTimeUs;\n                    if (endTime > 0 && originalPresentationTime >= endTime) {\n                      inputDone=true;\n                      decoderDone=true;\n                      doRender=false;\n                      info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                    }\n                    boolean flushed=false;\n                    if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                      if (startTime > 0) {\n                        extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                      }\n else {\n                        extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                      }\n                      additionalPresentationTime=minPresentationTime + frameDelta;\n                      endTime=avatarStartTime;\n                      avatarStartTime=-1;\n                      inputDone=false;\n                      decoderDone=false;\n                      doRender=false;\n                      info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                      decoder.flush();\n                      flushed=true;\n                    }\n                    trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                    if (trueStartTime > 0 && videoTime == -1) {\n                      if (originalPresentationTime < trueStartTime) {\n                        doRender=false;\n                        if (BuildVars.LOGS_ENABLED) {\n                          FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                        }\n                      }\n else {\n                        videoTime=info.presentationTimeUs;\n                        if (minPresentationTime != Integer.MIN_VALUE) {\n                          additionalPresentationTime-=videoTime;\n                        }\n                      }\n                    }\n                    if (flushed) {\n                      videoTime=-1;\n                    }\n else {\n                      if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                        info.presentationTimeUs+=additionalPresentationTime;\n                      }\n                      decoder.releaseOutputBuffer(decoderStatus,doRender);\n                    }\n                    if (doRender) {\n                      if (avatarStartTime >= 0) {\n                        minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                      }\n                      boolean errorWait=false;\n                      try {\n                        outputSurface.awaitNewImage();\n                      }\n catch (                      Exception e) {\n                        errorWait=true;\n                        FileLog.e(e);\n                      }\n                      if (!errorWait) {\n                        outputSurface.drawImage();\n                        inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                        inputSurface.swapBuffers();\n                      }\n                    }\n                    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                      decoderOutputAvailable=false;\n                      if (BuildVars.LOGS_ENABLED) {\n                        FileLog.d(\"decoder stream end\");\n                      }\n                      encoder.signalEndOfInputStream();\n                    }\n                  }\n                }\n              }\n            }\n          }\n catch (          Exception e) {\n            if (e instanceof IllegalStateException && !increaseTimeout) {\n              repeatWithIncreasedTimeout=true;\n            }\n            FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n            FileLog.e(e);\n            error=true;\n          }\n          extractor.unselectTrack(videoIndex);\n          if (decoder != null) {\n            decoder.stop();\n            decoder.release();\n          }\n        }\n        if (outputSurface != null) {\n          outputSurface.release();\n        }\n        if (inputSurface != null) {\n          inputSurface.release();\n        }\n        if (encoder != null) {\n          encoder.stop();\n          encoder.release();\n        }\n        if (audioRecoder != null) {\n          audioRecoder.release();\n        }\n        checkConversionCanceled();\n      }\n else {\n        readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n      }\n    }\n  }\n catch (  Exception e) {\n    error=true;\n    FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n    FileLog.e(e);\n  }\n finally {\n    if (extractor != null) {\n      extractor.release();\n    }\n    if (mediaMuxer != null) {\n      try {\n        mediaMuxer.finishMovie();\n        endPresentationTime=mediaMuxer.getLastFrameTimestamp(videoTrackIndex);\n      }\n catch (      Exception e) {\n        FileLog.e(e);\n      }\n    }\n  }\n  if (repeatWithIncreasedTimeout) {\n    return convertVideoInternal(videoPath,cacheFile,rotationValue,isSecret,resultWidth,resultHeight,framerate,bitrate,originalBitrate,startTime,endTime,avatarStartTime,duration,needCompress,true,savedFilterState,paintPath,mediaEntities,isPhoto,cropState);\n  }\n  return error;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 3519,
      "astHeight" : 38
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 45602,
        "startLineNumber" : 59,
        "startColumnNumber" : 4,
        "endLineNumber" : 773,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@TargetApi(18) private boolean convertVideoInternal(String videoPath,File cacheFile,int rotationValue,boolean isSecret,int resultWidth,int resultHeight,int framerate,int bitrate,int originalBitrate,long startTime,long endTime,long avatarStartTime,long duration,boolean needCompress,boolean increaseTimeout,MediaController.SavedFilterState savedFilterState,String paintPath,ArrayList<VideoEditedInfo.MediaEntity> mediaEntities,boolean isPhoto,MediaController.CropState cropState){\n  boolean error=false;\n  boolean repeatWithIncreasedTimeout=false;\n  int videoTrackIndex=-5;\n  try {\n    MediaCodec.BufferInfo info=new MediaCodec.BufferInfo();\n    Mp4Movie movie=new Mp4Movie();\n    movie.setCacheFile(cacheFile);\n    movie.setRotation(0);\n    movie.setSize(resultWidth,resultHeight);\n    mediaMuxer=new MP4Builder().createMovie(movie,isSecret);\n    long currentPts=0;\n    float durationS=duration / 1000f;\n    MediaCodec encoder=null;\n    InputSurface inputSurface=null;\n    OutputSurface outputSurface=null;\n    int prependHeaderSize=0;\n    endPresentationTime=duration * 1000;\n    checkConversionCanceled();\n    if (isPhoto) {\n      try {\n        boolean outputDone=false;\n        boolean decoderDone=false;\n        int framesCount=0;\n        if (avatarStartTime >= 0) {\n          if (durationS <= 2000) {\n            bitrate=2600000;\n          }\n else           if (durationS <= 5000) {\n            bitrate=2200000;\n          }\n else {\n            bitrate=1560000;\n          }\n        }\n else         if (bitrate <= 0) {\n          bitrate=921600;\n        }\n        if (resultWidth % 16 != 0) {\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"changing width from \" + resultWidth + \" to \"+ Math.round(resultWidth / 16.0f) * 16);\n          }\n          resultWidth=Math.round(resultWidth / 16.0f) * 16;\n        }\n        if (resultHeight % 16 != 0) {\n          if (BuildVars.LOGS_ENABLED) {\n            FileLog.d(\"changing height from \" + resultHeight + \" to \"+ Math.round(resultHeight / 16.0f) * 16);\n          }\n          resultHeight=Math.round(resultHeight / 16.0f) * 16;\n        }\n        if (BuildVars.LOGS_ENABLED) {\n          FileLog.d(\"create photo encoder \" + resultWidth + \" \"+ resultHeight+ \" duration = \"+ duration);\n        }\n        MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n        outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n        outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n        outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n        outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n        encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n        encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n        inputSurface=new InputSurface(encoder.createInputSurface());\n        inputSurface.makeCurrent();\n        encoder.start();\n        outputSurface=new OutputSurface(savedFilterState,videoPath,paintPath,mediaEntities,null,resultWidth,resultHeight,rotationValue,framerate,true);\n        ByteBuffer[] encoderOutputBuffers=null;\n        ByteBuffer[] encoderInputBuffers=null;\n        if (Build.VERSION.SDK_INT < 21) {\n          encoderOutputBuffers=encoder.getOutputBuffers();\n        }\n        boolean firstEncode=true;\n        checkConversionCanceled();\n        while (!outputDone) {\n          checkConversionCanceled();\n          boolean decoderOutputAvailable=!decoderDone;\n          boolean encoderOutputAvailable=true;\n          while (decoderOutputAvailable || encoderOutputAvailable) {\n            checkConversionCanceled();\n            int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n            if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n              encoderOutputAvailable=false;\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n              if (Build.VERSION.SDK_INT < 21) {\n                encoderOutputBuffers=encoder.getOutputBuffers();\n              }\n            }\n else             if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n              MediaFormat newFormat=encoder.getOutputFormat();\n              if (BuildVars.LOGS_ENABLED) {\n                FileLog.d(\"photo encoder new format \" + newFormat);\n              }\n              if (videoTrackIndex == -5 && newFormat != null) {\n                videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                  ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                  ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                  prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                }\n              }\n            }\n else             if (encoderStatus < 0) {\n              throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n            }\n else {\n              ByteBuffer encodedData;\n              if (Build.VERSION.SDK_INT < 21) {\n                encodedData=encoderOutputBuffers[encoderStatus];\n              }\n else {\n                encodedData=encoder.getOutputBuffer(encoderStatus);\n              }\n              if (encodedData == null) {\n                throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n              }\n              if (info.size > 1) {\n                if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                  if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    info.offset+=prependHeaderSize;\n                    info.size-=prependHeaderSize;\n                  }\n                  if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                    if (info.size > 100) {\n                      encodedData.position(info.offset);\n                      byte[] temp=new byte[100];\n                      encodedData.get(temp);\n                      int nalCount=0;\n                      for (int a=0; a < temp.length - 4; a++) {\n                        if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                          nalCount++;\n                          if (nalCount > 1) {\n                            info.offset+=a;\n                            info.size-=a;\n                            break;\n                          }\n                        }\n                      }\n                    }\n                    firstEncode=false;\n                  }\n                  long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                  if (availableSize != 0) {\n                    if (callback != null) {\n                      callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                    }\n                  }\n                }\n else                 if (videoTrackIndex == -5) {\n                  byte[] csd=new byte[info.size];\n                  encodedData.limit(info.offset + info.size);\n                  encodedData.position(info.offset);\n                  encodedData.get(csd);\n                  ByteBuffer sps=null;\n                  ByteBuffer pps=null;\n                  for (int a=info.size - 1; a >= 0; a--) {\n                    if (a > 3) {\n                      if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                        sps=ByteBuffer.allocate(a - 3);\n                        pps=ByteBuffer.allocate(info.size - (a - 3));\n                        sps.put(csd,0,a - 3).position(0);\n                        pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                        break;\n                      }\n                    }\n else {\n                      break;\n                    }\n                  }\n                  MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,resultWidth,resultHeight);\n                  if (sps != null && pps != null) {\n                    newFormat.setByteBuffer(\"csd-0\",sps);\n                    newFormat.setByteBuffer(\"csd-1\",pps);\n                  }\n                  videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                }\n              }\n              outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n              encoder.releaseOutputBuffer(encoderStatus,false);\n            }\n            if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n              continue;\n            }\n            if (!decoderDone) {\n              outputSurface.drawImage();\n              long presentationTime=(long)(framesCount / 30.0f * 1000L * 1000L * 1000L);\n              inputSurface.setPresentationTime(presentationTime);\n              inputSurface.swapBuffers();\n              framesCount++;\n              if (framesCount >= duration / 1000.0f * 30) {\n                decoderDone=true;\n                decoderOutputAvailable=false;\n                encoder.signalEndOfInputStream();\n              }\n            }\n          }\n        }\n      }\n catch (      Exception e) {\n        if (e instanceof IllegalStateException && !increaseTimeout) {\n          repeatWithIncreasedTimeout=true;\n        }\n        FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n        FileLog.e(e);\n        error=true;\n      }\n      if (outputSurface != null) {\n        outputSurface.release();\n      }\n      if (inputSurface != null) {\n        inputSurface.release();\n      }\n      if (encoder != null) {\n        encoder.stop();\n        encoder.release();\n      }\n      checkConversionCanceled();\n    }\n else {\n      extractor=new MediaExtractor();\n      extractor.setDataSource(videoPath);\n      int videoIndex=MediaController.findTrack(extractor,false);\n      int audioIndex=bitrate != -1 ? MediaController.findTrack(extractor,true) : -1;\n      boolean needConvertVideo=false;\n      if (videoIndex >= 0 && !extractor.getTrackFormat(videoIndex).getString(MediaFormat.KEY_MIME).equals(MediaController.VIDEO_MIME_TYPE)) {\n        needConvertVideo=true;\n      }\n      if (needCompress || needConvertVideo) {\n        AudioRecoder audioRecoder=null;\n        ByteBuffer audioBuffer=null;\n        boolean copyAudioBuffer=true;\n        if (videoIndex >= 0) {\n          MediaCodec decoder=null;\n          try {\n            long videoTime=-1;\n            boolean outputDone=false;\n            boolean inputDone=false;\n            boolean decoderDone=false;\n            int swapUV=0;\n            int audioTrackIndex=-5;\n            long additionalPresentationTime=0;\n            long minPresentationTime=Integer.MIN_VALUE;\n            long frameDelta=1000 / framerate * 1000;\n            extractor.selectTrack(videoIndex);\n            MediaFormat videoFormat=extractor.getTrackFormat(videoIndex);\n            if (avatarStartTime >= 0) {\n              if (durationS <= 2000) {\n                bitrate=2600000;\n              }\n else               if (durationS <= 5000) {\n                bitrate=2200000;\n              }\n else {\n                bitrate=1560000;\n              }\n              avatarStartTime=0;\n            }\n else             if (bitrate <= 0) {\n              bitrate=921600;\n            }\n            if (originalBitrate > 0) {\n              bitrate=Math.min(originalBitrate,bitrate);\n            }\n            long trueStartTime;\n            if (avatarStartTime >= 0) {\n              avatarStartTime=-1;\n            }\n            if (avatarStartTime >= 0) {\n              extractor.seekTo(avatarStartTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else             if (startTime > 0) {\n              extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n else {\n              extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n            }\n            int w;\n            int h;\n            if (cropState != null) {\n              if (rotationValue == 90 || rotationValue == 270) {\n                w=cropState.transformHeight;\n                h=cropState.transformWidth;\n              }\n else {\n                w=cropState.transformWidth;\n                h=cropState.transformHeight;\n              }\n            }\n else {\n              w=resultWidth;\n              h=resultHeight;\n            }\n            if (BuildVars.LOGS_ENABLED) {\n              FileLog.d(\"create encoder with w = \" + w + \" h = \"+ h);\n            }\n            MediaFormat outputFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n            outputFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT,MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface);\n            outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n            outputFormat.setInteger(MediaFormat.KEY_FRAME_RATE,framerate);\n            outputFormat.setInteger(MediaFormat.KEY_I_FRAME_INTERVAL,2);\n            if (Build.VERSION.SDK_INT < 23 && Math.min(h,w) <= 480) {\n              if (bitrate > 921600) {\n                bitrate=921600;\n              }\n              outputFormat.setInteger(MediaFormat.KEY_BIT_RATE,bitrate);\n            }\n            encoder=MediaCodec.createEncoderByType(MediaController.VIDEO_MIME_TYPE);\n            encoder.configure(outputFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE);\n            inputSurface=new InputSurface(encoder.createInputSurface());\n            inputSurface.makeCurrent();\n            encoder.start();\n            decoder=MediaCodec.createDecoderByType(videoFormat.getString(MediaFormat.KEY_MIME));\n            outputSurface=new OutputSurface(savedFilterState,null,paintPath,mediaEntities,cropState,resultWidth,resultHeight,rotationValue,framerate,false);\n            decoder.configure(videoFormat,outputSurface.getSurface(),null,0);\n            decoder.start();\n            ByteBuffer[] decoderInputBuffers=null;\n            ByteBuffer[] encoderOutputBuffers=null;\n            ByteBuffer[] encoderInputBuffers=null;\n            if (Build.VERSION.SDK_INT < 21) {\n              decoderInputBuffers=decoder.getInputBuffers();\n              encoderOutputBuffers=encoder.getOutputBuffers();\n            }\n            if (audioIndex >= 0) {\n              MediaFormat audioFormat=extractor.getTrackFormat(audioIndex);\n              copyAudioBuffer=audioFormat.getString(MediaFormat.KEY_MIME).equals(MediaController.AUIDO_MIME_TYPE) || audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/mpeg\");\n              if (audioFormat.getString(MediaFormat.KEY_MIME).equals(\"audio/unknown\")) {\n                audioIndex=-1;\n              }\n              if (audioIndex >= 0) {\n                if (copyAudioBuffer) {\n                  audioTrackIndex=mediaMuxer.addTrack(audioFormat,true);\n                  extractor.selectTrack(audioIndex);\n                  int maxBufferSize=audioFormat.getInteger(MediaFormat.KEY_MAX_INPUT_SIZE);\n                  audioBuffer=ByteBuffer.allocateDirect(maxBufferSize);\n                  if (startTime > 0) {\n                    extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                }\n else {\n                  MediaExtractor audioExtractor=new MediaExtractor();\n                  audioExtractor.setDataSource(videoPath);\n                  audioExtractor.selectTrack(audioIndex);\n                  if (startTime > 0) {\n                    audioExtractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n else {\n                    audioExtractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                  }\n                  audioRecoder=new AudioRecoder(audioFormat,audioExtractor,audioIndex);\n                  audioRecoder.startTime=startTime;\n                  audioRecoder.endTime=endTime;\n                  audioTrackIndex=mediaMuxer.addTrack(audioRecoder.format,true);\n                }\n              }\n            }\n            boolean audioEncoderDone=audioIndex < 0;\n            boolean firstEncode=true;\n            checkConversionCanceled();\n            while (!outputDone || (!copyAudioBuffer && !audioEncoderDone)) {\n              checkConversionCanceled();\n              if (!copyAudioBuffer && audioRecoder != null) {\n                audioEncoderDone=audioRecoder.step(mediaMuxer,audioTrackIndex);\n              }\n              if (!inputDone) {\n                boolean eof=false;\n                int index=extractor.getSampleTrackIndex();\n                if (index == videoIndex) {\n                  int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (inputBufIndex >= 0) {\n                    ByteBuffer inputBuf;\n                    if (Build.VERSION.SDK_INT < 21) {\n                      inputBuf=decoderInputBuffers[inputBufIndex];\n                    }\n else {\n                      inputBuf=decoder.getInputBuffer(inputBufIndex);\n                    }\n                    int chunkSize=extractor.readSampleData(inputBuf,0);\n                    if (chunkSize < 0) {\n                      decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                      inputDone=true;\n                    }\n else {\n                      decoder.queueInputBuffer(inputBufIndex,0,chunkSize,extractor.getSampleTime(),0);\n                      extractor.advance();\n                    }\n                  }\n                }\n else                 if (copyAudioBuffer && audioIndex != -1 && index == audioIndex) {\n                  info.size=extractor.readSampleData(audioBuffer,0);\n                  if (Build.VERSION.SDK_INT < 21) {\n                    audioBuffer.position(0);\n                    audioBuffer.limit(info.size);\n                  }\n                  if (info.size >= 0) {\n                    info.presentationTimeUs=extractor.getSampleTime();\n                    extractor.advance();\n                  }\n else {\n                    info.size=0;\n                    inputDone=true;\n                  }\n                  if (info.size > 0 && (endTime < 0 || info.presentationTimeUs < endTime)) {\n                    info.offset=0;\n                    info.flags=extractor.getSampleFlags();\n                    long availableSize=mediaMuxer.writeSampleData(audioTrackIndex,audioBuffer,info,false);\n                    if (availableSize != 0) {\n                      if (callback != null) {\n                        if (info.presentationTimeUs - startTime > currentPts) {\n                          currentPts=info.presentationTimeUs - startTime;\n                        }\n                        callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                      }\n                    }\n                  }\n                }\n else                 if (index == -1) {\n                  eof=true;\n                }\n                if (eof) {\n                  int inputBufIndex=decoder.dequeueInputBuffer(MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (inputBufIndex >= 0) {\n                    decoder.queueInputBuffer(inputBufIndex,0,0,0L,MediaCodec.BUFFER_FLAG_END_OF_STREAM);\n                    inputDone=true;\n                  }\n                }\n              }\n              boolean decoderOutputAvailable=!decoderDone;\n              boolean encoderOutputAvailable=true;\n              while (decoderOutputAvailable || encoderOutputAvailable) {\n                checkConversionCanceled();\n                int encoderStatus=encoder.dequeueOutputBuffer(info,increaseTimeout ? MEDIACODEC_TIMEOUT_INCREASED : MEDIACODEC_TIMEOUT_DEFAULT);\n                if (encoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  encoderOutputAvailable=false;\n                }\n else                 if (encoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                  if (Build.VERSION.SDK_INT < 21) {\n                    encoderOutputBuffers=encoder.getOutputBuffers();\n                  }\n                }\n else                 if (encoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                  MediaFormat newFormat=encoder.getOutputFormat();\n                  if (videoTrackIndex == -5 && newFormat != null) {\n                    videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                    if (newFormat.containsKey(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) && newFormat.getInteger(MediaFormat.KEY_PREPEND_HEADER_TO_SYNC_FRAMES) == 1) {\n                      ByteBuffer spsBuff=newFormat.getByteBuffer(\"csd-0\");\n                      ByteBuffer ppsBuff=newFormat.getByteBuffer(\"csd-1\");\n                      prependHeaderSize=spsBuff.limit() + ppsBuff.limit();\n                    }\n                  }\n                }\n else                 if (encoderStatus < 0) {\n                  throw new RuntimeException(\"unexpected result from encoder.dequeueOutputBuffer: \" + encoderStatus);\n                }\n else {\n                  ByteBuffer encodedData;\n                  if (Build.VERSION.SDK_INT < 21) {\n                    encodedData=encoderOutputBuffers[encoderStatus];\n                  }\n else {\n                    encodedData=encoder.getOutputBuffer(encoderStatus);\n                  }\n                  if (encodedData == null) {\n                    throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n                  }\n                  if (info.size > 1) {\n                    if ((info.flags & MediaCodec.BUFFER_FLAG_CODEC_CONFIG) == 0) {\n                      if (prependHeaderSize != 0 && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                        info.offset+=prependHeaderSize;\n                        info.size-=prependHeaderSize;\n                      }\n                      if (firstEncode && (info.flags & MediaCodec.BUFFER_FLAG_KEY_FRAME) != 0) {\n                        if (info.size > 100) {\n                          encodedData.position(info.offset);\n                          byte[] temp=new byte[100];\n                          encodedData.get(temp);\n                          int nalCount=0;\n                          for (int a=0; a < temp.length - 4; a++) {\n                            if (temp[a] == 0 && temp[a + 1] == 0 && temp[a + 2] == 0 && temp[a + 3] == 1) {\n                              nalCount++;\n                              if (nalCount > 1) {\n                                info.offset+=a;\n                                info.size-=a;\n                                break;\n                              }\n                            }\n                          }\n                        }\n                        firstEncode=false;\n                      }\n                      long availableSize=mediaMuxer.writeSampleData(videoTrackIndex,encodedData,info,true);\n                      if (availableSize != 0) {\n                        if (callback != null) {\n                          if (info.presentationTimeUs - startTime > currentPts) {\n                            currentPts=info.presentationTimeUs - startTime;\n                          }\n                          callback.didWriteData(availableSize,(currentPts / 1000f) / durationS);\n                        }\n                      }\n                    }\n else                     if (videoTrackIndex == -5) {\n                      byte[] csd=new byte[info.size];\n                      encodedData.limit(info.offset + info.size);\n                      encodedData.position(info.offset);\n                      encodedData.get(csd);\n                      ByteBuffer sps=null;\n                      ByteBuffer pps=null;\n                      for (int a=info.size - 1; a >= 0; a--) {\n                        if (a > 3) {\n                          if (csd[a] == 1 && csd[a - 1] == 0 && csd[a - 2] == 0 && csd[a - 3] == 0) {\n                            sps=ByteBuffer.allocate(a - 3);\n                            pps=ByteBuffer.allocate(info.size - (a - 3));\n                            sps.put(csd,0,a - 3).position(0);\n                            pps.put(csd,a - 3,info.size - (a - 3)).position(0);\n                            break;\n                          }\n                        }\n else {\n                          break;\n                        }\n                      }\n                      MediaFormat newFormat=MediaFormat.createVideoFormat(MediaController.VIDEO_MIME_TYPE,w,h);\n                      if (sps != null && pps != null) {\n                        newFormat.setByteBuffer(\"csd-0\",sps);\n                        newFormat.setByteBuffer(\"csd-1\",pps);\n                      }\n                      videoTrackIndex=mediaMuxer.addTrack(newFormat,false);\n                    }\n                  }\n                  outputDone=(info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0;\n                  encoder.releaseOutputBuffer(encoderStatus,false);\n                }\n                if (encoderStatus != MediaCodec.INFO_TRY_AGAIN_LATER) {\n                  continue;\n                }\n                if (!decoderDone) {\n                  int decoderStatus=decoder.dequeueOutputBuffer(info,MEDIACODEC_TIMEOUT_DEFAULT);\n                  if (decoderStatus == MediaCodec.INFO_TRY_AGAIN_LATER) {\n                    decoderOutputAvailable=false;\n                  }\n else                   if (decoderStatus == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {\n                  }\n else                   if (decoderStatus == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {\n                    MediaFormat newFormat=decoder.getOutputFormat();\n                    if (BuildVars.LOGS_ENABLED) {\n                      FileLog.d(\"newFormat = \" + newFormat);\n                    }\n                  }\n else                   if (decoderStatus < 0) {\n                    throw new RuntimeException(\"unexpected result from decoder.dequeueOutputBuffer: \" + decoderStatus);\n                  }\n else {\n                    boolean doRender=info.size != 0;\n                    long originalPresentationTime=info.presentationTimeUs;\n                    if (endTime > 0 && originalPresentationTime >= endTime) {\n                      inputDone=true;\n                      decoderDone=true;\n                      doRender=false;\n                      info.flags|=MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                    }\n                    boolean flushed=false;\n                    if (avatarStartTime >= 0 && (info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0 && Math.abs(avatarStartTime - startTime) > 1000000 / framerate) {\n                      if (startTime > 0) {\n                        extractor.seekTo(startTime,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                      }\n else {\n                        extractor.seekTo(0,MediaExtractor.SEEK_TO_PREVIOUS_SYNC);\n                      }\n                      additionalPresentationTime=minPresentationTime + frameDelta;\n                      endTime=avatarStartTime;\n                      avatarStartTime=-1;\n                      inputDone=false;\n                      decoderDone=false;\n                      doRender=false;\n                      info.flags&=~MediaCodec.BUFFER_FLAG_END_OF_STREAM;\n                      decoder.flush();\n                      flushed=true;\n                    }\n                    trueStartTime=avatarStartTime >= 0 ? avatarStartTime : startTime;\n                    if (trueStartTime > 0 && videoTime == -1) {\n                      if (originalPresentationTime < trueStartTime) {\n                        doRender=false;\n                        if (BuildVars.LOGS_ENABLED) {\n                          FileLog.d(\"drop frame startTime = \" + trueStartTime + \" present time = \"+ info.presentationTimeUs);\n                        }\n                      }\n else {\n                        videoTime=info.presentationTimeUs;\n                        if (minPresentationTime != Integer.MIN_VALUE) {\n                          additionalPresentationTime-=videoTime;\n                        }\n                      }\n                    }\n                    if (flushed) {\n                      videoTime=-1;\n                    }\n else {\n                      if (avatarStartTime == -1 && additionalPresentationTime != 0) {\n                        info.presentationTimeUs+=additionalPresentationTime;\n                      }\n                      decoder.releaseOutputBuffer(decoderStatus,doRender);\n                    }\n                    if (doRender) {\n                      if (avatarStartTime >= 0) {\n                        minPresentationTime=Math.max(minPresentationTime,info.presentationTimeUs);\n                      }\n                      boolean errorWait=false;\n                      try {\n                        outputSurface.awaitNewImage();\n                      }\n catch (                      Exception e) {\n                        errorWait=true;\n                        FileLog.e(e);\n                      }\n                      if (!errorWait) {\n                        outputSurface.drawImage();\n                        inputSurface.setPresentationTime(info.presentationTimeUs * 1000);\n                        inputSurface.swapBuffers();\n                      }\n                    }\n                    if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0) {\n                      decoderOutputAvailable=false;\n                      if (BuildVars.LOGS_ENABLED) {\n                        FileLog.d(\"decoder stream end\");\n                      }\n                      encoder.signalEndOfInputStream();\n                    }\n                  }\n                }\n              }\n            }\n          }\n catch (          Exception e) {\n            if (e instanceof IllegalStateException && !increaseTimeout) {\n              repeatWithIncreasedTimeout=true;\n            }\n            FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n            FileLog.e(e);\n            error=true;\n          }\n          extractor.unselectTrack(videoIndex);\n          if (decoder != null) {\n            decoder.stop();\n            decoder.release();\n          }\n        }\n        if (outputSurface != null) {\n          outputSurface.release();\n        }\n        if (inputSurface != null) {\n          inputSurface.release();\n        }\n        if (encoder != null) {\n          encoder.stop();\n          encoder.release();\n        }\n        if (audioRecoder != null) {\n          audioRecoder.release();\n        }\n        checkConversionCanceled();\n      }\n else {\n        readAndWriteTracks(extractor,mediaMuxer,info,startTime,endTime,duration,cacheFile,bitrate != -1);\n      }\n    }\n  }\n catch (  Exception e) {\n    error=true;\n    FileLog.e(\"bitrate: \" + bitrate + \" framerate: \"+ framerate+ \" size: \"+ resultHeight+ \"x\"+ resultWidth);\n    FileLog.e(e);\n  }\n finally {\n    if (extractor != null) {\n      extractor.release();\n    }\n    if (mediaMuxer != null) {\n      try {\n        mediaMuxer.finishMovie();\n        endPresentationTime=mediaMuxer.getLastFrameTimestamp(videoTrackIndex);\n      }\n catch (      Exception e) {\n        FileLog.e(e);\n      }\n    }\n  }\n  if (repeatWithIncreasedTimeout) {\n    return convertVideoInternal(videoPath,cacheFile,rotationValue,isSecret,resultWidth,resultHeight,framerate,bitrate,originalBitrate,startTime,endTime,avatarStartTime,duration,needCompress,true,savedFilterState,paintPath,mediaEntities,isPhoto,cropState);\n  }\n  return error;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 3601,
      "astHeight" : 39
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 81,
        "startLineNumber" : 550,
        "startColumnNumber" : 44,
        "endLineNumber" : 550,
        "endColumnNumber" : 125
      },
      "nodeContext" : "throw new RuntimeException(\"encoderOutputBuffer \" + encoderStatus + \" was null\");\n",
      "nodeType" : "ThrowStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  } ],
  "positionList" : [ {
    "charLength" : 22,
    "startLineNumber" : 190,
    "startColumnNumber" : 63,
    "endLineNumber" : 190,
    "endColumnNumber" : 85
  }, {
    "charLength" : 22,
    "startLineNumber" : 550,
    "startColumnNumber" : 71,
    "endLineNumber" : 550,
    "endColumnNumber" : 93
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 17
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 21
  } ]
}