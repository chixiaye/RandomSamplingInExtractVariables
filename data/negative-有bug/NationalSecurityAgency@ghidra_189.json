{
  "id" : 189,
  "expression" : "latestOnly",
  "projectName" : "NationalSecurityAgency@ghidra",
  "commitID" : "a54d0e28d652c48502551a88278808549aed5f98",
  "filePath" : "/Ghidra/Features/Base/src/main/java/ghidra/app/merge/listing/FunctionMerger.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "latestOnly",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 10,
      "startLineNumber" : 449,
      "startColumnNumber" : 31,
      "endLineNumber" : 449,
      "endColumnNumber" : 41
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 27,
        "startLineNumber" : 449,
        "startColumnNumber" : 31,
        "endLineNumber" : 449,
        "endColumnNumber" : 58
      },
      "nodeContext" : "latestOnly.intersect(addMy)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 53,
        "startLineNumber" : 449,
        "startColumnNumber" : 6,
        "endLineNumber" : 449,
        "endColumnNumber" : 59
      },
      "nodeContext" : "conflictingMyEntries.add(latestOnly.intersect(addMy))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 449,
        "startColumnNumber" : 6,
        "endLineNumber" : 449,
        "endColumnNumber" : 60
      },
      "nodeContext" : "conflictingMyEntries.add(latestOnly.intersect(addMy));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 600,
        "startLineNumber" : 446,
        "startColumnNumber" : 80,
        "endLineNumber" : 457,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  AddressSet conflictingMyEntries=new AddressSet();\n  conflictingMyEntries.add(latestOnly.intersect(addMy));\n  conflictingMyEntries.add(latestOnly.intersect(changeMy));\n  if (!conflictingMyEntries.isEmpty()) {\n    entryConflictSet.add(latestBody);\n    entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n  }\n  newEntries.add(conflictingMyEntries);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 51,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 675,
        "startLineNumber" : 446,
        "startColumnNumber" : 5,
        "endLineNumber" : 457,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n  AddressSet conflictingMyEntries=new AddressSet();\n  conflictingMyEntries.add(latestOnly.intersect(addMy));\n  conflictingMyEntries.add(latestOnly.intersect(changeMy));\n  if (!conflictingMyEntries.isEmpty()) {\n    entryConflictSet.add(latestBody);\n    entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n  }\n  newEntries.add(conflictingMyEntries);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 61,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 2089,
        "startLineNumber" : 431,
        "startColumnNumber" : 32,
        "endLineNumber" : 472,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  Address entry=entryIter.next();\n  Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n  Function myFunc=functionManagers[MY].getFunctionAt(entry);\n  AddressSet latestBody=new AddressSet();\n  if (latestFunc != null) {\n    latestBody.add(latestFunc.getBody());\n  }\n  AddressSet myBody=new AddressSet();\n  if (myFunc != null) {\n    myBody.add(myFunc.getBody());\n  }\n  AddressSet latestOnly=latestBody.subtract(myBody);\n  AddressSet myOnly=myBody.subtract(latestBody);\n  if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n    AddressSet conflictingMyEntries=new AddressSet();\n    conflictingMyEntries.add(latestOnly.intersect(addMy));\n    conflictingMyEntries.add(latestOnly.intersect(changeMy));\n    if (!conflictingMyEntries.isEmpty()) {\n      entryConflictSet.add(latestBody);\n      entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n    }\n    newEntries.add(conflictingMyEntries);\n  }\n  if (addMy.contains(entry) || changeMy.contains(entry)) {\n    AddressSet conflictingLatestEntries=new AddressSet();\n    conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n    conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n    if (!conflictingLatestEntries.isEmpty()) {\n      entryConflictSet.add(myBody);\n      entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n    }\n    newEntries.add(conflictingLatestEntries);\n  }\n  alreadyChecked.addRange(entry,entry);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 217,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2117,
        "startLineNumber" : 431,
        "startColumnNumber" : 4,
        "endLineNumber" : 472,
        "endColumnNumber" : 5
      },
      "nodeContext" : "while (entryIter.hasNext()) {\n  Address entry=entryIter.next();\n  Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n  Function myFunc=functionManagers[MY].getFunctionAt(entry);\n  AddressSet latestBody=new AddressSet();\n  if (latestFunc != null) {\n    latestBody.add(latestFunc.getBody());\n  }\n  AddressSet myBody=new AddressSet();\n  if (myFunc != null) {\n    myBody.add(myFunc.getBody());\n  }\n  AddressSet latestOnly=latestBody.subtract(myBody);\n  AddressSet myOnly=myBody.subtract(latestBody);\n  if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n    AddressSet conflictingMyEntries=new AddressSet();\n    conflictingMyEntries.add(latestOnly.intersect(addMy));\n    conflictingMyEntries.add(latestOnly.intersect(changeMy));\n    if (!conflictingMyEntries.isEmpty()) {\n      entryConflictSet.add(latestBody);\n      entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n    }\n    newEntries.add(conflictingMyEntries);\n  }\n  if (addMy.contains(entry) || changeMy.contains(entry)) {\n    AddressSet conflictingLatestEntries=new AddressSet();\n    conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n    conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n    if (!conflictingLatestEntries.isEmpty()) {\n      entryConflictSet.add(myBody);\n      entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n    }\n    newEntries.add(conflictingLatestEntries);\n  }\n  alreadyChecked.addRange(entry,entry);\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 221,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 2394,
        "startLineNumber" : 428,
        "startColumnNumber" : 35,
        "endLineNumber" : 475,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  AddressSet newEntries=new AddressSet();\n  AddressIterator entryIter=checkEntries.getAddresses(true);\n  while (entryIter.hasNext()) {\n    Address entry=entryIter.next();\n    Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n    Function myFunc=functionManagers[MY].getFunctionAt(entry);\n    AddressSet latestBody=new AddressSet();\n    if (latestFunc != null) {\n      latestBody.add(latestFunc.getBody());\n    }\n    AddressSet myBody=new AddressSet();\n    if (myFunc != null) {\n      myBody.add(myFunc.getBody());\n    }\n    AddressSet latestOnly=latestBody.subtract(myBody);\n    AddressSet myOnly=myBody.subtract(latestBody);\n    if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n      AddressSet conflictingMyEntries=new AddressSet();\n      conflictingMyEntries.add(latestOnly.intersect(addMy));\n      conflictingMyEntries.add(latestOnly.intersect(changeMy));\n      if (!conflictingMyEntries.isEmpty()) {\n        entryConflictSet.add(latestBody);\n        entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n      }\n      newEntries.add(conflictingMyEntries);\n    }\n    if (addMy.contains(entry) || changeMy.contains(entry)) {\n      AddressSet conflictingLatestEntries=new AddressSet();\n      conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n      conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n      if (!conflictingLatestEntries.isEmpty()) {\n        entryConflictSet.add(myBody);\n        entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n      }\n      newEntries.add(conflictingLatestEntries);\n    }\n    alreadyChecked.addRange(entry,entry);\n  }\n  checkEntries=newEntries.subtract(alreadyChecked);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 246,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2426,
        "startLineNumber" : 428,
        "startColumnNumber" : 3,
        "endLineNumber" : 475,
        "endColumnNumber" : 4
      },
      "nodeContext" : "while (!checkEntries.isEmpty()) {\n  AddressSet newEntries=new AddressSet();\n  AddressIterator entryIter=checkEntries.getAddresses(true);\n  while (entryIter.hasNext()) {\n    Address entry=entryIter.next();\n    Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n    Function myFunc=functionManagers[MY].getFunctionAt(entry);\n    AddressSet latestBody=new AddressSet();\n    if (latestFunc != null) {\n      latestBody.add(latestFunc.getBody());\n    }\n    AddressSet myBody=new AddressSet();\n    if (myFunc != null) {\n      myBody.add(myFunc.getBody());\n    }\n    AddressSet latestOnly=latestBody.subtract(myBody);\n    AddressSet myOnly=myBody.subtract(latestBody);\n    if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n      AddressSet conflictingMyEntries=new AddressSet();\n      conflictingMyEntries.add(latestOnly.intersect(addMy));\n      conflictingMyEntries.add(latestOnly.intersect(changeMy));\n      if (!conflictingMyEntries.isEmpty()) {\n        entryConflictSet.add(latestBody);\n        entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n      }\n      newEntries.add(conflictingMyEntries);\n    }\n    if (addMy.contains(entry) || changeMy.contains(entry)) {\n      AddressSet conflictingLatestEntries=new AddressSet();\n      conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n      conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n      if (!conflictingLatestEntries.isEmpty()) {\n        entryConflictSet.add(myBody);\n        entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n      }\n      newEntries.add(conflictingLatestEntries);\n    }\n    alreadyChecked.addRange(entry,entry);\n  }\n  checkEntries=newEntries.subtract(alreadyChecked);\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 251,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 3121,
        "startLineNumber" : 416,
        "startColumnNumber" : 25,
        "endLineNumber" : 482,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  monitor.checkCanceled();\n  Address changeEntry=iter.next();\n  if (overlapAddressSet.contains(changeEntry)) {\n    continue;\n  }\n  if (alreadyChecked.contains(changeEntry)) {\n    continue;\n  }\n  AddressSet entryConflictSet=new AddressSet();\n  AddressSet checkEntries=new AddressSet(changeEntry,changeEntry);\n  while (!checkEntries.isEmpty()) {\n    AddressSet newEntries=new AddressSet();\n    AddressIterator entryIter=checkEntries.getAddresses(true);\n    while (entryIter.hasNext()) {\n      Address entry=entryIter.next();\n      Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n      Function myFunc=functionManagers[MY].getFunctionAt(entry);\n      AddressSet latestBody=new AddressSet();\n      if (latestFunc != null) {\n        latestBody.add(latestFunc.getBody());\n      }\n      AddressSet myBody=new AddressSet();\n      if (myFunc != null) {\n        myBody.add(myFunc.getBody());\n      }\n      AddressSet latestOnly=latestBody.subtract(myBody);\n      AddressSet myOnly=myBody.subtract(latestBody);\n      if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n        AddressSet conflictingMyEntries=new AddressSet();\n        conflictingMyEntries.add(latestOnly.intersect(addMy));\n        conflictingMyEntries.add(latestOnly.intersect(changeMy));\n        if (!conflictingMyEntries.isEmpty()) {\n          entryConflictSet.add(latestBody);\n          entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n        }\n        newEntries.add(conflictingMyEntries);\n      }\n      if (addMy.contains(entry) || changeMy.contains(entry)) {\n        AddressSet conflictingLatestEntries=new AddressSet();\n        conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n        conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n        if (!conflictingLatestEntries.isEmpty()) {\n          entryConflictSet.add(myBody);\n          entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n        }\n        newEntries.add(conflictingLatestEntries);\n      }\n      alreadyChecked.addRange(entry,entry);\n    }\n    checkEntries=newEntries.subtract(alreadyChecked);\n  }\n  if (!entryConflictSet.isEmpty()) {\n    overlapConflicts.put(changeEntry,entryConflictSet);\n    overlapConflictSet.addRange(changeEntry,changeEntry);\n    overlapAddressSet.add(entryConflictSet);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 319,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3144,
        "startLineNumber" : 416,
        "startColumnNumber" : 2,
        "endLineNumber" : 482,
        "endColumnNumber" : 3
      },
      "nodeContext" : "while (iter.hasNext()) {\n  monitor.checkCanceled();\n  Address changeEntry=iter.next();\n  if (overlapAddressSet.contains(changeEntry)) {\n    continue;\n  }\n  if (alreadyChecked.contains(changeEntry)) {\n    continue;\n  }\n  AddressSet entryConflictSet=new AddressSet();\n  AddressSet checkEntries=new AddressSet(changeEntry,changeEntry);\n  while (!checkEntries.isEmpty()) {\n    AddressSet newEntries=new AddressSet();\n    AddressIterator entryIter=checkEntries.getAddresses(true);\n    while (entryIter.hasNext()) {\n      Address entry=entryIter.next();\n      Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n      Function myFunc=functionManagers[MY].getFunctionAt(entry);\n      AddressSet latestBody=new AddressSet();\n      if (latestFunc != null) {\n        latestBody.add(latestFunc.getBody());\n      }\n      AddressSet myBody=new AddressSet();\n      if (myFunc != null) {\n        myBody.add(myFunc.getBody());\n      }\n      AddressSet latestOnly=latestBody.subtract(myBody);\n      AddressSet myOnly=myBody.subtract(latestBody);\n      if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n        AddressSet conflictingMyEntries=new AddressSet();\n        conflictingMyEntries.add(latestOnly.intersect(addMy));\n        conflictingMyEntries.add(latestOnly.intersect(changeMy));\n        if (!conflictingMyEntries.isEmpty()) {\n          entryConflictSet.add(latestBody);\n          entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n        }\n        newEntries.add(conflictingMyEntries);\n      }\n      if (addMy.contains(entry) || changeMy.contains(entry)) {\n        AddressSet conflictingLatestEntries=new AddressSet();\n        conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n        conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n        if (!conflictingLatestEntries.isEmpty()) {\n          entryConflictSet.add(myBody);\n          entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n        }\n        newEntries.add(conflictingLatestEntries);\n      }\n      alreadyChecked.addRange(entry,entry);\n    }\n    checkEntries=newEntries.subtract(alreadyChecked);\n  }\n  if (!entryConflictSet.isEmpty()) {\n    overlapConflicts.put(changeEntry,entryConflictSet);\n    overlapConflictSet.addRange(changeEntry,changeEntry);\n    overlapAddressSet.add(entryConflictSet);\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 323,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3361,
        "startLineNumber" : 411,
        "startColumnNumber" : 29,
        "endLineNumber" : 483,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  monitor.checkCanceled();\n  AddressSet alreadyChecked=new AddressSet();\n  AddressIterator iter=changeSet.getAddresses(true);\n  while (iter.hasNext()) {\n    monitor.checkCanceled();\n    Address changeEntry=iter.next();\n    if (overlapAddressSet.contains(changeEntry)) {\n      continue;\n    }\n    if (alreadyChecked.contains(changeEntry)) {\n      continue;\n    }\n    AddressSet entryConflictSet=new AddressSet();\n    AddressSet checkEntries=new AddressSet(changeEntry,changeEntry);\n    while (!checkEntries.isEmpty()) {\n      AddressSet newEntries=new AddressSet();\n      AddressIterator entryIter=checkEntries.getAddresses(true);\n      while (entryIter.hasNext()) {\n        Address entry=entryIter.next();\n        Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n        Function myFunc=functionManagers[MY].getFunctionAt(entry);\n        AddressSet latestBody=new AddressSet();\n        if (latestFunc != null) {\n          latestBody.add(latestFunc.getBody());\n        }\n        AddressSet myBody=new AddressSet();\n        if (myFunc != null) {\n          myBody.add(myFunc.getBody());\n        }\n        AddressSet latestOnly=latestBody.subtract(myBody);\n        AddressSet myOnly=myBody.subtract(latestBody);\n        if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n          AddressSet conflictingMyEntries=new AddressSet();\n          conflictingMyEntries.add(latestOnly.intersect(addMy));\n          conflictingMyEntries.add(latestOnly.intersect(changeMy));\n          if (!conflictingMyEntries.isEmpty()) {\n            entryConflictSet.add(latestBody);\n            entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n          }\n          newEntries.add(conflictingMyEntries);\n        }\n        if (addMy.contains(entry) || changeMy.contains(entry)) {\n          AddressSet conflictingLatestEntries=new AddressSet();\n          conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n          conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n          if (!conflictingLatestEntries.isEmpty()) {\n            entryConflictSet.add(myBody);\n            entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n          }\n          newEntries.add(conflictingLatestEntries);\n        }\n        alreadyChecked.addRange(entry,entry);\n      }\n      checkEntries=newEntries.subtract(alreadyChecked);\n    }\n    if (!entryConflictSet.isEmpty()) {\n      overlapConflicts.put(changeEntry,entryConflictSet);\n      overlapConflictSet.addRange(changeEntry,changeEntry);\n      overlapAddressSet.add(entryConflictSet);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 345,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3633,
        "startLineNumber" : 404,
        "startColumnNumber" : 1,
        "endLineNumber" : 483,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * @param changeSet address set indicating where either Latest or My changed a function.\n * @param monitor\n * @throws CancelledException\n */\nprivate void determineOverlapConflicts(AddressSet changeSet,TaskMonitor monitor) throws CancelledException {\n  monitor.checkCanceled();\n  AddressSet alreadyChecked=new AddressSet();\n  AddressIterator iter=changeSet.getAddresses(true);\n  while (iter.hasNext()) {\n    monitor.checkCanceled();\n    Address changeEntry=iter.next();\n    if (overlapAddressSet.contains(changeEntry)) {\n      continue;\n    }\n    if (alreadyChecked.contains(changeEntry)) {\n      continue;\n    }\n    AddressSet entryConflictSet=new AddressSet();\n    AddressSet checkEntries=new AddressSet(changeEntry,changeEntry);\n    while (!checkEntries.isEmpty()) {\n      AddressSet newEntries=new AddressSet();\n      AddressIterator entryIter=checkEntries.getAddresses(true);\n      while (entryIter.hasNext()) {\n        Address entry=entryIter.next();\n        Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n        Function myFunc=functionManagers[MY].getFunctionAt(entry);\n        AddressSet latestBody=new AddressSet();\n        if (latestFunc != null) {\n          latestBody.add(latestFunc.getBody());\n        }\n        AddressSet myBody=new AddressSet();\n        if (myFunc != null) {\n          myBody.add(myFunc.getBody());\n        }\n        AddressSet latestOnly=latestBody.subtract(myBody);\n        AddressSet myOnly=myBody.subtract(latestBody);\n        if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n          AddressSet conflictingMyEntries=new AddressSet();\n          conflictingMyEntries.add(latestOnly.intersect(addMy));\n          conflictingMyEntries.add(latestOnly.intersect(changeMy));\n          if (!conflictingMyEntries.isEmpty()) {\n            entryConflictSet.add(latestBody);\n            entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n          }\n          newEntries.add(conflictingMyEntries);\n        }\n        if (addMy.contains(entry) || changeMy.contains(entry)) {\n          AddressSet conflictingLatestEntries=new AddressSet();\n          conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n          conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n          if (!conflictingLatestEntries.isEmpty()) {\n            entryConflictSet.add(myBody);\n            entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n          }\n          newEntries.add(conflictingLatestEntries);\n        }\n        alreadyChecked.addRange(entry,entry);\n      }\n      checkEntries=newEntries.subtract(alreadyChecked);\n    }\n    if (!entryConflictSet.isEmpty()) {\n      overlapConflicts.put(changeEntry,entryConflictSet);\n      overlapConflictSet.addRange(changeEntry,changeEntry);\n      overlapAddressSet.add(entryConflictSet);\n    }\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 360,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 54,
        "startLineNumber" : 449,
        "startColumnNumber" : 6,
        "endLineNumber" : 449,
        "endColumnNumber" : 60
      },
      "nodeContext" : "conflictingMyEntries.add(latestOnly.intersect(addMy));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "ghidra.program.model.address.AddressSet"
  }, {
    "nodeContext" : "latestOnly",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 10,
      "startLineNumber" : 450,
      "startColumnNumber" : 31,
      "endLineNumber" : 450,
      "endColumnNumber" : 41
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 30,
        "startLineNumber" : 450,
        "startColumnNumber" : 31,
        "endLineNumber" : 450,
        "endColumnNumber" : 61
      },
      "nodeContext" : "latestOnly.intersect(changeMy)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 56,
        "startLineNumber" : 450,
        "startColumnNumber" : 6,
        "endLineNumber" : 450,
        "endColumnNumber" : 62
      },
      "nodeContext" : "conflictingMyEntries.add(latestOnly.intersect(changeMy))",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 450,
        "startColumnNumber" : 6,
        "endLineNumber" : 450,
        "endColumnNumber" : 63
      },
      "nodeContext" : "conflictingMyEntries.add(latestOnly.intersect(changeMy));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 600,
        "startLineNumber" : 446,
        "startColumnNumber" : 80,
        "endLineNumber" : 457,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  AddressSet conflictingMyEntries=new AddressSet();\n  conflictingMyEntries.add(latestOnly.intersect(addMy));\n  conflictingMyEntries.add(latestOnly.intersect(changeMy));\n  if (!conflictingMyEntries.isEmpty()) {\n    entryConflictSet.add(latestBody);\n    entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n  }\n  newEntries.add(conflictingMyEntries);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 51,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 675,
        "startLineNumber" : 446,
        "startColumnNumber" : 5,
        "endLineNumber" : 457,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n  AddressSet conflictingMyEntries=new AddressSet();\n  conflictingMyEntries.add(latestOnly.intersect(addMy));\n  conflictingMyEntries.add(latestOnly.intersect(changeMy));\n  if (!conflictingMyEntries.isEmpty()) {\n    entryConflictSet.add(latestBody);\n    entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n  }\n  newEntries.add(conflictingMyEntries);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 61,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 2089,
        "startLineNumber" : 431,
        "startColumnNumber" : 32,
        "endLineNumber" : 472,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  Address entry=entryIter.next();\n  Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n  Function myFunc=functionManagers[MY].getFunctionAt(entry);\n  AddressSet latestBody=new AddressSet();\n  if (latestFunc != null) {\n    latestBody.add(latestFunc.getBody());\n  }\n  AddressSet myBody=new AddressSet();\n  if (myFunc != null) {\n    myBody.add(myFunc.getBody());\n  }\n  AddressSet latestOnly=latestBody.subtract(myBody);\n  AddressSet myOnly=myBody.subtract(latestBody);\n  if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n    AddressSet conflictingMyEntries=new AddressSet();\n    conflictingMyEntries.add(latestOnly.intersect(addMy));\n    conflictingMyEntries.add(latestOnly.intersect(changeMy));\n    if (!conflictingMyEntries.isEmpty()) {\n      entryConflictSet.add(latestBody);\n      entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n    }\n    newEntries.add(conflictingMyEntries);\n  }\n  if (addMy.contains(entry) || changeMy.contains(entry)) {\n    AddressSet conflictingLatestEntries=new AddressSet();\n    conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n    conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n    if (!conflictingLatestEntries.isEmpty()) {\n      entryConflictSet.add(myBody);\n      entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n    }\n    newEntries.add(conflictingLatestEntries);\n  }\n  alreadyChecked.addRange(entry,entry);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 217,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2117,
        "startLineNumber" : 431,
        "startColumnNumber" : 4,
        "endLineNumber" : 472,
        "endColumnNumber" : 5
      },
      "nodeContext" : "while (entryIter.hasNext()) {\n  Address entry=entryIter.next();\n  Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n  Function myFunc=functionManagers[MY].getFunctionAt(entry);\n  AddressSet latestBody=new AddressSet();\n  if (latestFunc != null) {\n    latestBody.add(latestFunc.getBody());\n  }\n  AddressSet myBody=new AddressSet();\n  if (myFunc != null) {\n    myBody.add(myFunc.getBody());\n  }\n  AddressSet latestOnly=latestBody.subtract(myBody);\n  AddressSet myOnly=myBody.subtract(latestBody);\n  if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n    AddressSet conflictingMyEntries=new AddressSet();\n    conflictingMyEntries.add(latestOnly.intersect(addMy));\n    conflictingMyEntries.add(latestOnly.intersect(changeMy));\n    if (!conflictingMyEntries.isEmpty()) {\n      entryConflictSet.add(latestBody);\n      entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n    }\n    newEntries.add(conflictingMyEntries);\n  }\n  if (addMy.contains(entry) || changeMy.contains(entry)) {\n    AddressSet conflictingLatestEntries=new AddressSet();\n    conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n    conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n    if (!conflictingLatestEntries.isEmpty()) {\n      entryConflictSet.add(myBody);\n      entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n    }\n    newEntries.add(conflictingLatestEntries);\n  }\n  alreadyChecked.addRange(entry,entry);\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 221,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 2394,
        "startLineNumber" : 428,
        "startColumnNumber" : 35,
        "endLineNumber" : 475,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  AddressSet newEntries=new AddressSet();\n  AddressIterator entryIter=checkEntries.getAddresses(true);\n  while (entryIter.hasNext()) {\n    Address entry=entryIter.next();\n    Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n    Function myFunc=functionManagers[MY].getFunctionAt(entry);\n    AddressSet latestBody=new AddressSet();\n    if (latestFunc != null) {\n      latestBody.add(latestFunc.getBody());\n    }\n    AddressSet myBody=new AddressSet();\n    if (myFunc != null) {\n      myBody.add(myFunc.getBody());\n    }\n    AddressSet latestOnly=latestBody.subtract(myBody);\n    AddressSet myOnly=myBody.subtract(latestBody);\n    if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n      AddressSet conflictingMyEntries=new AddressSet();\n      conflictingMyEntries.add(latestOnly.intersect(addMy));\n      conflictingMyEntries.add(latestOnly.intersect(changeMy));\n      if (!conflictingMyEntries.isEmpty()) {\n        entryConflictSet.add(latestBody);\n        entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n      }\n      newEntries.add(conflictingMyEntries);\n    }\n    if (addMy.contains(entry) || changeMy.contains(entry)) {\n      AddressSet conflictingLatestEntries=new AddressSet();\n      conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n      conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n      if (!conflictingLatestEntries.isEmpty()) {\n        entryConflictSet.add(myBody);\n        entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n      }\n      newEntries.add(conflictingLatestEntries);\n    }\n    alreadyChecked.addRange(entry,entry);\n  }\n  checkEntries=newEntries.subtract(alreadyChecked);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 246,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2426,
        "startLineNumber" : 428,
        "startColumnNumber" : 3,
        "endLineNumber" : 475,
        "endColumnNumber" : 4
      },
      "nodeContext" : "while (!checkEntries.isEmpty()) {\n  AddressSet newEntries=new AddressSet();\n  AddressIterator entryIter=checkEntries.getAddresses(true);\n  while (entryIter.hasNext()) {\n    Address entry=entryIter.next();\n    Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n    Function myFunc=functionManagers[MY].getFunctionAt(entry);\n    AddressSet latestBody=new AddressSet();\n    if (latestFunc != null) {\n      latestBody.add(latestFunc.getBody());\n    }\n    AddressSet myBody=new AddressSet();\n    if (myFunc != null) {\n      myBody.add(myFunc.getBody());\n    }\n    AddressSet latestOnly=latestBody.subtract(myBody);\n    AddressSet myOnly=myBody.subtract(latestBody);\n    if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n      AddressSet conflictingMyEntries=new AddressSet();\n      conflictingMyEntries.add(latestOnly.intersect(addMy));\n      conflictingMyEntries.add(latestOnly.intersect(changeMy));\n      if (!conflictingMyEntries.isEmpty()) {\n        entryConflictSet.add(latestBody);\n        entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n      }\n      newEntries.add(conflictingMyEntries);\n    }\n    if (addMy.contains(entry) || changeMy.contains(entry)) {\n      AddressSet conflictingLatestEntries=new AddressSet();\n      conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n      conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n      if (!conflictingLatestEntries.isEmpty()) {\n        entryConflictSet.add(myBody);\n        entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n      }\n      newEntries.add(conflictingLatestEntries);\n    }\n    alreadyChecked.addRange(entry,entry);\n  }\n  checkEntries=newEntries.subtract(alreadyChecked);\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 251,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 3121,
        "startLineNumber" : 416,
        "startColumnNumber" : 25,
        "endLineNumber" : 482,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  monitor.checkCanceled();\n  Address changeEntry=iter.next();\n  if (overlapAddressSet.contains(changeEntry)) {\n    continue;\n  }\n  if (alreadyChecked.contains(changeEntry)) {\n    continue;\n  }\n  AddressSet entryConflictSet=new AddressSet();\n  AddressSet checkEntries=new AddressSet(changeEntry,changeEntry);\n  while (!checkEntries.isEmpty()) {\n    AddressSet newEntries=new AddressSet();\n    AddressIterator entryIter=checkEntries.getAddresses(true);\n    while (entryIter.hasNext()) {\n      Address entry=entryIter.next();\n      Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n      Function myFunc=functionManagers[MY].getFunctionAt(entry);\n      AddressSet latestBody=new AddressSet();\n      if (latestFunc != null) {\n        latestBody.add(latestFunc.getBody());\n      }\n      AddressSet myBody=new AddressSet();\n      if (myFunc != null) {\n        myBody.add(myFunc.getBody());\n      }\n      AddressSet latestOnly=latestBody.subtract(myBody);\n      AddressSet myOnly=myBody.subtract(latestBody);\n      if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n        AddressSet conflictingMyEntries=new AddressSet();\n        conflictingMyEntries.add(latestOnly.intersect(addMy));\n        conflictingMyEntries.add(latestOnly.intersect(changeMy));\n        if (!conflictingMyEntries.isEmpty()) {\n          entryConflictSet.add(latestBody);\n          entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n        }\n        newEntries.add(conflictingMyEntries);\n      }\n      if (addMy.contains(entry) || changeMy.contains(entry)) {\n        AddressSet conflictingLatestEntries=new AddressSet();\n        conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n        conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n        if (!conflictingLatestEntries.isEmpty()) {\n          entryConflictSet.add(myBody);\n          entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n        }\n        newEntries.add(conflictingLatestEntries);\n      }\n      alreadyChecked.addRange(entry,entry);\n    }\n    checkEntries=newEntries.subtract(alreadyChecked);\n  }\n  if (!entryConflictSet.isEmpty()) {\n    overlapConflicts.put(changeEntry,entryConflictSet);\n    overlapConflictSet.addRange(changeEntry,changeEntry);\n    overlapAddressSet.add(entryConflictSet);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 319,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3144,
        "startLineNumber" : 416,
        "startColumnNumber" : 2,
        "endLineNumber" : 482,
        "endColumnNumber" : 3
      },
      "nodeContext" : "while (iter.hasNext()) {\n  monitor.checkCanceled();\n  Address changeEntry=iter.next();\n  if (overlapAddressSet.contains(changeEntry)) {\n    continue;\n  }\n  if (alreadyChecked.contains(changeEntry)) {\n    continue;\n  }\n  AddressSet entryConflictSet=new AddressSet();\n  AddressSet checkEntries=new AddressSet(changeEntry,changeEntry);\n  while (!checkEntries.isEmpty()) {\n    AddressSet newEntries=new AddressSet();\n    AddressIterator entryIter=checkEntries.getAddresses(true);\n    while (entryIter.hasNext()) {\n      Address entry=entryIter.next();\n      Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n      Function myFunc=functionManagers[MY].getFunctionAt(entry);\n      AddressSet latestBody=new AddressSet();\n      if (latestFunc != null) {\n        latestBody.add(latestFunc.getBody());\n      }\n      AddressSet myBody=new AddressSet();\n      if (myFunc != null) {\n        myBody.add(myFunc.getBody());\n      }\n      AddressSet latestOnly=latestBody.subtract(myBody);\n      AddressSet myOnly=myBody.subtract(latestBody);\n      if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n        AddressSet conflictingMyEntries=new AddressSet();\n        conflictingMyEntries.add(latestOnly.intersect(addMy));\n        conflictingMyEntries.add(latestOnly.intersect(changeMy));\n        if (!conflictingMyEntries.isEmpty()) {\n          entryConflictSet.add(latestBody);\n          entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n        }\n        newEntries.add(conflictingMyEntries);\n      }\n      if (addMy.contains(entry) || changeMy.contains(entry)) {\n        AddressSet conflictingLatestEntries=new AddressSet();\n        conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n        conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n        if (!conflictingLatestEntries.isEmpty()) {\n          entryConflictSet.add(myBody);\n          entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n        }\n        newEntries.add(conflictingLatestEntries);\n      }\n      alreadyChecked.addRange(entry,entry);\n    }\n    checkEntries=newEntries.subtract(alreadyChecked);\n  }\n  if (!entryConflictSet.isEmpty()) {\n    overlapConflicts.put(changeEntry,entryConflictSet);\n    overlapConflictSet.addRange(changeEntry,changeEntry);\n    overlapAddressSet.add(entryConflictSet);\n  }\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 323,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3361,
        "startLineNumber" : 411,
        "startColumnNumber" : 29,
        "endLineNumber" : 483,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  monitor.checkCanceled();\n  AddressSet alreadyChecked=new AddressSet();\n  AddressIterator iter=changeSet.getAddresses(true);\n  while (iter.hasNext()) {\n    monitor.checkCanceled();\n    Address changeEntry=iter.next();\n    if (overlapAddressSet.contains(changeEntry)) {\n      continue;\n    }\n    if (alreadyChecked.contains(changeEntry)) {\n      continue;\n    }\n    AddressSet entryConflictSet=new AddressSet();\n    AddressSet checkEntries=new AddressSet(changeEntry,changeEntry);\n    while (!checkEntries.isEmpty()) {\n      AddressSet newEntries=new AddressSet();\n      AddressIterator entryIter=checkEntries.getAddresses(true);\n      while (entryIter.hasNext()) {\n        Address entry=entryIter.next();\n        Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n        Function myFunc=functionManagers[MY].getFunctionAt(entry);\n        AddressSet latestBody=new AddressSet();\n        if (latestFunc != null) {\n          latestBody.add(latestFunc.getBody());\n        }\n        AddressSet myBody=new AddressSet();\n        if (myFunc != null) {\n          myBody.add(myFunc.getBody());\n        }\n        AddressSet latestOnly=latestBody.subtract(myBody);\n        AddressSet myOnly=myBody.subtract(latestBody);\n        if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n          AddressSet conflictingMyEntries=new AddressSet();\n          conflictingMyEntries.add(latestOnly.intersect(addMy));\n          conflictingMyEntries.add(latestOnly.intersect(changeMy));\n          if (!conflictingMyEntries.isEmpty()) {\n            entryConflictSet.add(latestBody);\n            entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n          }\n          newEntries.add(conflictingMyEntries);\n        }\n        if (addMy.contains(entry) || changeMy.contains(entry)) {\n          AddressSet conflictingLatestEntries=new AddressSet();\n          conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n          conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n          if (!conflictingLatestEntries.isEmpty()) {\n            entryConflictSet.add(myBody);\n            entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n          }\n          newEntries.add(conflictingLatestEntries);\n        }\n        alreadyChecked.addRange(entry,entry);\n      }\n      checkEntries=newEntries.subtract(alreadyChecked);\n    }\n    if (!entryConflictSet.isEmpty()) {\n      overlapConflicts.put(changeEntry,entryConflictSet);\n      overlapConflictSet.addRange(changeEntry,changeEntry);\n      overlapAddressSet.add(entryConflictSet);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 345,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3633,
        "startLineNumber" : 404,
        "startColumnNumber" : 1,
        "endLineNumber" : 483,
        "endColumnNumber" : 2
      },
      "nodeContext" : "/** \n * @param changeSet address set indicating where either Latest or My changed a function.\n * @param monitor\n * @throws CancelledException\n */\nprivate void determineOverlapConflicts(AddressSet changeSet,TaskMonitor monitor) throws CancelledException {\n  monitor.checkCanceled();\n  AddressSet alreadyChecked=new AddressSet();\n  AddressIterator iter=changeSet.getAddresses(true);\n  while (iter.hasNext()) {\n    monitor.checkCanceled();\n    Address changeEntry=iter.next();\n    if (overlapAddressSet.contains(changeEntry)) {\n      continue;\n    }\n    if (alreadyChecked.contains(changeEntry)) {\n      continue;\n    }\n    AddressSet entryConflictSet=new AddressSet();\n    AddressSet checkEntries=new AddressSet(changeEntry,changeEntry);\n    while (!checkEntries.isEmpty()) {\n      AddressSet newEntries=new AddressSet();\n      AddressIterator entryIter=checkEntries.getAddresses(true);\n      while (entryIter.hasNext()) {\n        Address entry=entryIter.next();\n        Function latestFunc=functionManagers[LATEST].getFunctionAt(entry);\n        Function myFunc=functionManagers[MY].getFunctionAt(entry);\n        AddressSet latestBody=new AddressSet();\n        if (latestFunc != null) {\n          latestBody.add(latestFunc.getBody());\n        }\n        AddressSet myBody=new AddressSet();\n        if (myFunc != null) {\n          myBody.add(myFunc.getBody());\n        }\n        AddressSet latestOnly=latestBody.subtract(myBody);\n        AddressSet myOnly=myBody.subtract(latestBody);\n        if (addEntireLatest.contains(entry) || changeEntireLatest.contains(entry)) {\n          AddressSet conflictingMyEntries=new AddressSet();\n          conflictingMyEntries.add(latestOnly.intersect(addMy));\n          conflictingMyEntries.add(latestOnly.intersect(changeMy));\n          if (!conflictingMyEntries.isEmpty()) {\n            entryConflictSet.add(latestBody);\n            entryConflictSet.add(getBodies(functionManagers[MY],conflictingMyEntries));\n          }\n          newEntries.add(conflictingMyEntries);\n        }\n        if (addMy.contains(entry) || changeMy.contains(entry)) {\n          AddressSet conflictingLatestEntries=new AddressSet();\n          conflictingLatestEntries.add(myOnly.intersect(addEntireLatest));\n          conflictingLatestEntries.add(myOnly.intersect(changeEntireLatest));\n          if (!conflictingLatestEntries.isEmpty()) {\n            entryConflictSet.add(myBody);\n            entryConflictSet.add(getBodies(functionManagers[LATEST],conflictingLatestEntries));\n          }\n          newEntries.add(conflictingLatestEntries);\n        }\n        alreadyChecked.addRange(entry,entry);\n      }\n      checkEntries=newEntries.subtract(alreadyChecked);\n    }\n    if (!entryConflictSet.isEmpty()) {\n      overlapConflicts.put(changeEntry,entryConflictSet);\n      overlapConflictSet.addRange(changeEntry,changeEntry);\n      overlapAddressSet.add(entryConflictSet);\n    }\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 360,
      "astHeight" : 17
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 57,
        "startLineNumber" : 450,
        "startColumnNumber" : 6,
        "endLineNumber" : 450,
        "endColumnNumber" : 63
      },
      "nodeContext" : "conflictingMyEntries.add(latestOnly.intersect(changeMy));\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 8,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "ghidra.program.model.address.AddressSet"
  } ],
  "positionList" : [ {
    "charLength" : 10,
    "startLineNumber" : 449,
    "startColumnNumber" : 31,
    "endLineNumber" : 449,
    "endColumnNumber" : 41
  }, {
    "charLength" : 10,
    "startLineNumber" : 450,
    "startColumnNumber" : 31,
    "endLineNumber" : 450,
    "endColumnNumber" : 41
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 3
  } ]
}