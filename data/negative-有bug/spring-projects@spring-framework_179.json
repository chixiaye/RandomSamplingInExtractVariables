{
  "id" : 179,
  "expression" : "transportType == null",
  "projectName" : "spring-projects@spring-framework",
  "commitID" : "d5dab129097f98ed3148473422eb706c20fd10c9",
  "filePath" : "/spring-websocket/src/main/java/org/springframework/web/socket/sockjs/transport/TransportHandlingSockJsService.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "transportType == null",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 21,
      "startLineNumber" : 233,
      "startColumnNumber" : 6,
      "endLineNumber" : 233,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 197,
        "startLineNumber" : 233,
        "startColumnNumber" : 2,
        "endLineNumber" : 239,
        "endColumnNumber" : 3
      },
      "nodeContext" : "if (transportType == null) {\n  if (logger.isWarnEnabled()) {\n    logger.warn(\"Unknown transport type for \" + request.getURI());\n  }\n  response.setStatusCode(HttpStatus.NOT_FOUND);\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 27,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3176,
        "startLineNumber" : 230,
        "startColumnNumber" : 88,
        "endLineNumber" : 327,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  TransportType transportType=TransportType.fromValue(transport);\n  if (transportType == null) {\n    if (logger.isWarnEnabled()) {\n      logger.warn(\"Unknown transport type for \" + request.getURI());\n    }\n    response.setStatusCode(HttpStatus.NOT_FOUND);\n    return;\n  }\n  TransportHandler transportHandler=this.handlers.get(transportType);\n  if (transportHandler == null) {\n    if (logger.isWarnEnabled()) {\n      logger.warn(\"No TransportHandler for \" + request.getURI());\n    }\n    response.setStatusCode(HttpStatus.NOT_FOUND);\n    return;\n  }\n  SockJsException failure=null;\n  HandshakeInterceptorChain chain=new HandshakeInterceptorChain(this.interceptors,handler);\n  try {\n    HttpMethod supportedMethod=transportType.getHttpMethod();\n    if (supportedMethod != request.getMethod()) {\n      if (request.getMethod() == HttpMethod.OPTIONS && transportType.supportsCors()) {\n        if (checkOrigin(request,response,HttpMethod.OPTIONS,supportedMethod)) {\n          response.setStatusCode(HttpStatus.NO_CONTENT);\n          addCacheHeaders(response);\n        }\n      }\n else       if (transportType.supportsCors()) {\n        sendMethodNotAllowed(response,supportedMethod,HttpMethod.OPTIONS);\n      }\n else {\n        sendMethodNotAllowed(response,supportedMethod);\n      }\n      return;\n    }\n    SockJsSession session=this.sessions.get(sessionId);\n    if (session == null) {\n      if (transportHandler instanceof SockJsSessionFactory) {\n        Map<String,Object> attributes=new HashMap<>();\n        if (!chain.applyBeforeHandshake(request,response,attributes)) {\n          return;\n        }\n        SockJsSessionFactory sessionFactory=(SockJsSessionFactory)transportHandler;\n        session=createSockJsSession(sessionId,sessionFactory,handler,attributes);\n      }\n else {\n        response.setStatusCode(HttpStatus.NOT_FOUND);\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Session not found, sessionId=\" + sessionId + \". The session may have been closed \"+ \"(e.g. missed heart-beat) while a message was coming in.\");\n        }\n        return;\n      }\n    }\n else {\n      Principal principal=session.getPrincipal();\n      if (principal != null && !principal.equals(request.getPrincipal())) {\n        logger.debug(\"The user for the session does not match the user for the request.\");\n        response.setStatusCode(HttpStatus.NOT_FOUND);\n        return;\n      }\n      if (!transportHandler.checkSessionType(session)) {\n        logger.debug(\"Session type does not match the transport type for the request.\");\n        response.setStatusCode(HttpStatus.NOT_FOUND);\n        return;\n      }\n    }\n    if (transportType.sendsNoCacheInstruction()) {\n      addNoCacheHeaders(response);\n    }\n    if (transportType.supportsCors() && !checkOrigin(request,response)) {\n      return;\n    }\n    transportHandler.handleRequest(request,response,handler,session);\n    chain.applyAfterHandshake(request,response,null);\n  }\n catch (  SockJsException ex) {\n    failure=ex;\n  }\ncatch (  Throwable ex) {\n    failure=new SockJsException(\"Uncaught failure for request \" + request.getURI(),sessionId,ex);\n  }\n finally {\n    if (failure != null) {\n      chain.applyAfterHandshake(request,response,failure);\n      throw failure;\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 386,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3369,
        "startLineNumber" : 228,
        "startColumnNumber" : 1,
        "endLineNumber" : 327,
        "endColumnNumber" : 2
      },
      "nodeContext" : "@Override protected void handleTransportRequest(ServerHttpRequest request,ServerHttpResponse response,WebSocketHandler handler,String sessionId,String transport) throws SockJsException {\n  TransportType transportType=TransportType.fromValue(transport);\n  if (transportType == null) {\n    if (logger.isWarnEnabled()) {\n      logger.warn(\"Unknown transport type for \" + request.getURI());\n    }\n    response.setStatusCode(HttpStatus.NOT_FOUND);\n    return;\n  }\n  TransportHandler transportHandler=this.handlers.get(transportType);\n  if (transportHandler == null) {\n    if (logger.isWarnEnabled()) {\n      logger.warn(\"No TransportHandler for \" + request.getURI());\n    }\n    response.setStatusCode(HttpStatus.NOT_FOUND);\n    return;\n  }\n  SockJsException failure=null;\n  HandshakeInterceptorChain chain=new HandshakeInterceptorChain(this.interceptors,handler);\n  try {\n    HttpMethod supportedMethod=transportType.getHttpMethod();\n    if (supportedMethod != request.getMethod()) {\n      if (request.getMethod() == HttpMethod.OPTIONS && transportType.supportsCors()) {\n        if (checkOrigin(request,response,HttpMethod.OPTIONS,supportedMethod)) {\n          response.setStatusCode(HttpStatus.NO_CONTENT);\n          addCacheHeaders(response);\n        }\n      }\n else       if (transportType.supportsCors()) {\n        sendMethodNotAllowed(response,supportedMethod,HttpMethod.OPTIONS);\n      }\n else {\n        sendMethodNotAllowed(response,supportedMethod);\n      }\n      return;\n    }\n    SockJsSession session=this.sessions.get(sessionId);\n    if (session == null) {\n      if (transportHandler instanceof SockJsSessionFactory) {\n        Map<String,Object> attributes=new HashMap<>();\n        if (!chain.applyBeforeHandshake(request,response,attributes)) {\n          return;\n        }\n        SockJsSessionFactory sessionFactory=(SockJsSessionFactory)transportHandler;\n        session=createSockJsSession(sessionId,sessionFactory,handler,attributes);\n      }\n else {\n        response.setStatusCode(HttpStatus.NOT_FOUND);\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Session not found, sessionId=\" + sessionId + \". The session may have been closed \"+ \"(e.g. missed heart-beat) while a message was coming in.\");\n        }\n        return;\n      }\n    }\n else {\n      Principal principal=session.getPrincipal();\n      if (principal != null && !principal.equals(request.getPrincipal())) {\n        logger.debug(\"The user for the session does not match the user for the request.\");\n        response.setStatusCode(HttpStatus.NOT_FOUND);\n        return;\n      }\n      if (!transportHandler.checkSessionType(session)) {\n        logger.debug(\"Session type does not match the transport type for the request.\");\n        response.setStatusCode(HttpStatus.NOT_FOUND);\n        return;\n      }\n    }\n    if (transportType.sendsNoCacheInstruction()) {\n      addNoCacheHeaders(response);\n    }\n    if (transportType.supportsCors() && !checkOrigin(request,response)) {\n      return;\n    }\n    transportHandler.handleRequest(request,response,handler,session);\n    chain.applyAfterHandshake(request,response,null);\n  }\n catch (  SockJsException ex) {\n    failure=ex;\n  }\ncatch (  Throwable ex) {\n    failure=new SockJsException(\"Uncaught failure for request \" + request.getURI(),sessionId,ex);\n  }\n finally {\n    if (failure != null) {\n      chain.applyAfterHandshake(request,response,failure);\n      throw failure;\n    }\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 414,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 197,
        "startLineNumber" : 233,
        "startColumnNumber" : 2,
        "endLineNumber" : 239,
        "endColumnNumber" : 3
      },
      "nodeContext" : "if (transportType == null) {\n  if (logger.isWarnEnabled()) {\n    logger.warn(\"Unknown transport type for \" + request.getURI());\n  }\n  response.setStatusCode(HttpStatus.NOT_FOUND);\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 27,
      "astHeight" : 9
    },
    "tokenLength" : 3,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 21,
    "startLineNumber" : 233,
    "startColumnNumber" : 6,
    "endLineNumber" : 233,
    "endColumnNumber" : 27
  } ],
  "layoutRelationDataList" : [ ]
}