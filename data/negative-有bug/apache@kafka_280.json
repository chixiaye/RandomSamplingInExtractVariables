{
  "id" : 280,
  "expression" : "FinalState.SUCCEEDED",
  "projectName" : "apache@kafka",
  "commitID" : "539f006e65d9060cd46a4052d1b70f2312d8ca34",
  "filePath" : "/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerBatch.java",
  "occurrences" : 4,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "FinalState.SUCCEEDED",
    "nodeType" : "QualifiedName",
    "nodePosition" : {
      "charLength" : 20,
      "startLineNumber" : 226,
      "startColumnNumber" : 71,
      "endLineNumber" : 226,
      "endColumnNumber" : 91
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 70,
        "startLineNumber" : 226,
        "startColumnNumber" : 41,
        "endLineNumber" : 226,
        "endColumnNumber" : 111
      },
      "nodeContext" : "(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 86,
        "startLineNumber" : 226,
        "startColumnNumber" : 25,
        "endLineNumber" : 226,
        "endColumnNumber" : 111
      },
      "nodeContext" : "tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 104,
        "startLineNumber" : 226,
        "startColumnNumber" : 8,
        "endLineNumber" : 226,
        "endColumnNumber" : 112
      },
      "nodeContext" : "final FinalState tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 1600,
        "startLineNumber" : 225,
        "startColumnNumber" : 6,
        "endLineNumber" : 253,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  final FinalState tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED;\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.trace(\"Successfully produced messages to {} with base offset {}.\",topicPartition,baseOffset);\n  }\n else {\n    log.trace(\"Failed to produce messages to {} with base offset {}.\",topicPartition,baseOffset,topLevelException);\n  }\n  if (this.finalState.compareAndSet(null,tryFinalState)) {\n    completeFutureAndFireCallbacks(baseOffset,logAppendTime,recordExceptions);\n    return true;\n  }\n  if (this.finalState.get() != FinalState.SUCCEEDED) {\n    if (tryFinalState == FinalState.SUCCEEDED) {\n      log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n    }\n else {\n      log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n    }\n  }\n else {\n    throw new IllegalStateException(\"A \" + this.finalState.get() + \" batch must not attempt another state change to \"+ tryFinalState);\n  }\n  return false;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 119,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3164,
        "startLineNumber" : 201,
        "startColumnNumber" : 4,
        "endLineNumber" : 253,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Finalize the state of a batch. Final state, once set, is immutable. This function may be called once or twice on a batch. It may be called twice if 1. An inflight batch expires before a response from the broker is received. The batch's final state is set to FAILED. But it could succeed on the broker and second time around batch.done() may try to set SUCCEEDED final state. 2. If a transaction abortion happens or if the producer is closed forcefully, the final state is ABORTED but again it could succeed if broker responds with a success. Attempted transitions from [FAILED | ABORTED] --> SUCCEEDED are logged. Attempted transitions from one failure state to the same or a different failed state are ignored. Attempted transitions from SUCCEEDED to the same or a failed state throw an exception.\n * @param baseOffset The base offset of the messages assigned by the server\n * @param logAppendTime The log append time or -1 if CreateTime is being used\n * @param topLevelException The exception that occurred (or null if the request was successful)\n * @param recordExceptions Record exception function mapping batchIndex to the respective record exception\n * @return true if the batch was completed successfully and false if the batch was previously aborted\n */\nprivate boolean done(long baseOffset,long logAppendTime,RuntimeException topLevelException,Function<Integer,RuntimeException> recordExceptions){\n  final FinalState tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED;\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.trace(\"Successfully produced messages to {} with base offset {}.\",topicPartition,baseOffset);\n  }\n else {\n    log.trace(\"Failed to produce messages to {} with base offset {}.\",topicPartition,baseOffset,topLevelException);\n  }\n  if (this.finalState.compareAndSet(null,tryFinalState)) {\n    completeFutureAndFireCallbacks(baseOffset,logAppendTime,recordExceptions);\n    return true;\n  }\n  if (this.finalState.get() != FinalState.SUCCEEDED) {\n    if (tryFinalState == FinalState.SUCCEEDED) {\n      log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n    }\n else {\n      log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n    }\n  }\n else {\n    throw new IllegalStateException(\"A \" + this.finalState.get() + \" batch must not attempt another state change to \"+ tryFinalState);\n  }\n  return false;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 143,
      "astHeight" : 11
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 104,
        "startLineNumber" : 226,
        "startColumnNumber" : 8,
        "endLineNumber" : 226,
        "endColumnNumber" : 112
      },
      "nodeContext" : "final FinalState tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED;\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 17,
      "astHeight" : 6
    },
    "tokenLength" : 2,
    "type" : "org.apache.kafka.clients.producer.internals.ProducerBatch.FinalState"
  }, {
    "nodeContext" : "FinalState.SUCCEEDED",
    "nodeType" : "QualifiedName",
    "nodePosition" : {
      "charLength" : 20,
      "startLineNumber" : 227,
      "startColumnNumber" : 29,
      "endLineNumber" : 227,
      "endColumnNumber" : 49
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 227,
        "startColumnNumber" : 12,
        "endLineNumber" : 227,
        "endColumnNumber" : 49
      },
      "nodeContext" : "tryFinalState == FinalState.SUCCEEDED",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 310,
        "startLineNumber" : 227,
        "startColumnNumber" : 8,
        "endLineNumber" : 231,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (tryFinalState == FinalState.SUCCEEDED) {\n  log.trace(\"Successfully produced messages to {} with base offset {}.\",topicPartition,baseOffset);\n}\n else {\n  log.trace(\"Failed to produce messages to {} with base offset {}.\",topicPartition,baseOffset,topLevelException);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 23,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 1600,
        "startLineNumber" : 225,
        "startColumnNumber" : 6,
        "endLineNumber" : 253,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  final FinalState tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED;\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.trace(\"Successfully produced messages to {} with base offset {}.\",topicPartition,baseOffset);\n  }\n else {\n    log.trace(\"Failed to produce messages to {} with base offset {}.\",topicPartition,baseOffset,topLevelException);\n  }\n  if (this.finalState.compareAndSet(null,tryFinalState)) {\n    completeFutureAndFireCallbacks(baseOffset,logAppendTime,recordExceptions);\n    return true;\n  }\n  if (this.finalState.get() != FinalState.SUCCEEDED) {\n    if (tryFinalState == FinalState.SUCCEEDED) {\n      log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n    }\n else {\n      log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n    }\n  }\n else {\n    throw new IllegalStateException(\"A \" + this.finalState.get() + \" batch must not attempt another state change to \"+ tryFinalState);\n  }\n  return false;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 119,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3164,
        "startLineNumber" : 201,
        "startColumnNumber" : 4,
        "endLineNumber" : 253,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Finalize the state of a batch. Final state, once set, is immutable. This function may be called once or twice on a batch. It may be called twice if 1. An inflight batch expires before a response from the broker is received. The batch's final state is set to FAILED. But it could succeed on the broker and second time around batch.done() may try to set SUCCEEDED final state. 2. If a transaction abortion happens or if the producer is closed forcefully, the final state is ABORTED but again it could succeed if broker responds with a success. Attempted transitions from [FAILED | ABORTED] --> SUCCEEDED are logged. Attempted transitions from one failure state to the same or a different failed state are ignored. Attempted transitions from SUCCEEDED to the same or a failed state throw an exception.\n * @param baseOffset The base offset of the messages assigned by the server\n * @param logAppendTime The log append time or -1 if CreateTime is being used\n * @param topLevelException The exception that occurred (or null if the request was successful)\n * @param recordExceptions Record exception function mapping batchIndex to the respective record exception\n * @return true if the batch was completed successfully and false if the batch was previously aborted\n */\nprivate boolean done(long baseOffset,long logAppendTime,RuntimeException topLevelException,Function<Integer,RuntimeException> recordExceptions){\n  final FinalState tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED;\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.trace(\"Successfully produced messages to {} with base offset {}.\",topicPartition,baseOffset);\n  }\n else {\n    log.trace(\"Failed to produce messages to {} with base offset {}.\",topicPartition,baseOffset,topLevelException);\n  }\n  if (this.finalState.compareAndSet(null,tryFinalState)) {\n    completeFutureAndFireCallbacks(baseOffset,logAppendTime,recordExceptions);\n    return true;\n  }\n  if (this.finalState.get() != FinalState.SUCCEEDED) {\n    if (tryFinalState == FinalState.SUCCEEDED) {\n      log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n    }\n else {\n      log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n    }\n  }\n else {\n    throw new IllegalStateException(\"A \" + this.finalState.get() + \" batch must not attempt another state change to \"+ tryFinalState);\n  }\n  return false;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 143,
      "astHeight" : 11
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 227,
        "startColumnNumber" : 12,
        "endLineNumber" : 227,
        "endColumnNumber" : 49
      },
      "nodeContext" : "tryFinalState == FinalState.SUCCEEDED",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 2,
    "type" : "org.apache.kafka.clients.producer.internals.ProducerBatch.FinalState"
  }, {
    "nodeContext" : "FinalState.SUCCEEDED",
    "nodeType" : "QualifiedName",
    "nodePosition" : {
      "charLength" : 20,
      "startLineNumber" : 238,
      "startColumnNumber" : 37,
      "endLineNumber" : 238,
      "endColumnNumber" : 57
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 238,
        "startColumnNumber" : 12,
        "endLineNumber" : 238,
        "endColumnNumber" : 57
      },
      "nodeContext" : "this.finalState.get() != FinalState.SUCCEEDED",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 938,
        "startLineNumber" : 238,
        "startColumnNumber" : 8,
        "endLineNumber" : 251,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (this.finalState.get() != FinalState.SUCCEEDED) {\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n  }\n else {\n    log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n  }\n}\n else {\n  throw new IllegalStateException(\"A \" + this.finalState.get() + \" batch must not attempt another state change to \"+ tryFinalState);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 59,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 1600,
        "startLineNumber" : 225,
        "startColumnNumber" : 6,
        "endLineNumber" : 253,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  final FinalState tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED;\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.trace(\"Successfully produced messages to {} with base offset {}.\",topicPartition,baseOffset);\n  }\n else {\n    log.trace(\"Failed to produce messages to {} with base offset {}.\",topicPartition,baseOffset,topLevelException);\n  }\n  if (this.finalState.compareAndSet(null,tryFinalState)) {\n    completeFutureAndFireCallbacks(baseOffset,logAppendTime,recordExceptions);\n    return true;\n  }\n  if (this.finalState.get() != FinalState.SUCCEEDED) {\n    if (tryFinalState == FinalState.SUCCEEDED) {\n      log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n    }\n else {\n      log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n    }\n  }\n else {\n    throw new IllegalStateException(\"A \" + this.finalState.get() + \" batch must not attempt another state change to \"+ tryFinalState);\n  }\n  return false;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 119,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3164,
        "startLineNumber" : 201,
        "startColumnNumber" : 4,
        "endLineNumber" : 253,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Finalize the state of a batch. Final state, once set, is immutable. This function may be called once or twice on a batch. It may be called twice if 1. An inflight batch expires before a response from the broker is received. The batch's final state is set to FAILED. But it could succeed on the broker and second time around batch.done() may try to set SUCCEEDED final state. 2. If a transaction abortion happens or if the producer is closed forcefully, the final state is ABORTED but again it could succeed if broker responds with a success. Attempted transitions from [FAILED | ABORTED] --> SUCCEEDED are logged. Attempted transitions from one failure state to the same or a different failed state are ignored. Attempted transitions from SUCCEEDED to the same or a failed state throw an exception.\n * @param baseOffset The base offset of the messages assigned by the server\n * @param logAppendTime The log append time or -1 if CreateTime is being used\n * @param topLevelException The exception that occurred (or null if the request was successful)\n * @param recordExceptions Record exception function mapping batchIndex to the respective record exception\n * @return true if the batch was completed successfully and false if the batch was previously aborted\n */\nprivate boolean done(long baseOffset,long logAppendTime,RuntimeException topLevelException,Function<Integer,RuntimeException> recordExceptions){\n  final FinalState tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED;\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.trace(\"Successfully produced messages to {} with base offset {}.\",topicPartition,baseOffset);\n  }\n else {\n    log.trace(\"Failed to produce messages to {} with base offset {}.\",topicPartition,baseOffset,topLevelException);\n  }\n  if (this.finalState.compareAndSet(null,tryFinalState)) {\n    completeFutureAndFireCallbacks(baseOffset,logAppendTime,recordExceptions);\n    return true;\n  }\n  if (this.finalState.get() != FinalState.SUCCEEDED) {\n    if (tryFinalState == FinalState.SUCCEEDED) {\n      log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n    }\n else {\n      log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n    }\n  }\n else {\n    throw new IllegalStateException(\"A \" + this.finalState.get() + \" batch must not attempt another state change to \"+ tryFinalState);\n  }\n  return false;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 143,
      "astHeight" : 11
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 45,
        "startLineNumber" : 238,
        "startColumnNumber" : 12,
        "endLineNumber" : 238,
        "endColumnNumber" : 57
      },
      "nodeContext" : "this.finalState.get() != FinalState.SUCCEEDED",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 2,
    "type" : "org.apache.kafka.clients.producer.internals.ProducerBatch.FinalState"
  }, {
    "nodeContext" : "FinalState.SUCCEEDED",
    "nodeType" : "QualifiedName",
    "nodePosition" : {
      "charLength" : 20,
      "startLineNumber" : 239,
      "startColumnNumber" : 33,
      "endLineNumber" : 239,
      "endColumnNumber" : 53
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 239,
        "startColumnNumber" : 16,
        "endLineNumber" : 239,
        "endColumnNumber" : 53
      },
      "nodeContext" : "tryFinalState == FinalState.SUCCEEDED",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 629,
        "startLineNumber" : 239,
        "startColumnNumber" : 12,
        "endLineNumber" : 247,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (tryFinalState == FinalState.SUCCEEDED) {\n  log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n}\n else {\n  log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 34,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 653,
        "startLineNumber" : 238,
        "startColumnNumber" : 59,
        "endLineNumber" : 248,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n  }\n else {\n    log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 35,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 938,
        "startLineNumber" : 238,
        "startColumnNumber" : 8,
        "endLineNumber" : 251,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (this.finalState.get() != FinalState.SUCCEEDED) {\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n  }\n else {\n    log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n  }\n}\n else {\n  throw new IllegalStateException(\"A \" + this.finalState.get() + \" batch must not attempt another state change to \"+ tryFinalState);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 59,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 1600,
        "startLineNumber" : 225,
        "startColumnNumber" : 6,
        "endLineNumber" : 253,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  final FinalState tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED;\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.trace(\"Successfully produced messages to {} with base offset {}.\",topicPartition,baseOffset);\n  }\n else {\n    log.trace(\"Failed to produce messages to {} with base offset {}.\",topicPartition,baseOffset,topLevelException);\n  }\n  if (this.finalState.compareAndSet(null,tryFinalState)) {\n    completeFutureAndFireCallbacks(baseOffset,logAppendTime,recordExceptions);\n    return true;\n  }\n  if (this.finalState.get() != FinalState.SUCCEEDED) {\n    if (tryFinalState == FinalState.SUCCEEDED) {\n      log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n    }\n else {\n      log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n    }\n  }\n else {\n    throw new IllegalStateException(\"A \" + this.finalState.get() + \" batch must not attempt another state change to \"+ tryFinalState);\n  }\n  return false;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 119,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3164,
        "startLineNumber" : 201,
        "startColumnNumber" : 4,
        "endLineNumber" : 253,
        "endColumnNumber" : 5
      },
      "nodeContext" : "/** \n * Finalize the state of a batch. Final state, once set, is immutable. This function may be called once or twice on a batch. It may be called twice if 1. An inflight batch expires before a response from the broker is received. The batch's final state is set to FAILED. But it could succeed on the broker and second time around batch.done() may try to set SUCCEEDED final state. 2. If a transaction abortion happens or if the producer is closed forcefully, the final state is ABORTED but again it could succeed if broker responds with a success. Attempted transitions from [FAILED | ABORTED] --> SUCCEEDED are logged. Attempted transitions from one failure state to the same or a different failed state are ignored. Attempted transitions from SUCCEEDED to the same or a failed state throw an exception.\n * @param baseOffset The base offset of the messages assigned by the server\n * @param logAppendTime The log append time or -1 if CreateTime is being used\n * @param topLevelException The exception that occurred (or null if the request was successful)\n * @param recordExceptions Record exception function mapping batchIndex to the respective record exception\n * @return true if the batch was completed successfully and false if the batch was previously aborted\n */\nprivate boolean done(long baseOffset,long logAppendTime,RuntimeException topLevelException,Function<Integer,RuntimeException> recordExceptions){\n  final FinalState tryFinalState=(topLevelException == null) ? FinalState.SUCCEEDED : FinalState.FAILED;\n  if (tryFinalState == FinalState.SUCCEEDED) {\n    log.trace(\"Successfully produced messages to {} with base offset {}.\",topicPartition,baseOffset);\n  }\n else {\n    log.trace(\"Failed to produce messages to {} with base offset {}.\",topicPartition,baseOffset,topLevelException);\n  }\n  if (this.finalState.compareAndSet(null,tryFinalState)) {\n    completeFutureAndFireCallbacks(baseOffset,logAppendTime,recordExceptions);\n    return true;\n  }\n  if (this.finalState.get() != FinalState.SUCCEEDED) {\n    if (tryFinalState == FinalState.SUCCEEDED) {\n      log.debug(\"ProduceResponse returned {} for {} after batch with base offset {} had already been {}.\",tryFinalState,topicPartition,baseOffset,this.finalState.get());\n    }\n else {\n      log.debug(\"Ignored state transition {} -> {} for {} batch with base offset {}\",this.finalState.get(),tryFinalState,topicPartition,baseOffset);\n    }\n  }\n else {\n    throw new IllegalStateException(\"A \" + this.finalState.get() + \" batch must not attempt another state change to \"+ tryFinalState);\n  }\n  return false;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 143,
      "astHeight" : 11
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 37,
        "startLineNumber" : 239,
        "startColumnNumber" : 16,
        "endLineNumber" : 239,
        "endColumnNumber" : 53
      },
      "nodeContext" : "tryFinalState == FinalState.SUCCEEDED",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 2,
    "type" : "org.apache.kafka.clients.producer.internals.ProducerBatch.FinalState"
  } ],
  "positionList" : [ {
    "charLength" : 20,
    "startLineNumber" : 226,
    "startColumnNumber" : 71,
    "endLineNumber" : 226,
    "endColumnNumber" : 91
  }, {
    "charLength" : 20,
    "startLineNumber" : 227,
    "startColumnNumber" : 29,
    "endLineNumber" : 227,
    "endColumnNumber" : 49
  }, {
    "charLength" : 20,
    "startLineNumber" : 238,
    "startColumnNumber" : 37,
    "endLineNumber" : 238,
    "endColumnNumber" : 57
  }, {
    "charLength" : 20,
    "startLineNumber" : 239,
    "startColumnNumber" : 33,
    "endLineNumber" : 239,
    "endColumnNumber" : 53
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 2
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 2
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 1
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 3
  } ]
}