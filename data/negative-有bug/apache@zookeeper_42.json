{
  "id" : 42,
  "expression" : "\"    try {\\n\"",
  "projectName" : "apache@zookeeper",
  "commitID" : "c6639c9842973a7954c8baa412d6825cb833d51f",
  "filePath" : "/src/java/main/org/apache/jute/compiler/JRecord.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "\"    try {\\n\"",
    "nodeType" : "StringLiteral",
    "nodePosition" : {
      "charLength" : 13,
      "startLineNumber" : 430,
      "startColumnNumber" : 17,
      "endLineNumber" : 430,
      "endColumnNumber" : 30
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 23,
        "startLineNumber" : 430,
        "startColumnNumber" : 8,
        "endLineNumber" : 430,
        "endColumnNumber" : 31
      },
      "nodeContext" : "jj.write(\"    try {\\n\")",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 24,
        "startLineNumber" : 430,
        "startColumnNumber" : 8,
        "endLineNumber" : 430,
        "endColumnNumber" : 32
      },
      "nodeContext" : "jj.write(\"    try {\\n\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 6359,
        "startLineNumber" : 360,
        "startColumnNumber" : 69,
        "endLineNumber" : 507,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  String pkg=getJavaPackage();\n  String pkgpath=pkg.replaceAll(\"\\\\.\",\"/\");\n  File pkgdir=new File(outputDirectory,pkgpath);\n  if (!pkgdir.exists()) {\n    boolean ret=pkgdir.mkdirs();\n    if (!ret) {\n      System.out.println(\"Cannnot create directory: \" + pkgpath);\n      System.exit(1);\n    }\n  }\n else   if (!pkgdir.isDirectory()) {\n    System.out.println(pkgpath + \" is not a directory.\");\n    System.exit(1);\n  }\n  File jfile=new File(pkgdir,getName() + \".java\");\n  FileWriter jj=new FileWriter(jfile);\n  jj.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n  jj.write(\"package \" + getJavaPackage() + \";\\n\\n\");\n  jj.write(\"import org.apache.jute.*;\\n\");\n  jj.write(\"public class \" + getName() + \" implements Record {\\n\");\n  for (Iterator i=mFields.iterator(); i.hasNext(); ) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaDecl());\n  }\n  jj.write(\"  public \" + getName() + \"() {\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public \" + getName() + \"(\\n\");\n  int fIdx=0;\n  int fLen=mFields.size();\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaConstructorParam(jf.getName()));\n    jj.write((fLen - 1 == fIdx) ? \"\" : \",\\n\");\n  }\n  jj.write(\") {\\n\");\n  fIdx=0;\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaConstructorSet(jf.getName()));\n  }\n  jj.write(\"  }\\n\");\n  fIdx=0;\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaGetSet(fIdx));\n  }\n  jj.write(\"  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\\n\");\n  jj.write(\"    a_.startRecord(this,tag);\\n\");\n  fIdx=0;\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaWriteMethodName());\n  }\n  jj.write(\"    a_.endRecord(this,tag);\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\\n\");\n  jj.write(\"    a_.startRecord(tag);\\n\");\n  fIdx=0;\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaReadMethodName());\n  }\n  jj.write(\"    a_.endRecord(tag);\\n\");\n  jj.write(\"}\\n\");\n  jj.write(\"  public String toString() {\\n\");\n  jj.write(\"    try {\\n\");\n  jj.write(\"      java.io.ByteArrayOutputStream s =\\n\");\n  jj.write(\"        new java.io.ByteArrayOutputStream();\\n\");\n  jj.write(\"      CsvOutputArchive a_ = \\n\");\n  jj.write(\"        new CsvOutputArchive(s);\\n\");\n  jj.write(\"      a_.startRecord(this,\\\"\\\");\\n\");\n  fIdx=0;\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaWriteMethodName());\n  }\n  jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n  jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n  jj.write(\"    } catch (Throwable ex) {\\n\");\n  jj.write(\"      ex.printStackTrace();\\n\");\n  jj.write(\"    }\\n\");\n  jj.write(\"    return \\\"ERROR\\\";\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public void write(java.io.DataOutput out) throws java.io.IOException {\\n\");\n  jj.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(out);\\n\");\n  jj.write(\"    serialize(archive, \\\"\\\");\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public void readFields(java.io.DataInput in) throws java.io.IOException {\\n\");\n  jj.write(\"    BinaryInputArchive archive = new BinaryInputArchive(in);\\n\");\n  jj.write(\"    deserialize(archive, \\\"\\\");\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public int compareTo (Object peer_) throws ClassCastException {\\n\");\n  jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n  jj.write(\"      throw new ClassCastException(\\\"Comparing different types of records.\\\");\\n\");\n  jj.write(\"    }\\n\");\n  jj.write(\"    \" + getName() + \" peer = (\"+ getName()+ \") peer_;\\n\");\n  jj.write(\"    int ret = 0;\\n\");\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaCompareTo());\n    jj.write(\"    if (ret != 0) return ret;\\n\");\n  }\n  jj.write(\"     return ret;\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public boolean equals(Object peer_) {\\n\");\n  jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n  jj.write(\"      return false;\\n\");\n  jj.write(\"    }\\n\");\n  jj.write(\"    if (peer_ == this) {\\n\");\n  jj.write(\"      return true;\\n\");\n  jj.write(\"    }\\n\");\n  jj.write(\"    \" + getName() + \" peer = (\"+ getName()+ \") peer_;\\n\");\n  jj.write(\"    boolean ret = false;\\n\");\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaEquals());\n    jj.write(\"    if (!ret) return ret;\\n\");\n  }\n  jj.write(\"     return ret;\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public int hashCode() {\\n\");\n  jj.write(\"    int result = 17;\\n\");\n  jj.write(\"    int ret;\\n\");\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaHashCode());\n    jj.write(\"    result = 37*result + ret;\\n\");\n  }\n  jj.write(\"    return result;\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public static String signature() {\\n\");\n  jj.write(\"    return \\\"\" + getSignature() + \"\\\";\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"}\\n\");\n  jj.close();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 877,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 6424,
        "startLineNumber" : 360,
        "startColumnNumber" : 4,
        "endLineNumber" : 507,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void genJavaCode(File outputDirectory) throws IOException {\n  String pkg=getJavaPackage();\n  String pkgpath=pkg.replaceAll(\"\\\\.\",\"/\");\n  File pkgdir=new File(outputDirectory,pkgpath);\n  if (!pkgdir.exists()) {\n    boolean ret=pkgdir.mkdirs();\n    if (!ret) {\n      System.out.println(\"Cannnot create directory: \" + pkgpath);\n      System.exit(1);\n    }\n  }\n else   if (!pkgdir.isDirectory()) {\n    System.out.println(pkgpath + \" is not a directory.\");\n    System.exit(1);\n  }\n  File jfile=new File(pkgdir,getName() + \".java\");\n  FileWriter jj=new FileWriter(jfile);\n  jj.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n  jj.write(\"package \" + getJavaPackage() + \";\\n\\n\");\n  jj.write(\"import org.apache.jute.*;\\n\");\n  jj.write(\"public class \" + getName() + \" implements Record {\\n\");\n  for (Iterator i=mFields.iterator(); i.hasNext(); ) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaDecl());\n  }\n  jj.write(\"  public \" + getName() + \"() {\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public \" + getName() + \"(\\n\");\n  int fIdx=0;\n  int fLen=mFields.size();\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaConstructorParam(jf.getName()));\n    jj.write((fLen - 1 == fIdx) ? \"\" : \",\\n\");\n  }\n  jj.write(\") {\\n\");\n  fIdx=0;\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaConstructorSet(jf.getName()));\n  }\n  jj.write(\"  }\\n\");\n  fIdx=0;\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaGetSet(fIdx));\n  }\n  jj.write(\"  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\\n\");\n  jj.write(\"    a_.startRecord(this,tag);\\n\");\n  fIdx=0;\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaWriteMethodName());\n  }\n  jj.write(\"    a_.endRecord(this,tag);\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\\n\");\n  jj.write(\"    a_.startRecord(tag);\\n\");\n  fIdx=0;\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaReadMethodName());\n  }\n  jj.write(\"    a_.endRecord(tag);\\n\");\n  jj.write(\"}\\n\");\n  jj.write(\"  public String toString() {\\n\");\n  jj.write(\"    try {\\n\");\n  jj.write(\"      java.io.ByteArrayOutputStream s =\\n\");\n  jj.write(\"        new java.io.ByteArrayOutputStream();\\n\");\n  jj.write(\"      CsvOutputArchive a_ = \\n\");\n  jj.write(\"        new CsvOutputArchive(s);\\n\");\n  jj.write(\"      a_.startRecord(this,\\\"\\\");\\n\");\n  fIdx=0;\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaWriteMethodName());\n  }\n  jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n  jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n  jj.write(\"    } catch (Throwable ex) {\\n\");\n  jj.write(\"      ex.printStackTrace();\\n\");\n  jj.write(\"    }\\n\");\n  jj.write(\"    return \\\"ERROR\\\";\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public void write(java.io.DataOutput out) throws java.io.IOException {\\n\");\n  jj.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(out);\\n\");\n  jj.write(\"    serialize(archive, \\\"\\\");\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public void readFields(java.io.DataInput in) throws java.io.IOException {\\n\");\n  jj.write(\"    BinaryInputArchive archive = new BinaryInputArchive(in);\\n\");\n  jj.write(\"    deserialize(archive, \\\"\\\");\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public int compareTo (Object peer_) throws ClassCastException {\\n\");\n  jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n  jj.write(\"      throw new ClassCastException(\\\"Comparing different types of records.\\\");\\n\");\n  jj.write(\"    }\\n\");\n  jj.write(\"    \" + getName() + \" peer = (\"+ getName()+ \") peer_;\\n\");\n  jj.write(\"    int ret = 0;\\n\");\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaCompareTo());\n    jj.write(\"    if (ret != 0) return ret;\\n\");\n  }\n  jj.write(\"     return ret;\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public boolean equals(Object peer_) {\\n\");\n  jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n  jj.write(\"      return false;\\n\");\n  jj.write(\"    }\\n\");\n  jj.write(\"    if (peer_ == this) {\\n\");\n  jj.write(\"      return true;\\n\");\n  jj.write(\"    }\\n\");\n  jj.write(\"    \" + getName() + \" peer = (\"+ getName()+ \") peer_;\\n\");\n  jj.write(\"    boolean ret = false;\\n\");\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaEquals());\n    jj.write(\"    if (!ret) return ret;\\n\");\n  }\n  jj.write(\"     return ret;\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public int hashCode() {\\n\");\n  jj.write(\"    int result = 17;\\n\");\n  jj.write(\"    int ret;\\n\");\n  for (Iterator i=mFields.iterator(); i.hasNext(); fIdx++) {\n    JField jf=(JField)i.next();\n    jj.write(jf.genJavaHashCode());\n    jj.write(\"    result = 37*result + ret;\\n\");\n  }\n  jj.write(\"    return result;\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"  public static String signature() {\\n\");\n  jj.write(\"    return \\\"\" + getSignature() + \"\\\";\\n\");\n  jj.write(\"  }\\n\");\n  jj.write(\"}\\n\");\n  jj.close();\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 887,
      "astHeight" : 11
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 24,
        "startLineNumber" : 430,
        "startColumnNumber" : 8,
        "endLineNumber" : 430,
        "endColumnNumber" : 32
      },
      "nodeContext" : "jj.write(\"    try {\\n\");\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 5,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.lang.String"
  } ],
  "positionList" : [ {
    "charLength" : 13,
    "startLineNumber" : 430,
    "startColumnNumber" : 17,
    "endLineNumber" : 430,
    "endColumnNumber" : 30
  } ],
  "layoutRelationDataList" : [ ]
}