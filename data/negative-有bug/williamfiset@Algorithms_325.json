{
  "id" : 325,
  "expression" : "subsetToConnect[0]",
  "projectName" : "williamfiset@Algorithms",
  "commitID" : "6d8bb428cd59ce3da5530d569b555c69a07c2f4d",
  "filePath" : "/src/main/java/com/williamfiset/algorithms/graphtheory/SteinerTree.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "subsetToConnect[0]",
    "nodeType" : "ArrayAccess",
    "nodePosition" : {
      "charLength" : 18,
      "startLineNumber" : 79,
      "startColumnNumber" : 28,
      "endLineNumber" : 79,
      "endColumnNumber" : 46
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ReturnStatement,expression]",
      "nodePosition" : {
        "charLength" : 36,
        "startLineNumber" : 79,
        "startColumnNumber" : 11,
        "endLineNumber" : 79,
        "endColumnNumber" : 47
      },
      "nodeContext" : "dp[(1 << t) - 1][subsetToConnect[0]]",
      "nodeType" : "ArrayAccess",
      "astNodeNumber" : 12,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 79,
        "startColumnNumber" : 4,
        "endLineNumber" : 79,
        "endColumnNumber" : 48
      },
      "nodeContext" : "return dp[(1 << t) - 1][subsetToConnect[0]];\n",
      "nodeType" : "ReturnStatement",
      "astNodeNumber" : 13,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 1817,
        "startLineNumber" : 26,
        "startColumnNumber" : 89,
        "endLineNumber" : 80,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  int v=distances.length;\n  int t=subsetToConnect.length;\n  if (t <= 1) {\n    return 0;\n  }\n  floydWarshall(distances);\n  double[][] dp=new double[1 << t][v];\n  for (int i=0; i < dp.length; i++) {\n    Arrays.fill(dp[i],Double.POSITIVE_INFINITY);\n  }\n  for (int mask=0; mask < t; mask++) {\n    for (int j=0; j < v; j++) {\n      dp[1 << mask][j]=distances[subsetToConnect[mask]][j];\n    }\n  }\n  for (int mask=1; mask < 1 << t; mask++) {\n    for (int j=0; j < v; j++) {\n      for (int subMask=(mask - 1) & mask; subMask > 0; subMask=(subMask - 1) & mask) {\n        dp[mask][j]=Math.min(dp[mask][j],dp[subMask][j] + dp[mask ^ subMask][j]);\n      }\n    }\n    for (int j=0; j < v; j++) {\n      for (int k=0; k < v; k++) {\n        dp[mask][j]=Math.min(dp[mask][j],dp[mask][k] + distances[k][j]);\n      }\n    }\n  }\n  return dp[(1 << t) - 1][subsetToConnect[0]];\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 246,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 2382,
        "startLineNumber" : 17,
        "startColumnNumber" : 2,
        "endLineNumber" : 80,
        "endColumnNumber" : 3
      },
      "nodeContext" : "/** \n * Finds the cheapest cost to connect a given subset of nodes (which we will refer to as terminal nodes). These nodes may be either directly or indirectly connected, possibly connecting to intermediate nodes which are not terminal nodes.\n * @param distances - The adjacency matrix for the undirected graph\n * @param subsetToConnect - The 0-based indices of the terminal nodes\n * @return the minimum cost required to connect the terminal nodes\n */\npublic static double minLengthSteinerTree(double[][] distances,int[] subsetToConnect){\n  int v=distances.length;\n  int t=subsetToConnect.length;\n  if (t <= 1) {\n    return 0;\n  }\n  floydWarshall(distances);\n  double[][] dp=new double[1 << t][v];\n  for (int i=0; i < dp.length; i++) {\n    Arrays.fill(dp[i],Double.POSITIVE_INFINITY);\n  }\n  for (int mask=0; mask < t; mask++) {\n    for (int j=0; j < v; j++) {\n      dp[1 << mask][j]=distances[subsetToConnect[mask]][j];\n    }\n  }\n  for (int mask=1; mask < 1 << t; mask++) {\n    for (int j=0; j < v; j++) {\n      for (int subMask=(mask - 1) & mask; subMask > 0; subMask=(subMask - 1) & mask) {\n        dp[mask][j]=Math.min(dp[mask][j],dp[subMask][j] + dp[mask ^ subMask][j]);\n      }\n    }\n    for (int j=0; j < v; j++) {\n      for (int k=0; k < v; k++) {\n        dp[mask][j]=Math.min(dp[mask][j],dp[mask][k] + distances[k][j]);\n      }\n    }\n  }\n  return dp[(1 << t) - 1][subsetToConnect[0]];\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 263,
      "astHeight" : 16
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 44,
        "startLineNumber" : 79,
        "startColumnNumber" : 4,
        "endLineNumber" : 79,
        "endColumnNumber" : 48
      },
      "nodeContext" : "return dp[(1 << t) - 1][subsetToConnect[0]];\n",
      "nodeType" : "ReturnStatement",
      "astNodeNumber" : 13,
      "astHeight" : 7
    },
    "tokenLength" : 2,
    "type" : "int"
  } ],
  "positionList" : [ {
    "charLength" : 18,
    "startLineNumber" : 79,
    "startColumnNumber" : 28,
    "endLineNumber" : 79,
    "endColumnNumber" : 46
  } ],
  "layoutRelationDataList" : [ ]
}