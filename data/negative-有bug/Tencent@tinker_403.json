{
  "id" : 403,
  "expression" : "patchVersionDirectoryFile",
  "projectName" : "Tencent@tinker",
  "commitID" : "df9e1d29420d53a650ab73569d828a22e3cfe728",
  "filePath" : "/tinker-android/tinker-android-loader/src/main/java/com/tencent/tinker/loader/TinkerLoader.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "patchVersionDirectoryFile",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 25,
      "startLineNumber" : 204,
      "startColumnNumber" : 13,
      "endLineNumber" : 204,
      "endColumnNumber" : 38
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.PrefixExpression,operand]",
      "nodePosition" : {
        "charLength" : 34,
        "startLineNumber" : 204,
        "startColumnNumber" : 13,
        "endLineNumber" : 204,
        "endColumnNumber" : 47
      },
      "nodeContext" : "patchVersionDirectoryFile.exists()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 35,
        "startLineNumber" : 204,
        "startColumnNumber" : 12,
        "endLineNumber" : 204,
        "endColumnNumber" : 47
      },
      "nodeContext" : "!patchVersionDirectoryFile.exists()",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 328,
        "startLineNumber" : 204,
        "startColumnNumber" : 8,
        "endLineNumber" : 209,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (!patchVersionDirectoryFile.exists()) {\n  ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchVersionDirectoryNotFound\");\n  ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n  return;\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 21,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 15781,
        "startLineNumber" : 63,
        "startColumnNumber" : 87,
        "endLineNumber" : 376,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  final int tinkerFlag=app.getTinkerFlags();\n  if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles: tinker is disable, just return\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_DISABLE);\n    return;\n  }\n  if (ShareTinkerInternals.isInPatchProcess(app)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles: we don't load patch with :patch process itself, just return\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_DISABLE);\n    return;\n  }\n  File patchDirectoryFile=SharePatchFileUtil.getPatchDirectory(app);\n  if (patchDirectoryFile == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:getPatchDirectory == null\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  String patchDirectoryPath=patchDirectoryFile.getAbsolutePath();\n  if (!patchDirectoryFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patch dir not exist:\" + patchDirectoryPath);\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  File patchInfoFile=SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);\n  if (!patchInfoFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patch info not exist:\" + patchInfoFile.getAbsolutePath());\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);\n    return;\n  }\n  File patchInfoLockFile=SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);\n  patchInfo=SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile,patchInfoLockFile);\n  if (patchInfo == null) {\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n    return;\n  }\n  final boolean isProtectedApp=patchInfo.isProtectedApp;\n  resultIntent.putExtra(ShareIntentUtil.INTENT_IS_PROTECTED_APP,isProtectedApp);\n  String oldVersion=patchInfo.oldVersion;\n  String newVersion=patchInfo.newVersion;\n  String oatDex=patchInfo.oatDir;\n  if (oldVersion == null || newVersion == null || oatDex == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchInfoCorrupted\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n    return;\n  }\n  boolean mainProcess=ShareTinkerInternals.isInMainProcess(app);\n  boolean isRemoveNewVersion=patchInfo.isRemoveNewVersion;\n  if (mainProcess) {\n    final String patchName=SharePatchFileUtil.getPatchVersionDirectory(newVersion);\n    if (isRemoveNewVersion) {\n      ShareTinkerLog.w(TAG,\"found clean patch mark and we are in main process, delete patch file now.\");\n      if (patchName != null) {\n        final boolean isNewVersionLoadedBefore=oldVersion.equals(newVersion);\n        if (isNewVersionLoadedBefore) {\n          oldVersion=\"\";\n        }\n        newVersion=oldVersion;\n        patchInfo.oldVersion=oldVersion;\n        patchInfo.newVersion=newVersion;\n        patchInfo.isRemoveNewVersion=false;\n        SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile);\n        String patchVersionDirFullPath=patchDirectoryPath + \"/\" + patchName;\n        SharePatchFileUtil.deleteDir(patchVersionDirFullPath);\n        if (isNewVersionLoadedBefore) {\n          ShareTinkerInternals.killProcessExceptMain(app);\n          ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n          return;\n        }\n      }\n    }\n    if (patchInfo.isRemoveInterpretOATDir) {\n      ShareTinkerLog.i(TAG,\"tryLoadPatchFiles: isRemoveInterpretOATDir is true, try to delete interpret optimize files\");\n      patchInfo.isRemoveInterpretOATDir=false;\n      SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile);\n      ShareTinkerInternals.killProcessExceptMain(app);\n      String patchVersionDirFullPath=patchDirectoryPath + \"/\" + patchName;\n      SharePatchFileUtil.deleteDir(patchVersionDirFullPath + \"/\" + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);\n    }\n  }\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION,oldVersion);\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION,newVersion);\n  boolean versionChanged=!(oldVersion.equals(newVersion));\n  boolean oatModeChanged=oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH);\n  oatDex=ShareTinkerInternals.getCurrentOatMode(app,oatDex);\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR,oatDex);\n  String version=oldVersion;\n  if (versionChanged && mainProcess) {\n    version=newVersion;\n  }\n  if (ShareTinkerInternals.isNullOrNil(version)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:version is blank, wait main process to restart\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);\n    return;\n  }\n  String patchName=SharePatchFileUtil.getPatchVersionDirectory(version);\n  if (patchName == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patchName is null\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  String patchVersionDirectory=patchDirectoryPath + \"/\" + patchName;\n  File patchVersionDirectoryFile=new File(patchVersionDirectory);\n  if (!patchVersionDirectoryFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchVersionDirectoryNotFound\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  final String patchVersionFileRelPath=SharePatchFileUtil.getPatchVersionFile(version);\n  File patchVersionFile=(patchVersionFileRelPath != null ? new File(patchVersionDirectoryFile.getAbsolutePath(),patchVersionFileRelPath) : null);\n  if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchVersionFileNotFound\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);\n    return;\n  }\n  ShareSecurityCheck securityCheck=new ShareSecurityCheck(app);\n  int returnCode=ShareTinkerInternals.checkTinkerPackage(app,tinkerFlag,patchVersionFile,securityCheck);\n  if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:checkTinkerPackage\");\n    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK,returnCode);\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);\n    return;\n  }\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG,securityCheck.getPackagePropertiesIfPresent());\n  final boolean isEnabledForDex=ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);\n  final boolean isArkHotRuning=ShareTinkerInternals.isArkHotRuning();\n  if (!isArkHotRuning && isEnabledForDex) {\n    boolean dexCheck=TinkerDexLoader.checkComplete(patchVersionDirectory,securityCheck,oatDex,resultIntent);\n    if (!dexCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:dex check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForArkHot=ShareTinkerInternals.isTinkerEnabledForArkHot(tinkerFlag);\n  if (isArkHotRuning && isEnabledForArkHot) {\n    boolean arkHotCheck=TinkerArkHotLoader.checkComplete(patchVersionDirectory,securityCheck,resultIntent);\n    if (!arkHotCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:dex check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForNativeLib=ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);\n  if (isEnabledForNativeLib) {\n    boolean libCheck=TinkerSoLoader.checkComplete(patchVersionDirectory,securityCheck,resultIntent);\n    if (!libCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:native lib check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForResource=ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);\n  ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:isEnabledForResource:\" + isEnabledForResource);\n  if (isEnabledForResource) {\n    boolean resourceCheck=TinkerResourceLoader.checkComplete(app,patchVersionDirectory,securityCheck,resultIntent);\n    if (!resourceCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:resource check fail\");\n      return;\n    }\n  }\n  boolean isSystemOTA=ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint) && Build.VERSION.SDK_INT >= 21 && !ShareTinkerInternals.isAfterAndroidO();\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA,isSystemOTA);\n  if (mainProcess) {\n    if (versionChanged) {\n      patchInfo.oldVersion=version;\n    }\n    if (oatModeChanged) {\n      patchInfo.oatDir=oatDex;\n      patchInfo.isRemoveInterpretOATDir=true;\n    }\n  }\n  if (!checkSafeModeCount(app)) {\n    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION,new TinkerRuntimeException(\"checkSafeModeCount fail\"));\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:checkSafeModeCount fail\");\n    return;\n  }\n  if (!isArkHotRuning && isEnabledForDex) {\n    boolean loadTinkerJars=TinkerDexLoader.loadTinkerJars(app,patchVersionDirectory,oatDex,resultIntent,isSystemOTA,isProtectedApp);\n    if (isSystemOTA) {\n      patchInfo.fingerPrint=Build.FINGERPRINT;\n      patchInfo.oatDir=loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;\n      oatModeChanged=false;\n      if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile)) {\n        ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);\n        ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onReWritePatchInfoCorrupted\");\n        return;\n      }\n      resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR,patchInfo.oatDir);\n    }\n    if (!loadTinkerJars) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadDexesFail\");\n      return;\n    }\n  }\n  if (isArkHotRuning && isEnabledForArkHot) {\n    boolean loadArkHotFixJars=TinkerArkHotLoader.loadTinkerArkHot(app,patchVersionDirectory,resultIntent);\n    if (!loadArkHotFixJars) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadArkApkFail\");\n      return;\n    }\n  }\n  if (isEnabledForResource) {\n    boolean loadTinkerResources=TinkerResourceLoader.loadTinkerResources(app,patchVersionDirectory,resultIntent);\n    if (!loadTinkerResources) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadResourcesFail\");\n      return;\n    }\n  }\n  if ((isEnabledForDex || isEnabledForArkHot) && isEnabledForResource) {\n    ComponentHotplug.install(app,securityCheck);\n  }\n  if (!AppInfoChangedBlocker.tryStart(app)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:AppInfoChangedBlocker install fail.\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_BAIL_HACK_FAILURE);\n    return;\n  }\n  if (mainProcess && (versionChanged || oatModeChanged)) {\n    if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile)) {\n      ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onReWritePatchInfoCorrupted\");\n      return;\n    }\n    ShareTinkerInternals.killProcessExceptMain(app);\n  }\n  ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_OK);\n  ShareTinkerLog.i(TAG,\"tryLoadPatchFiles: load end, ok!\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1154,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 15864,
        "startLineNumber" : 63,
        "startColumnNumber" : 4,
        "endLineNumber" : 376,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private void tryLoadPatchFilesInternal(TinkerApplication app,Intent resultIntent){\n  final int tinkerFlag=app.getTinkerFlags();\n  if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles: tinker is disable, just return\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_DISABLE);\n    return;\n  }\n  if (ShareTinkerInternals.isInPatchProcess(app)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles: we don't load patch with :patch process itself, just return\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_DISABLE);\n    return;\n  }\n  File patchDirectoryFile=SharePatchFileUtil.getPatchDirectory(app);\n  if (patchDirectoryFile == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:getPatchDirectory == null\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  String patchDirectoryPath=patchDirectoryFile.getAbsolutePath();\n  if (!patchDirectoryFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patch dir not exist:\" + patchDirectoryPath);\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  File patchInfoFile=SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);\n  if (!patchInfoFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patch info not exist:\" + patchInfoFile.getAbsolutePath());\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);\n    return;\n  }\n  File patchInfoLockFile=SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);\n  patchInfo=SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile,patchInfoLockFile);\n  if (patchInfo == null) {\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n    return;\n  }\n  final boolean isProtectedApp=patchInfo.isProtectedApp;\n  resultIntent.putExtra(ShareIntentUtil.INTENT_IS_PROTECTED_APP,isProtectedApp);\n  String oldVersion=patchInfo.oldVersion;\n  String newVersion=patchInfo.newVersion;\n  String oatDex=patchInfo.oatDir;\n  if (oldVersion == null || newVersion == null || oatDex == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchInfoCorrupted\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n    return;\n  }\n  boolean mainProcess=ShareTinkerInternals.isInMainProcess(app);\n  boolean isRemoveNewVersion=patchInfo.isRemoveNewVersion;\n  if (mainProcess) {\n    final String patchName=SharePatchFileUtil.getPatchVersionDirectory(newVersion);\n    if (isRemoveNewVersion) {\n      ShareTinkerLog.w(TAG,\"found clean patch mark and we are in main process, delete patch file now.\");\n      if (patchName != null) {\n        final boolean isNewVersionLoadedBefore=oldVersion.equals(newVersion);\n        if (isNewVersionLoadedBefore) {\n          oldVersion=\"\";\n        }\n        newVersion=oldVersion;\n        patchInfo.oldVersion=oldVersion;\n        patchInfo.newVersion=newVersion;\n        patchInfo.isRemoveNewVersion=false;\n        SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile);\n        String patchVersionDirFullPath=patchDirectoryPath + \"/\" + patchName;\n        SharePatchFileUtil.deleteDir(patchVersionDirFullPath);\n        if (isNewVersionLoadedBefore) {\n          ShareTinkerInternals.killProcessExceptMain(app);\n          ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n          return;\n        }\n      }\n    }\n    if (patchInfo.isRemoveInterpretOATDir) {\n      ShareTinkerLog.i(TAG,\"tryLoadPatchFiles: isRemoveInterpretOATDir is true, try to delete interpret optimize files\");\n      patchInfo.isRemoveInterpretOATDir=false;\n      SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile);\n      ShareTinkerInternals.killProcessExceptMain(app);\n      String patchVersionDirFullPath=patchDirectoryPath + \"/\" + patchName;\n      SharePatchFileUtil.deleteDir(patchVersionDirFullPath + \"/\" + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);\n    }\n  }\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION,oldVersion);\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION,newVersion);\n  boolean versionChanged=!(oldVersion.equals(newVersion));\n  boolean oatModeChanged=oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH);\n  oatDex=ShareTinkerInternals.getCurrentOatMode(app,oatDex);\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR,oatDex);\n  String version=oldVersion;\n  if (versionChanged && mainProcess) {\n    version=newVersion;\n  }\n  if (ShareTinkerInternals.isNullOrNil(version)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:version is blank, wait main process to restart\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);\n    return;\n  }\n  String patchName=SharePatchFileUtil.getPatchVersionDirectory(version);\n  if (patchName == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patchName is null\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  String patchVersionDirectory=patchDirectoryPath + \"/\" + patchName;\n  File patchVersionDirectoryFile=new File(patchVersionDirectory);\n  if (!patchVersionDirectoryFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchVersionDirectoryNotFound\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  final String patchVersionFileRelPath=SharePatchFileUtil.getPatchVersionFile(version);\n  File patchVersionFile=(patchVersionFileRelPath != null ? new File(patchVersionDirectoryFile.getAbsolutePath(),patchVersionFileRelPath) : null);\n  if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchVersionFileNotFound\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);\n    return;\n  }\n  ShareSecurityCheck securityCheck=new ShareSecurityCheck(app);\n  int returnCode=ShareTinkerInternals.checkTinkerPackage(app,tinkerFlag,patchVersionFile,securityCheck);\n  if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:checkTinkerPackage\");\n    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK,returnCode);\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);\n    return;\n  }\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG,securityCheck.getPackagePropertiesIfPresent());\n  final boolean isEnabledForDex=ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);\n  final boolean isArkHotRuning=ShareTinkerInternals.isArkHotRuning();\n  if (!isArkHotRuning && isEnabledForDex) {\n    boolean dexCheck=TinkerDexLoader.checkComplete(patchVersionDirectory,securityCheck,oatDex,resultIntent);\n    if (!dexCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:dex check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForArkHot=ShareTinkerInternals.isTinkerEnabledForArkHot(tinkerFlag);\n  if (isArkHotRuning && isEnabledForArkHot) {\n    boolean arkHotCheck=TinkerArkHotLoader.checkComplete(patchVersionDirectory,securityCheck,resultIntent);\n    if (!arkHotCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:dex check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForNativeLib=ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);\n  if (isEnabledForNativeLib) {\n    boolean libCheck=TinkerSoLoader.checkComplete(patchVersionDirectory,securityCheck,resultIntent);\n    if (!libCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:native lib check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForResource=ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);\n  ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:isEnabledForResource:\" + isEnabledForResource);\n  if (isEnabledForResource) {\n    boolean resourceCheck=TinkerResourceLoader.checkComplete(app,patchVersionDirectory,securityCheck,resultIntent);\n    if (!resourceCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:resource check fail\");\n      return;\n    }\n  }\n  boolean isSystemOTA=ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint) && Build.VERSION.SDK_INT >= 21 && !ShareTinkerInternals.isAfterAndroidO();\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA,isSystemOTA);\n  if (mainProcess) {\n    if (versionChanged) {\n      patchInfo.oldVersion=version;\n    }\n    if (oatModeChanged) {\n      patchInfo.oatDir=oatDex;\n      patchInfo.isRemoveInterpretOATDir=true;\n    }\n  }\n  if (!checkSafeModeCount(app)) {\n    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION,new TinkerRuntimeException(\"checkSafeModeCount fail\"));\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:checkSafeModeCount fail\");\n    return;\n  }\n  if (!isArkHotRuning && isEnabledForDex) {\n    boolean loadTinkerJars=TinkerDexLoader.loadTinkerJars(app,patchVersionDirectory,oatDex,resultIntent,isSystemOTA,isProtectedApp);\n    if (isSystemOTA) {\n      patchInfo.fingerPrint=Build.FINGERPRINT;\n      patchInfo.oatDir=loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;\n      oatModeChanged=false;\n      if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile)) {\n        ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);\n        ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onReWritePatchInfoCorrupted\");\n        return;\n      }\n      resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR,patchInfo.oatDir);\n    }\n    if (!loadTinkerJars) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadDexesFail\");\n      return;\n    }\n  }\n  if (isArkHotRuning && isEnabledForArkHot) {\n    boolean loadArkHotFixJars=TinkerArkHotLoader.loadTinkerArkHot(app,patchVersionDirectory,resultIntent);\n    if (!loadArkHotFixJars) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadArkApkFail\");\n      return;\n    }\n  }\n  if (isEnabledForResource) {\n    boolean loadTinkerResources=TinkerResourceLoader.loadTinkerResources(app,patchVersionDirectory,resultIntent);\n    if (!loadTinkerResources) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadResourcesFail\");\n      return;\n    }\n  }\n  if ((isEnabledForDex || isEnabledForArkHot) && isEnabledForResource) {\n    ComponentHotplug.install(app,securityCheck);\n  }\n  if (!AppInfoChangedBlocker.tryStart(app)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:AppInfoChangedBlocker install fail.\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_BAIL_HACK_FAILURE);\n    return;\n  }\n  if (mainProcess && (versionChanged || oatModeChanged)) {\n    if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile)) {\n      ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onReWritePatchInfoCorrupted\");\n      return;\n    }\n    ShareTinkerInternals.killProcessExceptMain(app);\n  }\n  ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_OK);\n  ShareTinkerLog.i(TAG,\"tryLoadPatchFiles: load end, ok!\");\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1166,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 35,
        "startLineNumber" : 204,
        "startColumnNumber" : 12,
        "endLineNumber" : 204,
        "endColumnNumber" : 47
      },
      "nodeContext" : "!patchVersionDirectoryFile.exists()",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 4,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "java.io.File"
  }, {
    "nodeContext" : "patchVersionDirectoryFile",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 25,
      "startLineNumber" : 213,
      "startColumnNumber" : 76,
      "endLineNumber" : 213,
      "endColumnNumber" : 101
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.ClassInstanceCreation,arguments]",
      "nodePosition" : {
        "charLength" : 43,
        "startLineNumber" : 213,
        "startColumnNumber" : 76,
        "endLineNumber" : 213,
        "endColumnNumber" : 119
      },
      "nodeContext" : "patchVersionDirectoryFile.getAbsolutePath()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ConditionalExpression,thenExpression]",
      "nodePosition" : {
        "charLength" : 78,
        "startLineNumber" : 213,
        "startColumnNumber" : 67,
        "endLineNumber" : 213,
        "endColumnNumber" : 145
      },
      "nodeContext" : "new File(patchVersionDirectoryFile.getAbsolutePath(),patchVersionFileRelPath)",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ParenthesizedExpression,expression]",
      "nodePosition" : {
        "charLength" : 119,
        "startLineNumber" : 213,
        "startColumnNumber" : 33,
        "endLineNumber" : 213,
        "endColumnNumber" : 152
      },
      "nodeContext" : "patchVersionFileRelPath != null ? new File(patchVersionDirectoryFile.getAbsolutePath(),patchVersionFileRelPath) : null",
      "nodeType" : "ConditionalExpression",
      "astNodeNumber" : 12,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 121,
        "startLineNumber" : 213,
        "startColumnNumber" : 32,
        "endLineNumber" : 213,
        "endColumnNumber" : 153
      },
      "nodeContext" : "(patchVersionFileRelPath != null ? new File(patchVersionDirectoryFile.getAbsolutePath(),patchVersionFileRelPath) : null)",
      "nodeType" : "ParenthesizedExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 140,
        "startLineNumber" : 213,
        "startColumnNumber" : 13,
        "endLineNumber" : 213,
        "endColumnNumber" : 153
      },
      "nodeContext" : "patchVersionFile=(patchVersionFileRelPath != null ? new File(patchVersionDirectoryFile.getAbsolutePath(),patchVersionFileRelPath) : null)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 15,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 146,
        "startLineNumber" : 213,
        "startColumnNumber" : 8,
        "endLineNumber" : 213,
        "endColumnNumber" : 154
      },
      "nodeContext" : "File patchVersionFile=(patchVersionFileRelPath != null ? new File(patchVersionDirectoryFile.getAbsolutePath(),patchVersionFileRelPath) : null);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 15781,
        "startLineNumber" : 63,
        "startColumnNumber" : 87,
        "endLineNumber" : 376,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  final int tinkerFlag=app.getTinkerFlags();\n  if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles: tinker is disable, just return\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_DISABLE);\n    return;\n  }\n  if (ShareTinkerInternals.isInPatchProcess(app)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles: we don't load patch with :patch process itself, just return\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_DISABLE);\n    return;\n  }\n  File patchDirectoryFile=SharePatchFileUtil.getPatchDirectory(app);\n  if (patchDirectoryFile == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:getPatchDirectory == null\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  String patchDirectoryPath=patchDirectoryFile.getAbsolutePath();\n  if (!patchDirectoryFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patch dir not exist:\" + patchDirectoryPath);\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  File patchInfoFile=SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);\n  if (!patchInfoFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patch info not exist:\" + patchInfoFile.getAbsolutePath());\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);\n    return;\n  }\n  File patchInfoLockFile=SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);\n  patchInfo=SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile,patchInfoLockFile);\n  if (patchInfo == null) {\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n    return;\n  }\n  final boolean isProtectedApp=patchInfo.isProtectedApp;\n  resultIntent.putExtra(ShareIntentUtil.INTENT_IS_PROTECTED_APP,isProtectedApp);\n  String oldVersion=patchInfo.oldVersion;\n  String newVersion=patchInfo.newVersion;\n  String oatDex=patchInfo.oatDir;\n  if (oldVersion == null || newVersion == null || oatDex == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchInfoCorrupted\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n    return;\n  }\n  boolean mainProcess=ShareTinkerInternals.isInMainProcess(app);\n  boolean isRemoveNewVersion=patchInfo.isRemoveNewVersion;\n  if (mainProcess) {\n    final String patchName=SharePatchFileUtil.getPatchVersionDirectory(newVersion);\n    if (isRemoveNewVersion) {\n      ShareTinkerLog.w(TAG,\"found clean patch mark and we are in main process, delete patch file now.\");\n      if (patchName != null) {\n        final boolean isNewVersionLoadedBefore=oldVersion.equals(newVersion);\n        if (isNewVersionLoadedBefore) {\n          oldVersion=\"\";\n        }\n        newVersion=oldVersion;\n        patchInfo.oldVersion=oldVersion;\n        patchInfo.newVersion=newVersion;\n        patchInfo.isRemoveNewVersion=false;\n        SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile);\n        String patchVersionDirFullPath=patchDirectoryPath + \"/\" + patchName;\n        SharePatchFileUtil.deleteDir(patchVersionDirFullPath);\n        if (isNewVersionLoadedBefore) {\n          ShareTinkerInternals.killProcessExceptMain(app);\n          ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n          return;\n        }\n      }\n    }\n    if (patchInfo.isRemoveInterpretOATDir) {\n      ShareTinkerLog.i(TAG,\"tryLoadPatchFiles: isRemoveInterpretOATDir is true, try to delete interpret optimize files\");\n      patchInfo.isRemoveInterpretOATDir=false;\n      SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile);\n      ShareTinkerInternals.killProcessExceptMain(app);\n      String patchVersionDirFullPath=patchDirectoryPath + \"/\" + patchName;\n      SharePatchFileUtil.deleteDir(patchVersionDirFullPath + \"/\" + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);\n    }\n  }\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION,oldVersion);\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION,newVersion);\n  boolean versionChanged=!(oldVersion.equals(newVersion));\n  boolean oatModeChanged=oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH);\n  oatDex=ShareTinkerInternals.getCurrentOatMode(app,oatDex);\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR,oatDex);\n  String version=oldVersion;\n  if (versionChanged && mainProcess) {\n    version=newVersion;\n  }\n  if (ShareTinkerInternals.isNullOrNil(version)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:version is blank, wait main process to restart\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);\n    return;\n  }\n  String patchName=SharePatchFileUtil.getPatchVersionDirectory(version);\n  if (patchName == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patchName is null\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  String patchVersionDirectory=patchDirectoryPath + \"/\" + patchName;\n  File patchVersionDirectoryFile=new File(patchVersionDirectory);\n  if (!patchVersionDirectoryFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchVersionDirectoryNotFound\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  final String patchVersionFileRelPath=SharePatchFileUtil.getPatchVersionFile(version);\n  File patchVersionFile=(patchVersionFileRelPath != null ? new File(patchVersionDirectoryFile.getAbsolutePath(),patchVersionFileRelPath) : null);\n  if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchVersionFileNotFound\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);\n    return;\n  }\n  ShareSecurityCheck securityCheck=new ShareSecurityCheck(app);\n  int returnCode=ShareTinkerInternals.checkTinkerPackage(app,tinkerFlag,patchVersionFile,securityCheck);\n  if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:checkTinkerPackage\");\n    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK,returnCode);\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);\n    return;\n  }\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG,securityCheck.getPackagePropertiesIfPresent());\n  final boolean isEnabledForDex=ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);\n  final boolean isArkHotRuning=ShareTinkerInternals.isArkHotRuning();\n  if (!isArkHotRuning && isEnabledForDex) {\n    boolean dexCheck=TinkerDexLoader.checkComplete(patchVersionDirectory,securityCheck,oatDex,resultIntent);\n    if (!dexCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:dex check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForArkHot=ShareTinkerInternals.isTinkerEnabledForArkHot(tinkerFlag);\n  if (isArkHotRuning && isEnabledForArkHot) {\n    boolean arkHotCheck=TinkerArkHotLoader.checkComplete(patchVersionDirectory,securityCheck,resultIntent);\n    if (!arkHotCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:dex check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForNativeLib=ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);\n  if (isEnabledForNativeLib) {\n    boolean libCheck=TinkerSoLoader.checkComplete(patchVersionDirectory,securityCheck,resultIntent);\n    if (!libCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:native lib check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForResource=ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);\n  ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:isEnabledForResource:\" + isEnabledForResource);\n  if (isEnabledForResource) {\n    boolean resourceCheck=TinkerResourceLoader.checkComplete(app,patchVersionDirectory,securityCheck,resultIntent);\n    if (!resourceCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:resource check fail\");\n      return;\n    }\n  }\n  boolean isSystemOTA=ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint) && Build.VERSION.SDK_INT >= 21 && !ShareTinkerInternals.isAfterAndroidO();\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA,isSystemOTA);\n  if (mainProcess) {\n    if (versionChanged) {\n      patchInfo.oldVersion=version;\n    }\n    if (oatModeChanged) {\n      patchInfo.oatDir=oatDex;\n      patchInfo.isRemoveInterpretOATDir=true;\n    }\n  }\n  if (!checkSafeModeCount(app)) {\n    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION,new TinkerRuntimeException(\"checkSafeModeCount fail\"));\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:checkSafeModeCount fail\");\n    return;\n  }\n  if (!isArkHotRuning && isEnabledForDex) {\n    boolean loadTinkerJars=TinkerDexLoader.loadTinkerJars(app,patchVersionDirectory,oatDex,resultIntent,isSystemOTA,isProtectedApp);\n    if (isSystemOTA) {\n      patchInfo.fingerPrint=Build.FINGERPRINT;\n      patchInfo.oatDir=loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;\n      oatModeChanged=false;\n      if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile)) {\n        ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);\n        ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onReWritePatchInfoCorrupted\");\n        return;\n      }\n      resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR,patchInfo.oatDir);\n    }\n    if (!loadTinkerJars) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadDexesFail\");\n      return;\n    }\n  }\n  if (isArkHotRuning && isEnabledForArkHot) {\n    boolean loadArkHotFixJars=TinkerArkHotLoader.loadTinkerArkHot(app,patchVersionDirectory,resultIntent);\n    if (!loadArkHotFixJars) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadArkApkFail\");\n      return;\n    }\n  }\n  if (isEnabledForResource) {\n    boolean loadTinkerResources=TinkerResourceLoader.loadTinkerResources(app,patchVersionDirectory,resultIntent);\n    if (!loadTinkerResources) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadResourcesFail\");\n      return;\n    }\n  }\n  if ((isEnabledForDex || isEnabledForArkHot) && isEnabledForResource) {\n    ComponentHotplug.install(app,securityCheck);\n  }\n  if (!AppInfoChangedBlocker.tryStart(app)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:AppInfoChangedBlocker install fail.\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_BAIL_HACK_FAILURE);\n    return;\n  }\n  if (mainProcess && (versionChanged || oatModeChanged)) {\n    if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile)) {\n      ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onReWritePatchInfoCorrupted\");\n      return;\n    }\n    ShareTinkerInternals.killProcessExceptMain(app);\n  }\n  ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_OK);\n  ShareTinkerLog.i(TAG,\"tryLoadPatchFiles: load end, ok!\");\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1154,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 15864,
        "startLineNumber" : 63,
        "startColumnNumber" : 4,
        "endLineNumber" : 376,
        "endColumnNumber" : 5
      },
      "nodeContext" : "private void tryLoadPatchFilesInternal(TinkerApplication app,Intent resultIntent){\n  final int tinkerFlag=app.getTinkerFlags();\n  if (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles: tinker is disable, just return\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_DISABLE);\n    return;\n  }\n  if (ShareTinkerInternals.isInPatchProcess(app)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles: we don't load patch with :patch process itself, just return\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_DISABLE);\n    return;\n  }\n  File patchDirectoryFile=SharePatchFileUtil.getPatchDirectory(app);\n  if (patchDirectoryFile == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:getPatchDirectory == null\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  String patchDirectoryPath=patchDirectoryFile.getAbsolutePath();\n  if (!patchDirectoryFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patch dir not exist:\" + patchDirectoryPath);\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  File patchInfoFile=SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);\n  if (!patchInfoFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patch info not exist:\" + patchInfoFile.getAbsolutePath());\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);\n    return;\n  }\n  File patchInfoLockFile=SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);\n  patchInfo=SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile,patchInfoLockFile);\n  if (patchInfo == null) {\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n    return;\n  }\n  final boolean isProtectedApp=patchInfo.isProtectedApp;\n  resultIntent.putExtra(ShareIntentUtil.INTENT_IS_PROTECTED_APP,isProtectedApp);\n  String oldVersion=patchInfo.oldVersion;\n  String newVersion=patchInfo.newVersion;\n  String oatDex=patchInfo.oatDir;\n  if (oldVersion == null || newVersion == null || oatDex == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchInfoCorrupted\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);\n    return;\n  }\n  boolean mainProcess=ShareTinkerInternals.isInMainProcess(app);\n  boolean isRemoveNewVersion=patchInfo.isRemoveNewVersion;\n  if (mainProcess) {\n    final String patchName=SharePatchFileUtil.getPatchVersionDirectory(newVersion);\n    if (isRemoveNewVersion) {\n      ShareTinkerLog.w(TAG,\"found clean patch mark and we are in main process, delete patch file now.\");\n      if (patchName != null) {\n        final boolean isNewVersionLoadedBefore=oldVersion.equals(newVersion);\n        if (isNewVersionLoadedBefore) {\n          oldVersion=\"\";\n        }\n        newVersion=oldVersion;\n        patchInfo.oldVersion=oldVersion;\n        patchInfo.newVersion=newVersion;\n        patchInfo.isRemoveNewVersion=false;\n        SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile);\n        String patchVersionDirFullPath=patchDirectoryPath + \"/\" + patchName;\n        SharePatchFileUtil.deleteDir(patchVersionDirFullPath);\n        if (isNewVersionLoadedBefore) {\n          ShareTinkerInternals.killProcessExceptMain(app);\n          ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);\n          return;\n        }\n      }\n    }\n    if (patchInfo.isRemoveInterpretOATDir) {\n      ShareTinkerLog.i(TAG,\"tryLoadPatchFiles: isRemoveInterpretOATDir is true, try to delete interpret optimize files\");\n      patchInfo.isRemoveInterpretOATDir=false;\n      SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile);\n      ShareTinkerInternals.killProcessExceptMain(app);\n      String patchVersionDirFullPath=patchDirectoryPath + \"/\" + patchName;\n      SharePatchFileUtil.deleteDir(patchVersionDirFullPath + \"/\" + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);\n    }\n  }\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION,oldVersion);\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION,newVersion);\n  boolean versionChanged=!(oldVersion.equals(newVersion));\n  boolean oatModeChanged=oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH);\n  oatDex=ShareTinkerInternals.getCurrentOatMode(app,oatDex);\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR,oatDex);\n  String version=oldVersion;\n  if (versionChanged && mainProcess) {\n    version=newVersion;\n  }\n  if (ShareTinkerInternals.isNullOrNil(version)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:version is blank, wait main process to restart\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);\n    return;\n  }\n  String patchName=SharePatchFileUtil.getPatchVersionDirectory(version);\n  if (patchName == null) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:patchName is null\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  String patchVersionDirectory=patchDirectoryPath + \"/\" + patchName;\n  File patchVersionDirectoryFile=new File(patchVersionDirectory);\n  if (!patchVersionDirectoryFile.exists()) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchVersionDirectoryNotFound\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);\n    return;\n  }\n  final String patchVersionFileRelPath=SharePatchFileUtil.getPatchVersionFile(version);\n  File patchVersionFile=(patchVersionFileRelPath != null ? new File(patchVersionDirectoryFile.getAbsolutePath(),patchVersionFileRelPath) : null);\n  if (!SharePatchFileUtil.isLegalFile(patchVersionFile)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchVersionFileNotFound\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);\n    return;\n  }\n  ShareSecurityCheck securityCheck=new ShareSecurityCheck(app);\n  int returnCode=ShareTinkerInternals.checkTinkerPackage(app,tinkerFlag,patchVersionFile,securityCheck);\n  if (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:checkTinkerPackage\");\n    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK,returnCode);\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);\n    return;\n  }\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG,securityCheck.getPackagePropertiesIfPresent());\n  final boolean isEnabledForDex=ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);\n  final boolean isArkHotRuning=ShareTinkerInternals.isArkHotRuning();\n  if (!isArkHotRuning && isEnabledForDex) {\n    boolean dexCheck=TinkerDexLoader.checkComplete(patchVersionDirectory,securityCheck,oatDex,resultIntent);\n    if (!dexCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:dex check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForArkHot=ShareTinkerInternals.isTinkerEnabledForArkHot(tinkerFlag);\n  if (isArkHotRuning && isEnabledForArkHot) {\n    boolean arkHotCheck=TinkerArkHotLoader.checkComplete(patchVersionDirectory,securityCheck,resultIntent);\n    if (!arkHotCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:dex check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForNativeLib=ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);\n  if (isEnabledForNativeLib) {\n    boolean libCheck=TinkerSoLoader.checkComplete(patchVersionDirectory,securityCheck,resultIntent);\n    if (!libCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:native lib check fail\");\n      return;\n    }\n  }\n  final boolean isEnabledForResource=ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);\n  ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:isEnabledForResource:\" + isEnabledForResource);\n  if (isEnabledForResource) {\n    boolean resourceCheck=TinkerResourceLoader.checkComplete(app,patchVersionDirectory,securityCheck,resultIntent);\n    if (!resourceCheck) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:resource check fail\");\n      return;\n    }\n  }\n  boolean isSystemOTA=ShareTinkerInternals.isVmArt() && ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint) && Build.VERSION.SDK_INT >= 21 && !ShareTinkerInternals.isAfterAndroidO();\n  resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA,isSystemOTA);\n  if (mainProcess) {\n    if (versionChanged) {\n      patchInfo.oldVersion=version;\n    }\n    if (oatModeChanged) {\n      patchInfo.oatDir=oatDex;\n      patchInfo.isRemoveInterpretOATDir=true;\n    }\n  }\n  if (!checkSafeModeCount(app)) {\n    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION,new TinkerRuntimeException(\"checkSafeModeCount fail\"));\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:checkSafeModeCount fail\");\n    return;\n  }\n  if (!isArkHotRuning && isEnabledForDex) {\n    boolean loadTinkerJars=TinkerDexLoader.loadTinkerJars(app,patchVersionDirectory,oatDex,resultIntent,isSystemOTA,isProtectedApp);\n    if (isSystemOTA) {\n      patchInfo.fingerPrint=Build.FINGERPRINT;\n      patchInfo.oatDir=loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;\n      oatModeChanged=false;\n      if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile)) {\n        ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);\n        ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onReWritePatchInfoCorrupted\");\n        return;\n      }\n      resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR,patchInfo.oatDir);\n    }\n    if (!loadTinkerJars) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadDexesFail\");\n      return;\n    }\n  }\n  if (isArkHotRuning && isEnabledForArkHot) {\n    boolean loadArkHotFixJars=TinkerArkHotLoader.loadTinkerArkHot(app,patchVersionDirectory,resultIntent);\n    if (!loadArkHotFixJars) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadArkApkFail\");\n      return;\n    }\n  }\n  if (isEnabledForResource) {\n    boolean loadTinkerResources=TinkerResourceLoader.loadTinkerResources(app,patchVersionDirectory,resultIntent);\n    if (!loadTinkerResources) {\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onPatchLoadResourcesFail\");\n      return;\n    }\n  }\n  if ((isEnabledForDex || isEnabledForArkHot) && isEnabledForResource) {\n    ComponentHotplug.install(app,securityCheck);\n  }\n  if (!AppInfoChangedBlocker.tryStart(app)) {\n    ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:AppInfoChangedBlocker install fail.\");\n    ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_BAIL_HACK_FAILURE);\n    return;\n  }\n  if (mainProcess && (versionChanged || oatModeChanged)) {\n    if (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile,patchInfo,patchInfoLockFile)) {\n      ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);\n      ShareTinkerLog.w(TAG,\"tryLoadPatchFiles:onReWritePatchInfoCorrupted\");\n      return;\n    }\n    ShareTinkerInternals.killProcessExceptMain(app);\n  }\n  ShareIntentUtil.setIntentReturnCode(resultIntent,ShareConstants.ERROR_LOAD_OK);\n  ShareTinkerLog.i(TAG,\"tryLoadPatchFiles: load end, ok!\");\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1166,
      "astHeight" : 14
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 146,
        "startLineNumber" : 213,
        "startColumnNumber" : 8,
        "endLineNumber" : 213,
        "endColumnNumber" : 154
      },
      "nodeContext" : "File patchVersionFile=(patchVersionFileRelPath != null ? new File(patchVersionDirectoryFile.getAbsolutePath(),patchVersionFileRelPath) : null);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 18,
      "astHeight" : 7
    },
    "tokenLength" : 1,
    "type" : "java.io.File"
  } ],
  "positionList" : [ {
    "charLength" : 25,
    "startLineNumber" : 204,
    "startColumnNumber" : 13,
    "endLineNumber" : 204,
    "endColumnNumber" : 38
  }, {
    "charLength" : 25,
    "startLineNumber" : 213,
    "startColumnNumber" : 76,
    "endLineNumber" : 213,
    "endColumnNumber" : 101
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 6
  } ]
}