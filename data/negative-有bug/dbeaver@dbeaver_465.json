{
  "id" : 465,
  "expression" : "context",
  "projectName" : "dbeaver@dbeaver",
  "commitID" : "aecf0da5baef5ea4aa1675578670cf057248123d",
  "filePath" : "/plugins/org.jkiss.dbeaver.data.transfer/src/org/jkiss/dbeaver/tools/transfer/database/DatabaseTransferProducer.java",
  "occurrences" : 9,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "context",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 181,
      "startColumnNumber" : 20,
      "endLineNumber" : 181,
      "endColumnNumber" : 27
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 15,
        "startLineNumber" : 181,
        "startColumnNumber" : 20,
        "endLineNumber" : 181,
        "endColumnNumber" : 35
      },
      "nodeContext" : "context == null",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 157,
        "startLineNumber" : 181,
        "startColumnNumber" : 16,
        "endLineNumber" : 183,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (context == null) {\n  throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 12,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 6551,
        "startLineNumber" : 174,
        "startColumnNumber" : 16,
        "endLineNumber" : 282,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n",
      "nodeType" : "Block",
      "astNodeNumber" : 469,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6649,
        "startLineNumber" : 174,
        "startColumnNumber" : 12,
        "endLineNumber" : 284,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n catch (DBException e) {\n  throw new InvocationTargetException(e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 481,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
      "nodePosition" : {
        "charLength" : 7412,
        "startLineNumber" : 161,
        "startColumnNumber" : 71,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 556,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 7423,
        "startLineNumber" : 161,
        "startColumnNumber" : 60,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "monitor -> {\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "LambdaExpression",
      "astNodeNumber" : 559,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 15,
        "startLineNumber" : 181,
        "startColumnNumber" : 20,
        "endLineNumber" : 181,
        "endColumnNumber" : 35
      },
      "nodeContext" : "context == null",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "org.jkiss.dbeaver.model.exec.DBCExecutionContext"
  }, {
    "nodeContext" : "context",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 185,
      "startColumnNumber" : 137,
      "endLineNumber" : 185,
      "endColumnNumber" : 144
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 115,
        "startLineNumber" : 185,
        "startColumnNumber" : 30,
        "endLineNumber" : 185,
        "endColumnNumber" : 145
      },
      "nodeContext" : "DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 125,
        "startLineNumber" : 185,
        "startColumnNumber" : 20,
        "endLineNumber" : 185,
        "endColumnNumber" : 145
      },
      "nodeContext" : "context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context)",
      "nodeType" : "Assignment",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 126,
        "startLineNumber" : 185,
        "startColumnNumber" : 20,
        "endLineNumber" : 185,
        "endColumnNumber" : 146
      },
      "nodeContext" : "context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 294,
        "startLineNumber" : 184,
        "startColumnNumber" : 61,
        "endLineNumber" : 187,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n  DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 24,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 339,
        "startLineNumber" : 184,
        "startColumnNumber" : 16,
        "endLineNumber" : 187,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (!selectiveExportFromUI && newConnection) {\n  context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n  DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 29,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 6551,
        "startLineNumber" : 174,
        "startColumnNumber" : 16,
        "endLineNumber" : 282,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n",
      "nodeType" : "Block",
      "astNodeNumber" : 469,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6649,
        "startLineNumber" : 174,
        "startColumnNumber" : 12,
        "endLineNumber" : 284,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n catch (DBException e) {\n  throw new InvocationTargetException(e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 481,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
      "nodePosition" : {
        "charLength" : 7412,
        "startLineNumber" : 161,
        "startColumnNumber" : 71,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 556,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 7423,
        "startLineNumber" : 161,
        "startColumnNumber" : 60,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "monitor -> {\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "LambdaExpression",
      "astNodeNumber" : 559,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 126,
        "startLineNumber" : 185,
        "startColumnNumber" : 20,
        "endLineNumber" : 185,
        "endColumnNumber" : 146
      },
      "nodeContext" : "context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 6
    },
    "tokenLength" : 1,
    "type" : "org.jkiss.dbeaver.model.exec.DBCExecutionContext"
  }, {
    "nodeContext" : "context",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 186,
      "startColumnNumber" : 81,
      "endLineNumber" : 186,
      "endColumnNumber" : 88
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 106,
        "startLineNumber" : 186,
        "startColumnNumber" : 20,
        "endLineNumber" : 186,
        "endColumnNumber" : 126
      },
      "nodeContext" : "DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 9,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 107,
        "startLineNumber" : 186,
        "startColumnNumber" : 20,
        "endLineNumber" : 186,
        "endColumnNumber" : 127
      },
      "nodeContext" : "DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 294,
        "startLineNumber" : 184,
        "startColumnNumber" : 61,
        "endLineNumber" : 187,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n  DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 24,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 339,
        "startLineNumber" : 184,
        "startColumnNumber" : 16,
        "endLineNumber" : 187,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (!selectiveExportFromUI && newConnection) {\n  context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n  DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 29,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 6551,
        "startLineNumber" : 174,
        "startColumnNumber" : 16,
        "endLineNumber" : 282,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n",
      "nodeType" : "Block",
      "astNodeNumber" : 469,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6649,
        "startLineNumber" : 174,
        "startColumnNumber" : 12,
        "endLineNumber" : 284,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n catch (DBException e) {\n  throw new InvocationTargetException(e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 481,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
      "nodePosition" : {
        "charLength" : 7412,
        "startLineNumber" : 161,
        "startColumnNumber" : 71,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 556,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 7423,
        "startLineNumber" : 161,
        "startColumnNumber" : 60,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "monitor -> {\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "LambdaExpression",
      "astNodeNumber" : 559,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 107,
        "startLineNumber" : 186,
        "startColumnNumber" : 20,
        "endLineNumber" : 186,
        "endColumnNumber" : 127
      },
      "nodeContext" : "DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 10,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "org.jkiss.dbeaver.model.exec.DBCExecutionContext"
  }, {
    "nodeContext" : "context",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 189,
      "startColumnNumber" : 63,
      "endLineNumber" : 189,
      "endColumnNumber" : 70
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 189,
        "startColumnNumber" : 20,
        "endLineNumber" : 189,
        "endColumnNumber" : 71
      },
      "nodeContext" : "DBTaskUtils.initFromContext(monitor,task,context)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 6,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 189,
        "startColumnNumber" : 20,
        "endLineNumber" : 189,
        "endColumnNumber" : 72
      },
      "nodeContext" : "DBTaskUtils.initFromContext(monitor,task,context);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 92,
        "startLineNumber" : 188,
        "startColumnNumber" : 34,
        "endLineNumber" : 190,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  DBTaskUtils.initFromContext(monitor,task,context);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 110,
        "startLineNumber" : 188,
        "startColumnNumber" : 16,
        "endLineNumber" : 190,
        "endColumnNumber" : 17
      },
      "nodeContext" : "if (task != null) {\n  DBTaskUtils.initFromContext(monitor,task,context);\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 12,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 6551,
        "startLineNumber" : 174,
        "startColumnNumber" : 16,
        "endLineNumber" : 282,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n",
      "nodeType" : "Block",
      "astNodeNumber" : 469,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6649,
        "startLineNumber" : 174,
        "startColumnNumber" : 12,
        "endLineNumber" : 284,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n catch (DBException e) {\n  throw new InvocationTargetException(e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 481,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
      "nodePosition" : {
        "charLength" : 7412,
        "startLineNumber" : 161,
        "startColumnNumber" : 71,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 556,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 7423,
        "startLineNumber" : 161,
        "startColumnNumber" : 60,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "monitor -> {\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "LambdaExpression",
      "astNodeNumber" : 559,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 52,
        "startLineNumber" : 189,
        "startColumnNumber" : 20,
        "endLineNumber" : 189,
        "endColumnNumber" : 72
      },
      "nodeContext" : "DBTaskUtils.initFromContext(monitor,task,context);\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 7,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "org.jkiss.dbeaver.model.exec.DBCExecutionContext"
  }, {
    "nodeContext" : "context",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 192,
      "startColumnNumber" : 42,
      "endLineNumber" : 192,
      "endColumnNumber" : 49
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 67,
        "startLineNumber" : 192,
        "startColumnNumber" : 42,
        "endLineNumber" : 192,
        "endColumnNumber" : 109
      },
      "nodeContext" : "context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 8,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationExpression,fragments]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 192,
        "startColumnNumber" : 32,
        "endLineNumber" : 192,
        "endColumnNumber" : 109
      },
      "nodeContext" : "session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 10,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TryStatement,resources]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 192,
        "startColumnNumber" : 21,
        "endLineNumber" : 192,
        "endColumnNumber" : 109
      },
      "nodeContext" : "DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5537,
        "startLineNumber" : 192,
        "startColumnNumber" : 16,
        "endLineNumber" : 281,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n  Boolean oldAutoCommit=null;\n  try {\n    AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n    session.enableLogging(false);\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions()) {\n          oldAutoCommit=txnManager.isAutoCommit();\n          txnManager.setAutoCommit(monitor,false);\n        }\n      }\n catch (      DBCException e) {\n        log.warn(\"Can't change auto-commit\",e);\n      }\n    }\n    long totalRows=0;\n    if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n      try {\n        totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n      }\n catch (      Throwable e) {\n        log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n          if (txnManager != null && !txnManager.isAutoCommit()) {\n            txnManager.rollback(session,null);\n          }\n        }\n catch (        Throwable e1) {\n          log.warn(\"Error rolling back transaction\",e1);\n        }\n      }\n finally {\n        monitor.done();\n      }\n    }\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n    try {\n      monitor.subTask(\"Read data\");\n      if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n        dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n      }\n else {\n        long offset=0;\n        int segmentSize=settings.getSegmentSize();\n        for (; ; ) {\n          DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n          if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n            break;\n          }\n          offset+=statistics.getRowsFetched();\n        }\n      }\n    }\n  finally {\n      monitor.done();\n    }\n  }\n  finally {\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n        try {\n          txnManager.commit(session);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n        if (oldAutoCommit != null) {\n          try {\n            txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n        }\n      }\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context.close();\n    }\n  }\n}\n ",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 385,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 6551,
        "startLineNumber" : 174,
        "startColumnNumber" : 16,
        "endLineNumber" : 282,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n",
      "nodeType" : "Block",
      "astNodeNumber" : 469,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6649,
        "startLineNumber" : 174,
        "startColumnNumber" : 12,
        "endLineNumber" : 284,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n catch (DBException e) {\n  throw new InvocationTargetException(e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 481,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
      "nodePosition" : {
        "charLength" : 7412,
        "startLineNumber" : 161,
        "startColumnNumber" : 71,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 556,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 7423,
        "startLineNumber" : 161,
        "startColumnNumber" : 60,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "monitor -> {\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "LambdaExpression",
      "astNodeNumber" : 559,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TryStatement,resources]",
      "nodePosition" : {
        "charLength" : 88,
        "startLineNumber" : 192,
        "startColumnNumber" : 21,
        "endLineNumber" : 192,
        "endColumnNumber" : 109
      },
      "nodeContext" : "DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)",
      "nodeType" : "VariableDeclarationExpression",
      "astNodeNumber" : 13,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "org.jkiss.dbeaver.model.exec.DBCExecutionContext"
  }, {
    "nodeContext" : "context",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 195,
      "startColumnNumber" : 108,
      "endLineNumber" : 195,
      "endColumnNumber" : 115
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 61,
        "startLineNumber" : 195,
        "startColumnNumber" : 65,
        "endLineNumber" : 195,
        "endColumnNumber" : 126
      },
      "nodeContext" : "new AbstractExecutionSource(dataContainer,context,consumer)",
      "nodeType" : "ClassInstanceCreation",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 78,
        "startLineNumber" : 195,
        "startColumnNumber" : 48,
        "endLineNumber" : 195,
        "endColumnNumber" : 126
      },
      "nodeContext" : "transferSource=new AbstractExecutionSource(dataContainer,context,consumer)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 8,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 103,
        "startLineNumber" : 195,
        "startColumnNumber" : 24,
        "endLineNumber" : 195,
        "endColumnNumber" : 127
      },
      "nodeContext" : "AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 4036,
        "startLineNumber" : 194,
        "startColumnNumber" : 24,
        "endLineNumber" : 259,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n  session.enableLogging(false);\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    try {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions()) {\n        oldAutoCommit=txnManager.isAutoCommit();\n        txnManager.setAutoCommit(monitor,false);\n      }\n    }\n catch (    DBCException e) {\n      log.warn(\"Can't change auto-commit\",e);\n    }\n  }\n  long totalRows=0;\n  if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n    try {\n      totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n    }\n catch (    Throwable e) {\n      log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n        if (txnManager != null && !txnManager.isAutoCommit()) {\n          txnManager.rollback(session,null);\n        }\n      }\n catch (      Throwable e1) {\n        log.warn(\"Error rolling back transaction\",e1);\n      }\n    }\n finally {\n      monitor.done();\n    }\n  }\n  monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n  try {\n    monitor.subTask(\"Read data\");\n    if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n      dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n    }\n else {\n      long offset=0;\n      int segmentSize=settings.getSegmentSize();\n      for (; ; ) {\n        DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n        if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n          break;\n        }\n        offset+=statistics.getRowsFetched();\n      }\n    }\n  }\n  finally {\n    monitor.done();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 274,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5352,
        "startLineNumber" : 194,
        "startColumnNumber" : 20,
        "endLineNumber" : 280,
        "endColumnNumber" : 21
      },
      "nodeContext" : "try {\n  AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n  session.enableLogging(false);\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    try {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions()) {\n        oldAutoCommit=txnManager.isAutoCommit();\n        txnManager.setAutoCommit(monitor,false);\n      }\n    }\n catch (    DBCException e) {\n      log.warn(\"Can't change auto-commit\",e);\n    }\n  }\n  long totalRows=0;\n  if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n    try {\n      totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n    }\n catch (    Throwable e) {\n      log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n        if (txnManager != null && !txnManager.isAutoCommit()) {\n          txnManager.rollback(session,null);\n        }\n      }\n catch (      Throwable e1) {\n        log.warn(\"Error rolling back transaction\",e1);\n      }\n    }\n finally {\n      monitor.done();\n    }\n  }\n  monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n  try {\n    monitor.subTask(\"Read data\");\n    if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n      dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n    }\n else {\n      long offset=0;\n      int segmentSize=settings.getSegmentSize();\n      for (; ; ) {\n        DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n        if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n          break;\n        }\n        offset+=statistics.getRowsFetched();\n      }\n    }\n  }\n  finally {\n    monitor.done();\n  }\n}\n  finally {\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n    if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n      try {\n        txnManager.commit(session);\n      }\n catch (      Exception e) {\n        log.error(\"Can't finish transaction in data producer connection\",e);\n      }\n      if (oldAutoCommit != null) {\n        try {\n          txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n      }\n    }\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context.close();\n  }\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 364,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 5442,
        "startLineNumber" : 192,
        "startColumnNumber" : 111,
        "endLineNumber" : 281,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  Boolean oldAutoCommit=null;\n  try {\n    AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n    session.enableLogging(false);\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions()) {\n          oldAutoCommit=txnManager.isAutoCommit();\n          txnManager.setAutoCommit(monitor,false);\n        }\n      }\n catch (      DBCException e) {\n        log.warn(\"Can't change auto-commit\",e);\n      }\n    }\n    long totalRows=0;\n    if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n      try {\n        totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n      }\n catch (      Throwable e) {\n        log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n          if (txnManager != null && !txnManager.isAutoCommit()) {\n            txnManager.rollback(session,null);\n          }\n        }\n catch (        Throwable e1) {\n          log.warn(\"Error rolling back transaction\",e1);\n        }\n      }\n finally {\n        monitor.done();\n      }\n    }\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n    try {\n      monitor.subTask(\"Read data\");\n      if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n        dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n      }\n else {\n        long offset=0;\n        int segmentSize=settings.getSegmentSize();\n        for (; ; ) {\n          DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n          if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n            break;\n          }\n          offset+=statistics.getRowsFetched();\n        }\n      }\n    }\n  finally {\n      monitor.done();\n    }\n  }\n  finally {\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n        try {\n          txnManager.commit(session);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n        if (oldAutoCommit != null) {\n          try {\n            txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n        }\n      }\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context.close();\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 371,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5537,
        "startLineNumber" : 192,
        "startColumnNumber" : 16,
        "endLineNumber" : 281,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n  Boolean oldAutoCommit=null;\n  try {\n    AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n    session.enableLogging(false);\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions()) {\n          oldAutoCommit=txnManager.isAutoCommit();\n          txnManager.setAutoCommit(monitor,false);\n        }\n      }\n catch (      DBCException e) {\n        log.warn(\"Can't change auto-commit\",e);\n      }\n    }\n    long totalRows=0;\n    if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n      try {\n        totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n      }\n catch (      Throwable e) {\n        log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n          if (txnManager != null && !txnManager.isAutoCommit()) {\n            txnManager.rollback(session,null);\n          }\n        }\n catch (        Throwable e1) {\n          log.warn(\"Error rolling back transaction\",e1);\n        }\n      }\n finally {\n        monitor.done();\n      }\n    }\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n    try {\n      monitor.subTask(\"Read data\");\n      if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n        dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n      }\n else {\n        long offset=0;\n        int segmentSize=settings.getSegmentSize();\n        for (; ; ) {\n          DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n          if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n            break;\n          }\n          offset+=statistics.getRowsFetched();\n        }\n      }\n    }\n  finally {\n      monitor.done();\n    }\n  }\n  finally {\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n        try {\n          txnManager.commit(session);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n        if (oldAutoCommit != null) {\n          try {\n            txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n        }\n      }\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context.close();\n    }\n  }\n}\n ",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 385,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 6551,
        "startLineNumber" : 174,
        "startColumnNumber" : 16,
        "endLineNumber" : 282,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n",
      "nodeType" : "Block",
      "astNodeNumber" : 469,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6649,
        "startLineNumber" : 174,
        "startColumnNumber" : 12,
        "endLineNumber" : 284,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n catch (DBException e) {\n  throw new InvocationTargetException(e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 481,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
      "nodePosition" : {
        "charLength" : 7412,
        "startLineNumber" : 161,
        "startColumnNumber" : 71,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 556,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 7423,
        "startLineNumber" : 161,
        "startColumnNumber" : 60,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "monitor -> {\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "LambdaExpression",
      "astNodeNumber" : 559,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 103,
        "startLineNumber" : 195,
        "startColumnNumber" : 24,
        "endLineNumber" : 195,
        "endColumnNumber" : 127
      },
      "nodeContext" : "AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 11,
      "astHeight" : 5
    },
    "tokenLength" : 1,
    "type" : "org.jkiss.dbeaver.model.exec.DBCExecutionContext"
  }, {
    "nodeContext" : "context",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 202,
      "startColumnNumber" : 97,
      "endLineNumber" : 202,
      "endColumnNumber" : 104
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 202,
        "startColumnNumber" : 67,
        "endLineNumber" : 202,
        "endColumnNumber" : 105
      },
      "nodeContext" : "DBUtils.getTransactionManager(context)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 202,
        "startColumnNumber" : 54,
        "endLineNumber" : 202,
        "endColumnNumber" : 105
      },
      "nodeContext" : "txnManager=DBUtils.getTransactionManager(context)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 74,
        "startLineNumber" : 202,
        "startColumnNumber" : 32,
        "endLineNumber" : 202,
        "endColumnNumber" : 106
      },
      "nodeContext" : "DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 426,
        "startLineNumber" : 201,
        "startColumnNumber" : 32,
        "endLineNumber" : 207,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n  if (txnManager != null && txnManager.isSupportsTransactions()) {\n    oldAutoCommit=txnManager.isAutoCommit();\n    txnManager.setAutoCommit(monitor,false);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 31,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 558,
        "startLineNumber" : 201,
        "startColumnNumber" : 28,
        "endLineNumber" : 209,
        "endColumnNumber" : 29
      },
      "nodeContext" : "try {\n  DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n  if (txnManager != null && txnManager.isSupportsTransactions()) {\n    oldAutoCommit=txnManager.isAutoCommit();\n    txnManager.setAutoCommit(monitor,false);\n  }\n}\n catch (DBCException e) {\n  log.warn(\"Can't change auto-commit\",e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 44,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 872,
        "startLineNumber" : 197,
        "startColumnNumber" : 100,
        "endLineNumber" : 211,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  try {\n    DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n    if (txnManager != null && txnManager.isSupportsTransactions()) {\n      oldAutoCommit=txnManager.isAutoCommit();\n      txnManager.setAutoCommit(monitor,false);\n    }\n  }\n catch (  DBCException e) {\n    log.warn(\"Can't change auto-commit\",e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 45,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 948,
        "startLineNumber" : 197,
        "startColumnNumber" : 24,
        "endLineNumber" : 211,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n  try {\n    DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n    if (txnManager != null && txnManager.isSupportsTransactions()) {\n      oldAutoCommit=txnManager.isAutoCommit();\n      txnManager.setAutoCommit(monitor,false);\n    }\n  }\n catch (  DBCException e) {\n    log.warn(\"Can't change auto-commit\",e);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 53,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 4036,
        "startLineNumber" : 194,
        "startColumnNumber" : 24,
        "endLineNumber" : 259,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n  session.enableLogging(false);\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    try {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions()) {\n        oldAutoCommit=txnManager.isAutoCommit();\n        txnManager.setAutoCommit(monitor,false);\n      }\n    }\n catch (    DBCException e) {\n      log.warn(\"Can't change auto-commit\",e);\n    }\n  }\n  long totalRows=0;\n  if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n    try {\n      totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n    }\n catch (    Throwable e) {\n      log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n        if (txnManager != null && !txnManager.isAutoCommit()) {\n          txnManager.rollback(session,null);\n        }\n      }\n catch (      Throwable e1) {\n        log.warn(\"Error rolling back transaction\",e1);\n      }\n    }\n finally {\n      monitor.done();\n    }\n  }\n  monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n  try {\n    monitor.subTask(\"Read data\");\n    if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n      dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n    }\n else {\n      long offset=0;\n      int segmentSize=settings.getSegmentSize();\n      for (; ; ) {\n        DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n        if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n          break;\n        }\n        offset+=statistics.getRowsFetched();\n      }\n    }\n  }\n  finally {\n    monitor.done();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 274,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5352,
        "startLineNumber" : 194,
        "startColumnNumber" : 20,
        "endLineNumber" : 280,
        "endColumnNumber" : 21
      },
      "nodeContext" : "try {\n  AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n  session.enableLogging(false);\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    try {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions()) {\n        oldAutoCommit=txnManager.isAutoCommit();\n        txnManager.setAutoCommit(monitor,false);\n      }\n    }\n catch (    DBCException e) {\n      log.warn(\"Can't change auto-commit\",e);\n    }\n  }\n  long totalRows=0;\n  if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n    try {\n      totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n    }\n catch (    Throwable e) {\n      log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n        if (txnManager != null && !txnManager.isAutoCommit()) {\n          txnManager.rollback(session,null);\n        }\n      }\n catch (      Throwable e1) {\n        log.warn(\"Error rolling back transaction\",e1);\n      }\n    }\n finally {\n      monitor.done();\n    }\n  }\n  monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n  try {\n    monitor.subTask(\"Read data\");\n    if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n      dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n    }\n else {\n      long offset=0;\n      int segmentSize=settings.getSegmentSize();\n      for (; ; ) {\n        DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n        if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n          break;\n        }\n        offset+=statistics.getRowsFetched();\n      }\n    }\n  }\n  finally {\n    monitor.done();\n  }\n}\n  finally {\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n    if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n      try {\n        txnManager.commit(session);\n      }\n catch (      Exception e) {\n        log.error(\"Can't finish transaction in data producer connection\",e);\n      }\n      if (oldAutoCommit != null) {\n        try {\n          txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n      }\n    }\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context.close();\n  }\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 364,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 5442,
        "startLineNumber" : 192,
        "startColumnNumber" : 111,
        "endLineNumber" : 281,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  Boolean oldAutoCommit=null;\n  try {\n    AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n    session.enableLogging(false);\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions()) {\n          oldAutoCommit=txnManager.isAutoCommit();\n          txnManager.setAutoCommit(monitor,false);\n        }\n      }\n catch (      DBCException e) {\n        log.warn(\"Can't change auto-commit\",e);\n      }\n    }\n    long totalRows=0;\n    if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n      try {\n        totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n      }\n catch (      Throwable e) {\n        log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n          if (txnManager != null && !txnManager.isAutoCommit()) {\n            txnManager.rollback(session,null);\n          }\n        }\n catch (        Throwable e1) {\n          log.warn(\"Error rolling back transaction\",e1);\n        }\n      }\n finally {\n        monitor.done();\n      }\n    }\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n    try {\n      monitor.subTask(\"Read data\");\n      if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n        dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n      }\n else {\n        long offset=0;\n        int segmentSize=settings.getSegmentSize();\n        for (; ; ) {\n          DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n          if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n            break;\n          }\n          offset+=statistics.getRowsFetched();\n        }\n      }\n    }\n  finally {\n      monitor.done();\n    }\n  }\n  finally {\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n        try {\n          txnManager.commit(session);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n        if (oldAutoCommit != null) {\n          try {\n            txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n        }\n      }\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context.close();\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 371,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5537,
        "startLineNumber" : 192,
        "startColumnNumber" : 16,
        "endLineNumber" : 281,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n  Boolean oldAutoCommit=null;\n  try {\n    AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n    session.enableLogging(false);\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions()) {\n          oldAutoCommit=txnManager.isAutoCommit();\n          txnManager.setAutoCommit(monitor,false);\n        }\n      }\n catch (      DBCException e) {\n        log.warn(\"Can't change auto-commit\",e);\n      }\n    }\n    long totalRows=0;\n    if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n      try {\n        totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n      }\n catch (      Throwable e) {\n        log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n          if (txnManager != null && !txnManager.isAutoCommit()) {\n            txnManager.rollback(session,null);\n          }\n        }\n catch (        Throwable e1) {\n          log.warn(\"Error rolling back transaction\",e1);\n        }\n      }\n finally {\n        monitor.done();\n      }\n    }\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n    try {\n      monitor.subTask(\"Read data\");\n      if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n        dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n      }\n else {\n        long offset=0;\n        int segmentSize=settings.getSegmentSize();\n        for (; ; ) {\n          DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n          if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n            break;\n          }\n          offset+=statistics.getRowsFetched();\n        }\n      }\n    }\n  finally {\n      monitor.done();\n    }\n  }\n  finally {\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n        try {\n          txnManager.commit(session);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n        if (oldAutoCommit != null) {\n          try {\n            txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n        }\n      }\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context.close();\n    }\n  }\n}\n ",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 385,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 6551,
        "startLineNumber" : 174,
        "startColumnNumber" : 16,
        "endLineNumber" : 282,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n",
      "nodeType" : "Block",
      "astNodeNumber" : 469,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6649,
        "startLineNumber" : 174,
        "startColumnNumber" : 12,
        "endLineNumber" : 284,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n catch (DBException e) {\n  throw new InvocationTargetException(e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 481,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
      "nodePosition" : {
        "charLength" : 7412,
        "startLineNumber" : 161,
        "startColumnNumber" : 71,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 556,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 7423,
        "startLineNumber" : 161,
        "startColumnNumber" : 60,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "monitor -> {\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "LambdaExpression",
      "astNodeNumber" : 559,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 74,
        "startLineNumber" : 202,
        "startColumnNumber" : 32,
        "endLineNumber" : 202,
        "endColumnNumber" : 106
      },
      "nodeContext" : "DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "org.jkiss.dbeaver.model.exec.DBCExecutionContext"
  }, {
    "nodeContext" : "context",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 261,
      "startColumnNumber" : 93,
      "endLineNumber" : 261,
      "endColumnNumber" : 100
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.VariableDeclarationFragment,initializer]",
      "nodePosition" : {
        "charLength" : 38,
        "startLineNumber" : 261,
        "startColumnNumber" : 63,
        "endLineNumber" : 261,
        "endColumnNumber" : 101
      },
      "nodeContext" : "DBUtils.getTransactionManager(context)",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 4,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.VariableDeclarationStatement,fragments]",
      "nodePosition" : {
        "charLength" : 51,
        "startLineNumber" : 261,
        "startColumnNumber" : 50,
        "endLineNumber" : 261,
        "endColumnNumber" : 101
      },
      "nodeContext" : "txnManager=DBUtils.getTransactionManager(context)",
      "nodeType" : "VariableDeclarationFragment",
      "astNodeNumber" : 6,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 74,
        "startLineNumber" : 261,
        "startColumnNumber" : 28,
        "endLineNumber" : 261,
        "endColumnNumber" : 102
      },
      "nodeContext" : "DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 1037,
        "startLineNumber" : 260,
        "startColumnNumber" : 100,
        "endLineNumber" : 276,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n  if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n    try {\n      txnManager.commit(session);\n    }\n catch (    Exception e) {\n      log.error(\"Can't finish transaction in data producer connection\",e);\n    }\n    if (oldAutoCommit != null) {\n      try {\n        txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n      }\n catch (      Exception e) {\n        log.error(\"Can't finish transaction in data producer connection\",e);\n      }\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 70,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1113,
        "startLineNumber" : 260,
        "startColumnNumber" : 24,
        "endLineNumber" : 276,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n  DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n  if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n    try {\n      txnManager.commit(session);\n    }\n catch (    Exception e) {\n      log.error(\"Can't finish transaction in data producer connection\",e);\n    }\n    if (oldAutoCommit != null) {\n      try {\n        txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n      }\n catch (      Exception e) {\n        log.error(\"Can't finish transaction in data producer connection\",e);\n      }\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 78,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,finally]",
      "nodePosition" : {
        "charLength" : 1303,
        "startLineNumber" : 259,
        "startColumnNumber" : 30,
        "endLineNumber" : 280,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n    if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n      try {\n        txnManager.commit(session);\n      }\n catch (      Exception e) {\n        log.error(\"Can't finish transaction in data producer connection\",e);\n      }\n      if (oldAutoCommit != null) {\n        try {\n          txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n      }\n    }\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context.close();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 89,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5352,
        "startLineNumber" : 194,
        "startColumnNumber" : 20,
        "endLineNumber" : 280,
        "endColumnNumber" : 21
      },
      "nodeContext" : "try {\n  AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n  session.enableLogging(false);\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    try {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions()) {\n        oldAutoCommit=txnManager.isAutoCommit();\n        txnManager.setAutoCommit(monitor,false);\n      }\n    }\n catch (    DBCException e) {\n      log.warn(\"Can't change auto-commit\",e);\n    }\n  }\n  long totalRows=0;\n  if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n    try {\n      totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n    }\n catch (    Throwable e) {\n      log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n        if (txnManager != null && !txnManager.isAutoCommit()) {\n          txnManager.rollback(session,null);\n        }\n      }\n catch (      Throwable e1) {\n        log.warn(\"Error rolling back transaction\",e1);\n      }\n    }\n finally {\n      monitor.done();\n    }\n  }\n  monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n  try {\n    monitor.subTask(\"Read data\");\n    if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n      dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n    }\n else {\n      long offset=0;\n      int segmentSize=settings.getSegmentSize();\n      for (; ; ) {\n        DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n        if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n          break;\n        }\n        offset+=statistics.getRowsFetched();\n      }\n    }\n  }\n  finally {\n    monitor.done();\n  }\n}\n  finally {\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n    if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n      try {\n        txnManager.commit(session);\n      }\n catch (      Exception e) {\n        log.error(\"Can't finish transaction in data producer connection\",e);\n      }\n      if (oldAutoCommit != null) {\n        try {\n          txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n      }\n    }\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context.close();\n  }\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 364,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 5442,
        "startLineNumber" : 192,
        "startColumnNumber" : 111,
        "endLineNumber" : 281,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  Boolean oldAutoCommit=null;\n  try {\n    AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n    session.enableLogging(false);\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions()) {\n          oldAutoCommit=txnManager.isAutoCommit();\n          txnManager.setAutoCommit(monitor,false);\n        }\n      }\n catch (      DBCException e) {\n        log.warn(\"Can't change auto-commit\",e);\n      }\n    }\n    long totalRows=0;\n    if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n      try {\n        totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n      }\n catch (      Throwable e) {\n        log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n          if (txnManager != null && !txnManager.isAutoCommit()) {\n            txnManager.rollback(session,null);\n          }\n        }\n catch (        Throwable e1) {\n          log.warn(\"Error rolling back transaction\",e1);\n        }\n      }\n finally {\n        monitor.done();\n      }\n    }\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n    try {\n      monitor.subTask(\"Read data\");\n      if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n        dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n      }\n else {\n        long offset=0;\n        int segmentSize=settings.getSegmentSize();\n        for (; ; ) {\n          DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n          if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n            break;\n          }\n          offset+=statistics.getRowsFetched();\n        }\n      }\n    }\n  finally {\n      monitor.done();\n    }\n  }\n  finally {\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n        try {\n          txnManager.commit(session);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n        if (oldAutoCommit != null) {\n          try {\n            txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n        }\n      }\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context.close();\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 371,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5537,
        "startLineNumber" : 192,
        "startColumnNumber" : 16,
        "endLineNumber" : 281,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n  Boolean oldAutoCommit=null;\n  try {\n    AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n    session.enableLogging(false);\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions()) {\n          oldAutoCommit=txnManager.isAutoCommit();\n          txnManager.setAutoCommit(monitor,false);\n        }\n      }\n catch (      DBCException e) {\n        log.warn(\"Can't change auto-commit\",e);\n      }\n    }\n    long totalRows=0;\n    if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n      try {\n        totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n      }\n catch (      Throwable e) {\n        log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n          if (txnManager != null && !txnManager.isAutoCommit()) {\n            txnManager.rollback(session,null);\n          }\n        }\n catch (        Throwable e1) {\n          log.warn(\"Error rolling back transaction\",e1);\n        }\n      }\n finally {\n        monitor.done();\n      }\n    }\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n    try {\n      monitor.subTask(\"Read data\");\n      if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n        dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n      }\n else {\n        long offset=0;\n        int segmentSize=settings.getSegmentSize();\n        for (; ; ) {\n          DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n          if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n            break;\n          }\n          offset+=statistics.getRowsFetched();\n        }\n      }\n    }\n  finally {\n      monitor.done();\n    }\n  }\n  finally {\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n        try {\n          txnManager.commit(session);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n        if (oldAutoCommit != null) {\n          try {\n            txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n        }\n      }\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context.close();\n    }\n  }\n}\n ",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 385,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 6551,
        "startLineNumber" : 174,
        "startColumnNumber" : 16,
        "endLineNumber" : 282,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n",
      "nodeType" : "Block",
      "astNodeNumber" : 469,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6649,
        "startLineNumber" : 174,
        "startColumnNumber" : 12,
        "endLineNumber" : 284,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n catch (DBException e) {\n  throw new InvocationTargetException(e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 481,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
      "nodePosition" : {
        "charLength" : 7412,
        "startLineNumber" : 161,
        "startColumnNumber" : 71,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 556,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 7423,
        "startLineNumber" : 161,
        "startColumnNumber" : 60,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "monitor -> {\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "LambdaExpression",
      "astNodeNumber" : 559,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 74,
        "startLineNumber" : 261,
        "startColumnNumber" : 28,
        "endLineNumber" : 261,
        "endColumnNumber" : 102
      },
      "nodeContext" : "DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n",
      "nodeType" : "VariableDeclarationStatement",
      "astNodeNumber" : 9,
      "astHeight" : 4
    },
    "tokenLength" : 1,
    "type" : "org.jkiss.dbeaver.model.exec.DBCExecutionContext"
  }, {
    "nodeContext" : "context",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 7,
      "startLineNumber" : 278,
      "startColumnNumber" : 28,
      "endLineNumber" : 278,
      "endColumnNumber" : 35
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 15,
        "startLineNumber" : 278,
        "startColumnNumber" : 28,
        "endLineNumber" : 278,
        "endColumnNumber" : 43
      },
      "nodeContext" : "context.close()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 16,
        "startLineNumber" : 278,
        "startColumnNumber" : 28,
        "endLineNumber" : 278,
        "endColumnNumber" : 44
      },
      "nodeContext" : "context.close();\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 4,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 72,
        "startLineNumber" : 277,
        "startColumnNumber" : 69,
        "endLineNumber" : 279,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  context.close();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 5,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 117,
        "startLineNumber" : 277,
        "startColumnNumber" : 24,
        "endLineNumber" : 279,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (!selectiveExportFromUI && newConnection) {\n  context.close();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,finally]",
      "nodePosition" : {
        "charLength" : 1303,
        "startLineNumber" : 259,
        "startColumnNumber" : 30,
        "endLineNumber" : 280,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n    if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n      try {\n        txnManager.commit(session);\n      }\n catch (      Exception e) {\n        log.error(\"Can't finish transaction in data producer connection\",e);\n      }\n      if (oldAutoCommit != null) {\n        try {\n          txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n      }\n    }\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context.close();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 89,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5352,
        "startLineNumber" : 194,
        "startColumnNumber" : 20,
        "endLineNumber" : 280,
        "endColumnNumber" : 21
      },
      "nodeContext" : "try {\n  AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n  session.enableLogging(false);\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    try {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions()) {\n        oldAutoCommit=txnManager.isAutoCommit();\n        txnManager.setAutoCommit(monitor,false);\n      }\n    }\n catch (    DBCException e) {\n      log.warn(\"Can't change auto-commit\",e);\n    }\n  }\n  long totalRows=0;\n  if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n    try {\n      totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n    }\n catch (    Throwable e) {\n      log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n        if (txnManager != null && !txnManager.isAutoCommit()) {\n          txnManager.rollback(session,null);\n        }\n      }\n catch (      Throwable e1) {\n        log.warn(\"Error rolling back transaction\",e1);\n      }\n    }\n finally {\n      monitor.done();\n    }\n  }\n  monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n  try {\n    monitor.subTask(\"Read data\");\n    if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n      dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n    }\n else {\n      long offset=0;\n      int segmentSize=settings.getSegmentSize();\n      for (; ; ) {\n        DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n        if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n          break;\n        }\n        offset+=statistics.getRowsFetched();\n      }\n    }\n  }\n  finally {\n    monitor.done();\n  }\n}\n  finally {\n  if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n    DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n    if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n      try {\n        txnManager.commit(session);\n      }\n catch (      Exception e) {\n        log.error(\"Can't finish transaction in data producer connection\",e);\n      }\n      if (oldAutoCommit != null) {\n        try {\n          txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n      }\n    }\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context.close();\n  }\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 364,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 5442,
        "startLineNumber" : 192,
        "startColumnNumber" : 111,
        "endLineNumber" : 281,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  Boolean oldAutoCommit=null;\n  try {\n    AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n    session.enableLogging(false);\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions()) {\n          oldAutoCommit=txnManager.isAutoCommit();\n          txnManager.setAutoCommit(monitor,false);\n        }\n      }\n catch (      DBCException e) {\n        log.warn(\"Can't change auto-commit\",e);\n      }\n    }\n    long totalRows=0;\n    if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n      try {\n        totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n      }\n catch (      Throwable e) {\n        log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n          if (txnManager != null && !txnManager.isAutoCommit()) {\n            txnManager.rollback(session,null);\n          }\n        }\n catch (        Throwable e1) {\n          log.warn(\"Error rolling back transaction\",e1);\n        }\n      }\n finally {\n        monitor.done();\n      }\n    }\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n    try {\n      monitor.subTask(\"Read data\");\n      if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n        dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n      }\n else {\n        long offset=0;\n        int segmentSize=settings.getSegmentSize();\n        for (; ; ) {\n          DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n          if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n            break;\n          }\n          offset+=statistics.getRowsFetched();\n        }\n      }\n    }\n  finally {\n      monitor.done();\n    }\n  }\n  finally {\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n        try {\n          txnManager.commit(session);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n        if (oldAutoCommit != null) {\n          try {\n            txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n        }\n      }\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context.close();\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 371,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5537,
        "startLineNumber" : 192,
        "startColumnNumber" : 16,
        "endLineNumber" : 281,
        "endColumnNumber" : 17
      },
      "nodeContext" : "try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n  Boolean oldAutoCommit=null;\n  try {\n    AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n    session.enableLogging(false);\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      try {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions()) {\n          oldAutoCommit=txnManager.isAutoCommit();\n          txnManager.setAutoCommit(monitor,false);\n        }\n      }\n catch (      DBCException e) {\n        log.warn(\"Can't change auto-commit\",e);\n      }\n    }\n    long totalRows=0;\n    if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n      try {\n        totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n      }\n catch (      Throwable e) {\n        log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n          if (txnManager != null && !txnManager.isAutoCommit()) {\n            txnManager.rollback(session,null);\n          }\n        }\n catch (        Throwable e1) {\n          log.warn(\"Error rolling back transaction\",e1);\n        }\n      }\n finally {\n        monitor.done();\n      }\n    }\n    monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n    try {\n      monitor.subTask(\"Read data\");\n      if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n        dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n      }\n else {\n        long offset=0;\n        int segmentSize=settings.getSegmentSize();\n        for (; ; ) {\n          DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n          if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n            break;\n          }\n          offset+=statistics.getRowsFetched();\n        }\n      }\n    }\n  finally {\n      monitor.done();\n    }\n  }\n  finally {\n    if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n      DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n      if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n        try {\n          txnManager.commit(session);\n        }\n catch (        Exception e) {\n          log.error(\"Can't finish transaction in data producer connection\",e);\n        }\n        if (oldAutoCommit != null) {\n          try {\n            txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n        }\n      }\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context.close();\n    }\n  }\n}\n ",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 385,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 6551,
        "startLineNumber" : 174,
        "startColumnNumber" : 16,
        "endLineNumber" : 282,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n",
      "nodeType" : "Block",
      "astNodeNumber" : 469,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 6649,
        "startLineNumber" : 174,
        "startColumnNumber" : 12,
        "endLineNumber" : 284,
        "endColumnNumber" : 13
      },
      "nodeContext" : "try {\n  DBCExecutionContext context;\n  if (dataContainer instanceof DBPContextProvider) {\n    context=((DBPContextProvider)dataContainer).getExecutionContext();\n  }\n else {\n    context=DBUtils.getDefaultContext(dataContainer,false);\n  }\n  if (context == null) {\n    throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n  }\n  if (!selectiveExportFromUI && newConnection) {\n    context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n    DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n  }\n  if (task != null) {\n    DBTaskUtils.initFromContext(monitor,task,context);\n  }\n  try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n    Boolean oldAutoCommit=null;\n    try {\n      AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n      session.enableLogging(false);\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        try {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions()) {\n            oldAutoCommit=txnManager.isAutoCommit();\n            txnManager.setAutoCommit(monitor,false);\n          }\n        }\n catch (        DBCException e) {\n          log.warn(\"Can't change auto-commit\",e);\n        }\n      }\n      long totalRows=0;\n      if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n        try {\n          totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n        }\n catch (        Throwable e) {\n          log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n            if (txnManager != null && !txnManager.isAutoCommit()) {\n              txnManager.rollback(session,null);\n            }\n          }\n catch (          Throwable e1) {\n            log.warn(\"Error rolling back transaction\",e1);\n          }\n        }\n finally {\n          monitor.done();\n        }\n      }\n      monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n      try {\n        monitor.subTask(\"Read data\");\n        if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n          dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n        }\n else {\n          long offset=0;\n          int segmentSize=settings.getSegmentSize();\n          for (; ; ) {\n            DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n            if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n              break;\n            }\n            offset+=statistics.getRowsFetched();\n          }\n        }\n      }\n  finally {\n        monitor.done();\n      }\n    }\n  finally {\n      if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n        DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n        if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n          try {\n            txnManager.commit(session);\n          }\n catch (          Exception e) {\n            log.error(\"Can't finish transaction in data producer connection\",e);\n          }\n          if (oldAutoCommit != null) {\n            try {\n              txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n          }\n        }\n      }\n      if (!selectiveExportFromUI && newConnection) {\n        context.close();\n      }\n    }\n  }\n }\n catch (DBException e) {\n  throw new InvocationTargetException(e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 481,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.LambdaExpression,body]",
      "nodePosition" : {
        "charLength" : 7412,
        "startLineNumber" : 161,
        "startColumnNumber" : 71,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 556,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.MethodInvocation,arguments]",
      "nodePosition" : {
        "charLength" : 7423,
        "startLineNumber" : 161,
        "startColumnNumber" : 60,
        "endLineNumber" : 285,
        "endColumnNumber" : 9
      },
      "nodeContext" : "monitor -> {\n  long readFlags=DBSDataContainer.FLAG_NONE;\n  if (settings.isSelectedColumnsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_COLUMNS;\n  }\n  if (settings.isSelectedRowsOnly()) {\n    readFlags|=DBSDataContainer.FLAG_USE_SELECTED_ROWS;\n  }\n  boolean newConnection=settings.isOpenNewConnections() && !getDatabaseObject().getDataSource().getContainer().getDriver().isEmbedded();\n  boolean forceDataReadTransactions=Boolean.TRUE.equals(dataSource.getDataSourceFeature(DBConstants.FEATURE_LOB_REQUIRE_TRANSACTIONS));\n  boolean selectiveExportFromUI=settings.isSelectedColumnsOnly() || settings.isSelectedRowsOnly();\n  try {\n    DBCExecutionContext context;\n    if (dataContainer instanceof DBPContextProvider) {\n      context=((DBPContextProvider)dataContainer).getExecutionContext();\n    }\n else {\n      context=DBUtils.getDefaultContext(dataContainer,false);\n    }\n    if (context == null) {\n      throw new DBCException(\"Can't retrieve execution context from data container \" + dataContainer);\n    }\n    if (!selectiveExportFromUI && newConnection) {\n      context=DBUtils.getObjectOwnerInstance(getDatabaseObject()).openIsolatedContext(monitor,\"Data transfer producer\",context);\n      DBExecUtils.setExecutionContextDefaults(monitor,dataSource,context,defaultCatalog,null,defaultSchema);\n    }\n    if (task != null) {\n      DBTaskUtils.initFromContext(monitor,task,context);\n    }\n    try (DBCSession session=context.openSession(monitor,DBCExecutionPurpose.UTIL,contextTask)){\n      Boolean oldAutoCommit=null;\n      try {\n        AbstractExecutionSource transferSource=new AbstractExecutionSource(dataContainer,context,consumer);\n        session.enableLogging(false);\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          try {\n            DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n            if (txnManager != null && txnManager.isSupportsTransactions()) {\n              oldAutoCommit=txnManager.isAutoCommit();\n              txnManager.setAutoCommit(monitor,false);\n            }\n          }\n catch (          DBCException e) {\n            log.warn(\"Can't change auto-commit\",e);\n          }\n        }\n        long totalRows=0;\n        if (settings.isQueryRowCount() && (dataContainer.getSupportedFeatures() & DBSDataContainer.DATA_COUNT) != 0) {\n          monitor.beginTask(DTMessages.data_transfer_wizard_job_task_retrieve,1);\n          try {\n            totalRows=dataContainer.countData(transferSource,session,dataFilter,readFlags);\n          }\n catch (          Throwable e) {\n            log.warn(\"Can't retrieve row count from '\" + dataContainer.getName() + \"'\",e);\n            try {\n              DBCTransactionManager txnManager=DBUtils.getTransactionManager(session.getExecutionContext());\n              if (txnManager != null && !txnManager.isAutoCommit()) {\n                txnManager.rollback(session,null);\n              }\n            }\n catch (            Throwable e1) {\n              log.warn(\"Error rolling back transaction\",e1);\n            }\n          }\n finally {\n            monitor.done();\n          }\n        }\n        monitor.beginTask(DTMessages.data_transfer_wizard_job_task_export_table_data,(int)totalRows);\n        try {\n          monitor.subTask(\"Read data\");\n          if (settings.getExtractType() == DatabaseProducerSettings.ExtractType.SINGLE_QUERY) {\n            dataContainer.readData(transferSource,session,consumer,dataFilter,-1,-1,readFlags,settings.getFetchSize());\n          }\n else {\n            long offset=0;\n            int segmentSize=settings.getSegmentSize();\n            for (; ; ) {\n              DBCStatistics statistics=dataContainer.readData(transferSource,session,consumer,dataFilter,offset,segmentSize,readFlags,settings.getFetchSize());\n              if (statistics == null || statistics.getRowsFetched() < segmentSize) {\n                break;\n              }\n              offset+=statistics.getRowsFetched();\n            }\n          }\n        }\n  finally {\n          monitor.done();\n        }\n      }\n  finally {\n        if (!selectiveExportFromUI && (newConnection || forceDataReadTransactions)) {\n          DBCTransactionManager txnManager=DBUtils.getTransactionManager(context);\n          if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {\n            try {\n              txnManager.commit(session);\n            }\n catch (            Exception e) {\n              log.error(\"Can't finish transaction in data producer connection\",e);\n            }\n            if (oldAutoCommit != null) {\n              try {\n                txnManager.setAutoCommit(session.getProgressMonitor(),oldAutoCommit);\n              }\n catch (              Exception e) {\n                log.error(\"Can't finish transaction in data producer connection\",e);\n              }\n            }\n          }\n        }\n        if (!selectiveExportFromUI && newConnection) {\n          context.close();\n        }\n      }\n    }\n   }\n catch (  DBException e) {\n    throw new InvocationTargetException(e);\n  }\n}\n",
      "nodeType" : "LambdaExpression",
      "astNodeNumber" : 559,
      "astHeight" : 20
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 16,
        "startLineNumber" : 278,
        "startColumnNumber" : 28,
        "endLineNumber" : 278,
        "endColumnNumber" : 44
      },
      "nodeContext" : "context.close();\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 4,
      "astHeight" : 3
    },
    "tokenLength" : 1,
    "type" : "org.jkiss.dbeaver.model.exec.DBCExecutionContext"
  } ],
  "positionList" : [ {
    "charLength" : 7,
    "startLineNumber" : 181,
    "startColumnNumber" : 20,
    "endLineNumber" : 181,
    "endColumnNumber" : 27
  }, {
    "charLength" : 7,
    "startLineNumber" : 185,
    "startColumnNumber" : 137,
    "endLineNumber" : 185,
    "endColumnNumber" : 144
  }, {
    "charLength" : 7,
    "startLineNumber" : 186,
    "startColumnNumber" : 81,
    "endLineNumber" : 186,
    "endColumnNumber" : 88
  }, {
    "charLength" : 7,
    "startLineNumber" : 189,
    "startColumnNumber" : 63,
    "endLineNumber" : 189,
    "endColumnNumber" : 70
  }, {
    "charLength" : 7,
    "startLineNumber" : 192,
    "startColumnNumber" : 42,
    "endLineNumber" : 192,
    "endColumnNumber" : 49
  }, {
    "charLength" : 7,
    "startLineNumber" : 195,
    "startColumnNumber" : 108,
    "endLineNumber" : 195,
    "endColumnNumber" : 115
  }, {
    "charLength" : 7,
    "startLineNumber" : 202,
    "startColumnNumber" : 97,
    "endLineNumber" : 202,
    "endColumnNumber" : 104
  }, {
    "charLength" : 7,
    "startLineNumber" : 261,
    "startColumnNumber" : 93,
    "endLineNumber" : 261,
    "endColumnNumber" : 100
  }, {
    "charLength" : 7,
    "startLineNumber" : 278,
    "startColumnNumber" : 28,
    "endLineNumber" : 278,
    "endColumnNumber" : 35
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 2,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 3,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 4,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 5,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 6,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 7,
    "layout" : 2
  }, {
    "firstKey" : 0,
    "secondKey" : 8,
    "layout" : 2
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 2,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 3,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 4,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 7,
    "layout" : 5
  }, {
    "firstKey" : 1,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 2,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 1,
    "layout" : 2
  }, {
    "firstKey" : 2,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 2,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 4,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 5,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 6,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 3,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 0,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 1,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 2,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 3,
    "layout" : 4
  }, {
    "firstKey" : 4,
    "secondKey" : 5,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 7,
    "layout" : 3
  }, {
    "firstKey" : 4,
    "secondKey" : 8,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 0,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 1,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 2,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 3,
    "layout" : 7
  }, {
    "firstKey" : 5,
    "secondKey" : 4,
    "layout" : 6
  }, {
    "firstKey" : 5,
    "secondKey" : 6,
    "layout" : 3
  }, {
    "firstKey" : 5,
    "secondKey" : 7,
    "layout" : 4
  }, {
    "firstKey" : 5,
    "secondKey" : 8,
    "layout" : 4
  }, {
    "firstKey" : 6,
    "secondKey" : 0,
    "layout" : 11
  }, {
    "firstKey" : 6,
    "secondKey" : 1,
    "layout" : 11
  }, {
    "firstKey" : 6,
    "secondKey" : 2,
    "layout" : 11
  }, {
    "firstKey" : 6,
    "secondKey" : 3,
    "layout" : 11
  }, {
    "firstKey" : 6,
    "secondKey" : 4,
    "layout" : 10
  }, {
    "firstKey" : 6,
    "secondKey" : 5,
    "layout" : 7
  }, {
    "firstKey" : 6,
    "secondKey" : 7,
    "layout" : 8
  }, {
    "firstKey" : 6,
    "secondKey" : 8,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 0,
    "layout" : 9
  }, {
    "firstKey" : 7,
    "secondKey" : 1,
    "layout" : 9
  }, {
    "firstKey" : 7,
    "secondKey" : 2,
    "layout" : 9
  }, {
    "firstKey" : 7,
    "secondKey" : 3,
    "layout" : 9
  }, {
    "firstKey" : 7,
    "secondKey" : 4,
    "layout" : 8
  }, {
    "firstKey" : 7,
    "secondKey" : 5,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 6,
    "layout" : 6
  }, {
    "firstKey" : 7,
    "secondKey" : 8,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 0,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 1,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 2,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 3,
    "layout" : 8
  }, {
    "firstKey" : 8,
    "secondKey" : 4,
    "layout" : 7
  }, {
    "firstKey" : 8,
    "secondKey" : 5,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 6,
    "layout" : 5
  }, {
    "firstKey" : 8,
    "secondKey" : 7,
    "layout" : 4
  } ]
}