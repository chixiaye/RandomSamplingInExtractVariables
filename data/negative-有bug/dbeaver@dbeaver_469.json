{
  "id" : 469,
  "expression" : "!CommonUtils.isEmpty(packageName)",
  "projectName" : "dbeaver@dbeaver",
  "commitID" : "aecf0da5baef5ea4aa1675578670cf057248123d",
  "filePath" : "/plugins/org.jkiss.dbeaver.ext.generic/src/org/jkiss/dbeaver/ext/generic/model/meta/GenericMetaModel.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "!CommonUtils.isEmpty(packageName)",
    "nodeType" : "PrefixExpression",
    "nodePosition" : {
      "charLength" : 33,
      "startLineNumber" : 402,
      "startColumnNumber" : 36,
      "endLineNumber" : 402,
      "endColumnNumber" : 69
    },
    "astNodeNumber" : 5,
    "astHeight" : 3,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 710,
        "startLineNumber" : 402,
        "startColumnNumber" : 32,
        "endLineNumber" : 412,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (!CommonUtils.isEmpty(packageName)) {\n  if (packageMap == null) {\n    packageMap=new TreeMap<>();\n  }\n  procedurePackage=packageMap.get(packageName);\n  if (procedurePackage == null) {\n    procedurePackage=new GenericPackage(container,packageName,true);\n    packageMap.put(packageName,procedurePackage);\n    container.addPackage(procedurePackage);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 51,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 774,
        "startLineNumber" : 401,
        "startColumnNumber" : 53,
        "endLineNumber" : 413,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  if (!CommonUtils.isEmpty(packageName)) {\n    if (packageMap == null) {\n      packageMap=new TreeMap<>();\n    }\n    procedurePackage=packageMap.get(packageName);\n    if (procedurePackage == null) {\n      procedurePackage=new GenericPackage(container,packageName,true);\n      packageMap.put(packageName,procedurePackage);\n      container.addPackage(procedurePackage);\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 52,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 799,
        "startLineNumber" : 401,
        "startColumnNumber" : 28,
        "endLineNumber" : 413,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (packageName != null) {\n  if (!CommonUtils.isEmpty(packageName)) {\n    if (packageMap == null) {\n      packageMap=new TreeMap<>();\n    }\n    procedurePackage=packageMap.get(packageName);\n    if (procedurePackage == null) {\n      procedurePackage=new GenericPackage(container,packageName,true);\n      packageMap.put(packageName,procedurePackage);\n      container.addPackage(procedurePackage);\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 56,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.WhileStatement,body]",
      "nodePosition" : {
        "charLength" : 4229,
        "startLineNumber" : 363,
        "startColumnNumber" : 48,
        "endLineNumber" : 427,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (monitor.isCanceled()) {\n    break;\n  }\n  String procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\n  String procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\n  String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n  int procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\n  String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n  DBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:    procedureType=DBSProcedureType.PROCEDURE;\n  break;\ncase DatabaseMetaData.procedureReturnsResult:procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\nbreak;\ncase DatabaseMetaData.procedureResultUnknown:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 280,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4253,
        "startLineNumber" : 363,
        "startColumnNumber" : 24,
        "endLineNumber" : 427,
        "endColumnNumber" : 25
      },
      "nodeContext" : "while (dbResult.next()) {\n  if (monitor.isCanceled()) {\n    break;\n  }\n  String procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\n  String procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\n  String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n  int procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\n  String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n  DBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:    procedureType=DBSProcedureType.PROCEDURE;\n  break;\ncase DatabaseMetaData.procedureReturnsResult:procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\nbreak;\ncase DatabaseMetaData.procedureResultUnknown:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n",
      "nodeType" : "WhileStatement",
      "astNodeNumber" : 284,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 4301,
        "startLineNumber" : 362,
        "startColumnNumber" : 24,
        "endLineNumber" : 428,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  while (dbResult.next()) {\n    if (monitor.isCanceled()) {\n      break;\n    }\n    String procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\n    String procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\n    String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n    int procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\n    String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n    DBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:      procedureType=DBSProcedureType.PROCEDURE;\n    break;\ncase DatabaseMetaData.procedureReturnsResult:  procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\nbreak;\ncase DatabaseMetaData.procedureResultUnknown:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 285,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4379,
        "startLineNumber" : 362,
        "startColumnNumber" : 20,
        "endLineNumber" : 430,
        "endColumnNumber" : 21
      },
      "nodeContext" : "try {\n  while (dbResult.next()) {\n    if (monitor.isCanceled()) {\n      break;\n    }\n    String procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\n    String procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\n    String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n    int procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\n    String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n    DBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:      procedureType=DBSProcedureType.PROCEDURE;\n    break;\ncase DatabaseMetaData.procedureReturnsResult:  procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\nbreak;\ncase DatabaseMetaData.procedureResultUnknown:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n}\n  finally {\ndbResult.close();\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 291,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4892,
        "startLineNumber" : 356,
        "startColumnNumber" : 16,
        "endLineNumber" : 431,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  JDBCResultSet dbResult=session.getMetaData().getProcedures(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\n  try {\n    while (dbResult.next()) {\n      if (monitor.isCanceled()) {\n        break;\n      }\n      String procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\n      String procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\n      String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n      int procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\n      String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n      DBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:        procedureType=DBSProcedureType.PROCEDURE;\n      break;\ncase DatabaseMetaData.procedureReturnsResult:    procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\n  break;\ncase DatabaseMetaData.procedureResultUnknown:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n}\n  finally {\ndbResult.close();\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 340,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 4924,
        "startLineNumber" : 355,
        "startColumnNumber" : 39,
        "endLineNumber" : 432,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n{\n    JDBCResultSet dbResult=session.getMetaData().getProcedures(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\n    try {\n      while (dbResult.next()) {\n        if (monitor.isCanceled()) {\n          break;\n        }\n        String procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\n        String procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\n        String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n        int procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\n        String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n        DBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:          procedureType=DBSProcedureType.PROCEDURE;\n        break;\ncase DatabaseMetaData.procedureReturnsResult:      procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\n    break;\ncase DatabaseMetaData.procedureResultUnknown:  procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n}\n  finally {\ndbResult.close();\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 341,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4951,
        "startLineNumber" : 355,
        "startColumnNumber" : 12,
        "endLineNumber" : 432,
        "endColumnNumber" : 13
      },
      "nodeContext" : "if (hasProcedureSupport()) {\n{\n    JDBCResultSet dbResult=session.getMetaData().getProcedures(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\n    try {\n      while (dbResult.next()) {\n        if (monitor.isCanceled()) {\n          break;\n        }\n        String procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\n        String procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\n        String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n        int procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\n        String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n        DBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:          procedureType=DBSProcedureType.PROCEDURE;\n        break;\ncase DatabaseMetaData.procedureReturnsResult:      procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\n    break;\ncase DatabaseMetaData.procedureResultUnknown:  procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n}\n  finally {\ndbResult.close();\n}\n}\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 344,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 9190,
        "startLineNumber" : 287,
        "startColumnNumber" : 99,
        "endLineNumber" : 434,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  boolean supportsFunctions=false;\n  if (hasFunctionSupport()) {\n    try {\n      JDBCResultSet dbResult=session.getMetaData().getFunctions(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\n      try {\n        supportsFunctions=true;\n        while (dbResult.next()) {\n          if (monitor.isCanceled()) {\n            break;\n          }\n          String functionName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.FUNCTION_NAME);\n          if (functionName == null) {\n            continue;\n          }\n          String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n          if (specificName == null && functionName.indexOf(';') != -1) {\n            specificName=functionName;\n            functionName=functionName.substring(0,functionName.lastIndexOf(';'));\n          }\n          if (container.hasProcedure(functionName)) {\n            continue;\n          }\n          int funcTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.FUNCTION_TYPE);\n          String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n          GenericFunctionResultType functionResultType;\nswitch (funcTypeNum) {\ncase DatabaseMetaData.functionNoTable:            functionResultType=GenericFunctionResultType.NO_TABLE;\n          break;\ncase DatabaseMetaData.functionReturnsTable:        functionResultType=GenericFunctionResultType.TABLE;\n      break;\ndefault:    functionResultType=GenericFunctionResultType.UNKNOWN;\n  break;\n}\nfinal GenericProcedure procedure=createProcedureImpl(container,functionName,specificName,remarks,DBSProcedureType.FUNCTION,functionResultType);\ncontainer.addProcedure(procedure);\nfuncMap.put(specificName == null ? functionName : specificName,procedure);\n}\n}\n  finally {\ndbResult.close();\n}\n}\n catch (Throwable e) {\nlog.debug(\"Can't read generic functions\",e);\n}\n}\nif (hasProcedureSupport()) {\n{\nJDBCResultSet dbResult=session.getMetaData().getProcedures(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\ntry {\nwhile (dbResult.next()) {\nif (monitor.isCanceled()) {\nbreak;\n}\nString procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\nString procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\nString specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\nint procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\nString remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\nDBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ncase DatabaseMetaData.procedureReturnsResult:procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\nbreak;\ncase DatabaseMetaData.procedureResultUnknown:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n}\n  finally {\ndbResult.close();\n}\n}\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 599,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 9366,
        "startLineNumber" : 287,
        "startColumnNumber" : 8,
        "endLineNumber" : 436,
        "endColumnNumber" : 9
      },
      "nodeContext" : "try (JDBCSession session=DBUtils.openMetaSession(monitor,container,\"Load procedures\")){\n  boolean supportsFunctions=false;\n  if (hasFunctionSupport()) {\n    try {\n      JDBCResultSet dbResult=session.getMetaData().getFunctions(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\n      try {\n        supportsFunctions=true;\n        while (dbResult.next()) {\n          if (monitor.isCanceled()) {\n            break;\n          }\n          String functionName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.FUNCTION_NAME);\n          if (functionName == null) {\n            continue;\n          }\n          String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n          if (specificName == null && functionName.indexOf(';') != -1) {\n            specificName=functionName;\n            functionName=functionName.substring(0,functionName.lastIndexOf(';'));\n          }\n          if (container.hasProcedure(functionName)) {\n            continue;\n          }\n          int funcTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.FUNCTION_TYPE);\n          String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n          GenericFunctionResultType functionResultType;\nswitch (funcTypeNum) {\ncase DatabaseMetaData.functionNoTable:            functionResultType=GenericFunctionResultType.NO_TABLE;\n          break;\ncase DatabaseMetaData.functionReturnsTable:        functionResultType=GenericFunctionResultType.TABLE;\n      break;\ndefault:    functionResultType=GenericFunctionResultType.UNKNOWN;\n  break;\n}\nfinal GenericProcedure procedure=createProcedureImpl(container,functionName,specificName,remarks,DBSProcedureType.FUNCTION,functionResultType);\ncontainer.addProcedure(procedure);\nfuncMap.put(specificName == null ? functionName : specificName,procedure);\n}\n}\n  finally {\ndbResult.close();\n}\n}\n catch (Throwable e) {\nlog.debug(\"Can't read generic functions\",e);\n}\n}\nif (hasProcedureSupport()) {\n{\nJDBCResultSet dbResult=session.getMetaData().getProcedures(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\ntry {\nwhile (dbResult.next()) {\nif (monitor.isCanceled()) {\nbreak;\n}\nString procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\nString procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\nString specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\nint procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\nString remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\nDBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ncase DatabaseMetaData.procedureReturnsResult:procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\nbreak;\ncase DatabaseMetaData.procedureResultUnknown:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n}\n  finally {\ndbResult.close();\n}\n}\n}\n}\n catch (SQLException e) {\nthrow new DBException(e,dataSource);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 623,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 9676,
        "startLineNumber" : 280,
        "startColumnNumber" : 4,
        "endLineNumber" : 437,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  Map<String,GenericPackage> packageMap=null;\n  Map<String,GenericProcedure> funcMap=new LinkedHashMap<>();\n  GenericDataSource dataSource=container.getDataSource();\n  GenericMetaObject procObject=dataSource.getMetaObject(GenericConstants.OBJECT_PROCEDURE);\n  try (JDBCSession session=DBUtils.openMetaSession(monitor,container,\"Load procedures\")){\n    boolean supportsFunctions=false;\n    if (hasFunctionSupport()) {\n      try {\n        JDBCResultSet dbResult=session.getMetaData().getFunctions(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\n        try {\n          supportsFunctions=true;\n          while (dbResult.next()) {\n            if (monitor.isCanceled()) {\n              break;\n            }\n            String functionName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.FUNCTION_NAME);\n            if (functionName == null) {\n              continue;\n            }\n            String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n            if (specificName == null && functionName.indexOf(';') != -1) {\n              specificName=functionName;\n              functionName=functionName.substring(0,functionName.lastIndexOf(';'));\n            }\n            if (container.hasProcedure(functionName)) {\n              continue;\n            }\n            int funcTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.FUNCTION_TYPE);\n            String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n            GenericFunctionResultType functionResultType;\nswitch (funcTypeNum) {\ncase DatabaseMetaData.functionNoTable:              functionResultType=GenericFunctionResultType.NO_TABLE;\n            break;\ncase DatabaseMetaData.functionReturnsTable:          functionResultType=GenericFunctionResultType.TABLE;\n        break;\ndefault:      functionResultType=GenericFunctionResultType.UNKNOWN;\n    break;\n}\nfinal GenericProcedure procedure=createProcedureImpl(container,functionName,specificName,remarks,DBSProcedureType.FUNCTION,functionResultType);\ncontainer.addProcedure(procedure);\nfuncMap.put(specificName == null ? functionName : specificName,procedure);\n}\n}\n  finally {\ndbResult.close();\n}\n}\n catch (Throwable e) {\nlog.debug(\"Can't read generic functions\",e);\n}\n}\nif (hasProcedureSupport()) {\n{\nJDBCResultSet dbResult=session.getMetaData().getProcedures(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\ntry {\nwhile (dbResult.next()) {\nif (monitor.isCanceled()) {\n  break;\n}\nString procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\nString procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\nString specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\nint procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\nString remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\nDBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:  procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ncase DatabaseMetaData.procedureReturnsResult:procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\nbreak;\ncase DatabaseMetaData.procedureResultUnknown:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n}\n  finally {\ndbResult.close();\n}\n}\n}\n}\n catch (SQLException e) {\nthrow new DBException(e,dataSource);\n}\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 668,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 9805,
        "startLineNumber" : 278,
        "startColumnNumber" : 4,
        "endLineNumber" : 437,
        "endColumnNumber" : 5
      },
      "nodeContext" : "public void loadProcedures(DBRProgressMonitor monitor,@NotNull GenericObjectContainer container) throws DBException {\n  Map<String,GenericPackage> packageMap=null;\n  Map<String,GenericProcedure> funcMap=new LinkedHashMap<>();\n  GenericDataSource dataSource=container.getDataSource();\n  GenericMetaObject procObject=dataSource.getMetaObject(GenericConstants.OBJECT_PROCEDURE);\n  try (JDBCSession session=DBUtils.openMetaSession(monitor,container,\"Load procedures\")){\n    boolean supportsFunctions=false;\n    if (hasFunctionSupport()) {\n      try {\n        JDBCResultSet dbResult=session.getMetaData().getFunctions(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\n        try {\n          supportsFunctions=true;\n          while (dbResult.next()) {\n            if (monitor.isCanceled()) {\n              break;\n            }\n            String functionName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.FUNCTION_NAME);\n            if (functionName == null) {\n              continue;\n            }\n            String specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\n            if (specificName == null && functionName.indexOf(';') != -1) {\n              specificName=functionName;\n              functionName=functionName.substring(0,functionName.lastIndexOf(';'));\n            }\n            if (container.hasProcedure(functionName)) {\n              continue;\n            }\n            int funcTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.FUNCTION_TYPE);\n            String remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\n            GenericFunctionResultType functionResultType;\nswitch (funcTypeNum) {\ncase DatabaseMetaData.functionNoTable:              functionResultType=GenericFunctionResultType.NO_TABLE;\n            break;\ncase DatabaseMetaData.functionReturnsTable:          functionResultType=GenericFunctionResultType.TABLE;\n        break;\ndefault:      functionResultType=GenericFunctionResultType.UNKNOWN;\n    break;\n}\nfinal GenericProcedure procedure=createProcedureImpl(container,functionName,specificName,remarks,DBSProcedureType.FUNCTION,functionResultType);\ncontainer.addProcedure(procedure);\nfuncMap.put(specificName == null ? functionName : specificName,procedure);\n}\n}\n  finally {\ndbResult.close();\n}\n}\n catch (Throwable e) {\nlog.debug(\"Can't read generic functions\",e);\n}\n}\nif (hasProcedureSupport()) {\n{\nJDBCResultSet dbResult=session.getMetaData().getProcedures(container.getCatalog() == null ? null : container.getCatalog().getName(),container.getSchema() == null || DBUtils.isVirtualObject(container.getSchema()) ? null : JDBCUtils.escapeWildCards(session,container.getSchema().getName()),dataSource.getAllObjectsPattern());\ntry {\nwhile (dbResult.next()) {\nif (monitor.isCanceled()) {\n  break;\n}\nString procedureCatalog=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_CAT);\nString procedureName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.PROCEDURE_NAME);\nString specificName=GenericUtils.safeGetStringTrimmed(procObject,dbResult,JDBCConstants.SPECIFIC_NAME);\nint procTypeNum=GenericUtils.safeGetInt(procObject,dbResult,JDBCConstants.PROCEDURE_TYPE);\nString remarks=GenericUtils.safeGetString(procObject,dbResult,JDBCConstants.REMARKS);\nDBSProcedureType procedureType;\nswitch (procTypeNum) {\ncase DatabaseMetaData.procedureNoResult:  procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ncase DatabaseMetaData.procedureReturnsResult:procedureType=supportsFunctions ? DBSProcedureType.PROCEDURE : DBSProcedureType.FUNCTION;\nbreak;\ncase DatabaseMetaData.procedureResultUnknown:procedureType=DBSProcedureType.PROCEDURE;\nbreak;\ndefault:procedureType=DBSProcedureType.UNKNOWN;\nbreak;\n}\nif (CommonUtils.isEmpty(specificName)) {\nspecificName=procedureName;\n}\nGenericProcedure function=funcMap.get(specificName);\nif (function != null) {\nlog.debug(\"Broken driver [\" + session.getDataSource().getContainer().getDriver().getName() + \"] - returns the same list for getProcedures and getFunctons\");\nbreak;\n}\nprocedureName=GenericUtils.normalizeProcedureName(procedureName);\nGenericPackage procedurePackage=null;\nString packageName=getPackageName(dataSource,procedureCatalog,procedureName,specificName);\nif (packageName != null) {\nif (!CommonUtils.isEmpty(packageName)) {\nif (packageMap == null) {\npackageMap=new TreeMap<>();\n}\nprocedurePackage=packageMap.get(packageName);\nif (procedurePackage == null) {\nprocedurePackage=new GenericPackage(container,packageName,true);\npackageMap.put(packageName,procedurePackage);\ncontainer.addPackage(procedurePackage);\n}\n}\n}\nfinal GenericProcedure procedure=createProcedureImpl(procedurePackage != null ? procedurePackage : container,procedureName,specificName,remarks,procedureType,null);\nif (procedurePackage != null) {\nprocedurePackage.addProcedure(procedure);\n}\n else {\ncontainer.addProcedure(procedure);\n}\n}\n}\n  finally {\ndbResult.close();\n}\n}\n}\n}\n catch (SQLException e) {\nthrow new DBException(e,dataSource);\n}\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 684,
      "astHeight" : 23
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 710,
        "startLineNumber" : 402,
        "startColumnNumber" : 32,
        "endLineNumber" : 412,
        "endColumnNumber" : 33
      },
      "nodeContext" : "if (!CommonUtils.isEmpty(packageName)) {\n  if (packageMap == null) {\n    packageMap=new TreeMap<>();\n  }\n  procedurePackage=packageMap.get(packageName);\n  if (procedurePackage == null) {\n    procedurePackage=new GenericPackage(container,packageName,true);\n    packageMap.put(packageName,procedurePackage);\n    container.addPackage(procedurePackage);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 51,
      "astHeight" : 10
    },
    "tokenLength" : 3,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 33,
    "startLineNumber" : 402,
    "startColumnNumber" : 36,
    "endLineNumber" : 402,
    "endColumnNumber" : 69
  } ],
  "layoutRelationDataList" : [ ]
}