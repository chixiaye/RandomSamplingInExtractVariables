{
  "id" : 408,
  "expression" : "yPoint * (1f - transitionProgressHalf)",
  "projectName" : "DrKLO@Telegram",
  "commitID" : "11fbfb1329df700b203e1852a71c4c11b5ab12f4",
  "filePath" : "/TMessagesProj/src/main/java/org/telegram/ui/Charts/StackLinearChartView.java",
  "occurrences" : 2,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "yPoint * (1f - transitionProgressHalf)",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 38,
      "startLineNumber" : 181,
      "startColumnNumber" : 33,
      "endLineNumber" : 181,
      "endColumnNumber" : 71
    },
    "astNodeNumber" : 6,
    "astHeight" : 4,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 69,
        "startLineNumber" : 181,
        "startColumnNumber" : 33,
        "endLineNumber" : 181,
        "endColumnNumber" : 102
      },
      "nodeContext" : "yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 78,
        "startLineNumber" : 181,
        "startColumnNumber" : 24,
        "endLineNumber" : 181,
        "endColumnNumber" : 102
      },
      "nodeContext" : "yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf",
      "nodeType" : "Assignment",
      "astNodeNumber" : 12,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 79,
        "startLineNumber" : 181,
        "startColumnNumber" : 24,
        "endLineNumber" : 181,
        "endColumnNumber" : 103
      },
      "nodeContext" : "yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 3671,
        "startLineNumber" : 168,
        "startColumnNumber" : 86,
        "endLineNumber" : 237,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (xPoint < cX) {\n    x1=transitionParams.startX[k];\n    y1=transitionParams.startY[k];\n  }\n else {\n    x1=transitionParams.endX[k];\n    y1=transitionParams.endY[k];\n  }\n  dX=cX - x1;\n  dY=cY - y1;\n  float yTo=dY * (xPoint - x1) / dX + y1;\n  yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n  yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n  float angleK=dY / dX;\n  if (angleK > 0) {\n    angle=(float)Math.toDegrees(-Math.atan(angleK));\n  }\n else {\n    angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n  }\n  angle-=90;\n  if (xPoint >= cX) {\n    mapPoints[0]=xPoint;\n    mapPoints[1]=yPoint;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle,cX,cY);\n    matrix.mapPoints(mapPoints);\n    xPoint=mapPoints[0];\n    yPoint=mapPoints[1];\n    if (xPoint < cX)     xPoint=cX;\n    mapPoints[0]=xPointZero;\n    mapPoints[1]=yPointZero;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle,cX,cY);\n    matrix.mapPoints(mapPoints);\n    yPointZero=mapPoints[1];\n    if (xPointZero < cX)     xPointZero=cX;\n  }\n else {\n    if (nextXPoint >= cX) {\n      xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n      yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n    }\n else {\n      mapPoints[0]=xPoint;\n      mapPoints[1]=yPoint;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPoint=mapPoints[0];\n      yPoint=mapPoints[1];\n      if (nextXPoint >= cX) {\n        mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n      }\n else {\n        mapPoints[0]=xPointZero;\n      }\n      mapPoints[1]=yPointZero;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPointZero=mapPoints[0];\n      yPointZero=mapPoints[1];\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 409,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3737,
        "startLineNumber" : 168,
        "startColumnNumber" : 20,
        "endLineNumber" : 237,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n  if (xPoint < cX) {\n    x1=transitionParams.startX[k];\n    y1=transitionParams.startY[k];\n  }\n else {\n    x1=transitionParams.endX[k];\n    y1=transitionParams.endY[k];\n  }\n  dX=cX - x1;\n  dY=cY - y1;\n  float yTo=dY * (xPoint - x1) / dX + y1;\n  yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n  yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n  float angleK=dY / dX;\n  if (angleK > 0) {\n    angle=(float)Math.toDegrees(-Math.atan(angleK));\n  }\n else {\n    angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n  }\n  angle-=90;\n  if (xPoint >= cX) {\n    mapPoints[0]=xPoint;\n    mapPoints[1]=yPoint;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle,cX,cY);\n    matrix.mapPoints(mapPoints);\n    xPoint=mapPoints[0];\n    yPoint=mapPoints[1];\n    if (xPoint < cX)     xPoint=cX;\n    mapPoints[0]=xPointZero;\n    mapPoints[1]=yPointZero;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle,cX,cY);\n    matrix.mapPoints(mapPoints);\n    yPointZero=mapPoints[1];\n    if (xPointZero < cX)     xPointZero=cX;\n  }\n else {\n    if (nextXPoint >= cX) {\n      xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n      yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n    }\n else {\n      mapPoints[0]=xPoint;\n      mapPoints[1]=yPoint;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPoint=mapPoints[0];\n      yPoint=mapPoints[1];\n      if (nextXPoint >= cX) {\n        mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n      }\n else {\n        mapPoints[0]=xPointZero;\n      }\n      mapPoints[1]=yPointZero;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPointZero=mapPoints[0];\n      yPointZero=mapPoints[1];\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 417,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 11685,
        "startLineNumber" : 124,
        "startColumnNumber" : 55,
        "endLineNumber" : 356,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  LineViewData line=lines.get(k);\n  if (!line.enabled && line.alpha == 0)   continue;\n  int[] y=line.line.y;\n  float yPercentage;\n  if (drawingLinesCount == 1) {\n    if (y[i] == 0) {\n      yPercentage=0;\n    }\n else {\n      yPercentage=line.alpha;\n    }\n  }\n else {\n    if (sum == 0) {\n      yPercentage=0;\n    }\n else {\n      yPercentage=y[i] * line.alpha / sum;\n    }\n  }\n  float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n  float nextXPoint;\n  if (i == localEnd) {\n    nextXPoint=getMeasuredWidth();\n  }\n else {\n    nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n  }\n  if (yPercentage == 0 && k == lastEnabled) {\n    hasEmptyPoint=true;\n  }\n  float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n  float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n  startFromY[k]=yPoint;\n  float angle=0;\n  float yPointZero=getMeasuredHeight() - chartBottom;\n  float xPointZero=xPoint;\n  if (i == localEnd) {\n    endXPoint=xPoint;\n  }\n else   if (i == localStart) {\n    startXPoint=xPoint;\n  }\n  if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n    if (xPoint < cX) {\n      x1=transitionParams.startX[k];\n      y1=transitionParams.startY[k];\n    }\n else {\n      x1=transitionParams.endX[k];\n      y1=transitionParams.endY[k];\n    }\n    dX=cX - x1;\n    dY=cY - y1;\n    float yTo=dY * (xPoint - x1) / dX + y1;\n    yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n    yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n    float angleK=dY / dX;\n    if (angleK > 0) {\n      angle=(float)Math.toDegrees(-Math.atan(angleK));\n    }\n else {\n      angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n    }\n    angle-=90;\n    if (xPoint >= cX) {\n      mapPoints[0]=xPoint;\n      mapPoints[1]=yPoint;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle,cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPoint=mapPoints[0];\n      yPoint=mapPoints[1];\n      if (xPoint < cX)       xPoint=cX;\n      mapPoints[0]=xPointZero;\n      mapPoints[1]=yPointZero;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle,cX,cY);\n      matrix.mapPoints(mapPoints);\n      yPointZero=mapPoints[1];\n      if (xPointZero < cX)       xPointZero=cX;\n    }\n else {\n      if (nextXPoint >= cX) {\n        xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n        yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n      }\n else {\n        mapPoints[0]=xPoint;\n        mapPoints[1]=yPoint;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPoint=mapPoints[0];\n        yPoint=mapPoints[1];\n        if (nextXPoint >= cX) {\n          mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n        }\n else {\n          mapPoints[0]=xPointZero;\n        }\n        mapPoints[1]=yPointZero;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPointZero=mapPoints[0];\n        yPointZero=mapPoints[1];\n      }\n    }\n  }\n  if (i == localStart) {\n    float localX=0;\n    float localY=getMeasuredHeight();\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      mapPoints[0]=localX - cX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n    }\n    line.chartPath.moveTo(localX,localY);\n    skipPoints[k]=false;\n  }\n  float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n  if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n    if (!skipPoints[k]) {\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPointZero,yPointZero);\n      }\n    }\n    skipPoints[k]=true;\n  }\n else {\n    if (skipPoints[k]) {\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPointZero,yPointZero);\n      }\n    }\n    if (k == lastEnabled) {\n      line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n    }\n else {\n      line.chartPath.lineTo(xPoint,yPoint);\n    }\n    skipPoints[k]=false;\n  }\n  if (i == localEnd) {\n    float localX=getMeasuredWidth();\n    float localY=getMeasuredHeight();\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      mapPoints[0]=localX + cX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n    }\n else {\n      line.chartPath.lineTo(localX,localY);\n    }\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      x1=transitionParams.startX[k];\n      y1=transitionParams.startY[k];\n      dX=cX - x1;\n      dY=cY - y1;\n      float angleK=dY / dX;\n      if (angleK > 0) {\n        angle=(float)Math.toDegrees(-Math.atan(angleK));\n      }\n else {\n        angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n      }\n      angle-=90;\n      localX=transitionParams.startX[k];\n      localY=transitionParams.startY[k];\n      mapPoints[0]=localX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n      int endQuarter;\n      int startQuarter;\n      if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n        if (transitionParams.angle[k] == -180f) {\n          endQuarter=0;\n          startQuarter=0;\n        }\n else {\n          endQuarter=0;\n          startQuarter=3;\n        }\n      }\n else {\n        endQuarter=quarterForPoint(xPoint,yPoint);\n        startQuarter=quarterForPoint(localX,localY);\n      }\n      for (int q=endQuarter; q <= startQuarter; q++) {\n        if (q == 0) {\n          line.chartPath.lineTo(getMeasuredWidth(),0);\n        }\n else         if (q == 1) {\n          line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n        }\n else         if (q == 2) {\n          line.chartPath.lineTo(0,getMeasuredHeight());\n        }\n else {\n          line.chartPath.lineTo(0,0);\n        }\n      }\n    }\n  }\n  stackOffset+=height;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1251,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11724,
        "startLineNumber" : 124,
        "startColumnNumber" : 16,
        "endLineNumber" : 356,
        "endColumnNumber" : 17
      },
      "nodeContext" : "for (int k=0; k < lines.size(); k++) {\n  LineViewData line=lines.get(k);\n  if (!line.enabled && line.alpha == 0)   continue;\n  int[] y=line.line.y;\n  float yPercentage;\n  if (drawingLinesCount == 1) {\n    if (y[i] == 0) {\n      yPercentage=0;\n    }\n else {\n      yPercentage=line.alpha;\n    }\n  }\n else {\n    if (sum == 0) {\n      yPercentage=0;\n    }\n else {\n      yPercentage=y[i] * line.alpha / sum;\n    }\n  }\n  float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n  float nextXPoint;\n  if (i == localEnd) {\n    nextXPoint=getMeasuredWidth();\n  }\n else {\n    nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n  }\n  if (yPercentage == 0 && k == lastEnabled) {\n    hasEmptyPoint=true;\n  }\n  float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n  float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n  startFromY[k]=yPoint;\n  float angle=0;\n  float yPointZero=getMeasuredHeight() - chartBottom;\n  float xPointZero=xPoint;\n  if (i == localEnd) {\n    endXPoint=xPoint;\n  }\n else   if (i == localStart) {\n    startXPoint=xPoint;\n  }\n  if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n    if (xPoint < cX) {\n      x1=transitionParams.startX[k];\n      y1=transitionParams.startY[k];\n    }\n else {\n      x1=transitionParams.endX[k];\n      y1=transitionParams.endY[k];\n    }\n    dX=cX - x1;\n    dY=cY - y1;\n    float yTo=dY * (xPoint - x1) / dX + y1;\n    yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n    yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n    float angleK=dY / dX;\n    if (angleK > 0) {\n      angle=(float)Math.toDegrees(-Math.atan(angleK));\n    }\n else {\n      angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n    }\n    angle-=90;\n    if (xPoint >= cX) {\n      mapPoints[0]=xPoint;\n      mapPoints[1]=yPoint;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle,cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPoint=mapPoints[0];\n      yPoint=mapPoints[1];\n      if (xPoint < cX)       xPoint=cX;\n      mapPoints[0]=xPointZero;\n      mapPoints[1]=yPointZero;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle,cX,cY);\n      matrix.mapPoints(mapPoints);\n      yPointZero=mapPoints[1];\n      if (xPointZero < cX)       xPointZero=cX;\n    }\n else {\n      if (nextXPoint >= cX) {\n        xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n        yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n      }\n else {\n        mapPoints[0]=xPoint;\n        mapPoints[1]=yPoint;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPoint=mapPoints[0];\n        yPoint=mapPoints[1];\n        if (nextXPoint >= cX) {\n          mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n        }\n else {\n          mapPoints[0]=xPointZero;\n        }\n        mapPoints[1]=yPointZero;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPointZero=mapPoints[0];\n        yPointZero=mapPoints[1];\n      }\n    }\n  }\n  if (i == localStart) {\n    float localX=0;\n    float localY=getMeasuredHeight();\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      mapPoints[0]=localX - cX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n    }\n    line.chartPath.moveTo(localX,localY);\n    skipPoints[k]=false;\n  }\n  float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n  if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n    if (!skipPoints[k]) {\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPointZero,yPointZero);\n      }\n    }\n    skipPoints[k]=true;\n  }\n else {\n    if (skipPoints[k]) {\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPointZero,yPointZero);\n      }\n    }\n    if (k == lastEnabled) {\n      line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n    }\n else {\n      line.chartPath.lineTo(xPoint,yPoint);\n    }\n    skipPoints[k]=false;\n  }\n  if (i == localEnd) {\n    float localX=getMeasuredWidth();\n    float localY=getMeasuredHeight();\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      mapPoints[0]=localX + cX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n    }\n else {\n      line.chartPath.lineTo(localX,localY);\n    }\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      x1=transitionParams.startX[k];\n      y1=transitionParams.startY[k];\n      dX=cX - x1;\n      dY=cY - y1;\n      float angleK=dY / dX;\n      if (angleK > 0) {\n        angle=(float)Math.toDegrees(-Math.atan(angleK));\n      }\n else {\n        angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n      }\n      angle-=90;\n      localX=transitionParams.startX[k];\n      localY=transitionParams.startY[k];\n      mapPoints[0]=localX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n      int endQuarter;\n      int startQuarter;\n      if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n        if (transitionParams.angle[k] == -180f) {\n          endQuarter=0;\n          startQuarter=0;\n        }\n else {\n          endQuarter=0;\n          startQuarter=3;\n        }\n      }\n else {\n        endQuarter=quarterForPoint(xPoint,yPoint);\n        startQuarter=quarterForPoint(localX,localY);\n      }\n      for (int q=endQuarter; q <= startQuarter; q++) {\n        if (q == 0) {\n          line.chartPath.lineTo(getMeasuredWidth(),0);\n        }\n else         if (q == 1) {\n          line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n        }\n else         if (q == 2) {\n          line.chartPath.lineTo(0,getMeasuredHeight());\n        }\n else {\n          line.chartPath.lineTo(0,0);\n        }\n      }\n    }\n  }\n  stackOffset+=height;\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 1264,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 12315,
        "startLineNumber" : 108,
        "startColumnNumber" : 57,
        "endLineNumber" : 357,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  float stackOffset=0;\n  float sum=0;\n  int lastEnabled=0;\n  int drawingLinesCount=0;\n  for (int k=0; k < lines.size(); k++) {\n    LineViewData line=lines.get(k);\n    if (!line.enabled && line.alpha == 0)     continue;\n    if (line.line.y[i] > 0) {\n      sum+=line.line.y[i] * line.alpha;\n      drawingLinesCount++;\n    }\n    lastEnabled=k;\n  }\n  for (int k=0; k < lines.size(); k++) {\n    LineViewData line=lines.get(k);\n    if (!line.enabled && line.alpha == 0)     continue;\n    int[] y=line.line.y;\n    float yPercentage;\n    if (drawingLinesCount == 1) {\n      if (y[i] == 0) {\n        yPercentage=0;\n      }\n else {\n        yPercentage=line.alpha;\n      }\n    }\n else {\n      if (sum == 0) {\n        yPercentage=0;\n      }\n else {\n        yPercentage=y[i] * line.alpha / sum;\n      }\n    }\n    float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n    float nextXPoint;\n    if (i == localEnd) {\n      nextXPoint=getMeasuredWidth();\n    }\n else {\n      nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n    }\n    if (yPercentage == 0 && k == lastEnabled) {\n      hasEmptyPoint=true;\n    }\n    float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n    float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n    startFromY[k]=yPoint;\n    float angle=0;\n    float yPointZero=getMeasuredHeight() - chartBottom;\n    float xPointZero=xPoint;\n    if (i == localEnd) {\n      endXPoint=xPoint;\n    }\n else     if (i == localStart) {\n      startXPoint=xPoint;\n    }\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      if (xPoint < cX) {\n        x1=transitionParams.startX[k];\n        y1=transitionParams.startY[k];\n      }\n else {\n        x1=transitionParams.endX[k];\n        y1=transitionParams.endY[k];\n      }\n      dX=cX - x1;\n      dY=cY - y1;\n      float yTo=dY * (xPoint - x1) / dX + y1;\n      yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n      yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n      float angleK=dY / dX;\n      if (angleK > 0) {\n        angle=(float)Math.toDegrees(-Math.atan(angleK));\n      }\n else {\n        angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n      }\n      angle-=90;\n      if (xPoint >= cX) {\n        mapPoints[0]=xPoint;\n        mapPoints[1]=yPoint;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle,cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPoint=mapPoints[0];\n        yPoint=mapPoints[1];\n        if (xPoint < cX)         xPoint=cX;\n        mapPoints[0]=xPointZero;\n        mapPoints[1]=yPointZero;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle,cX,cY);\n        matrix.mapPoints(mapPoints);\n        yPointZero=mapPoints[1];\n        if (xPointZero < cX)         xPointZero=cX;\n      }\n else {\n        if (nextXPoint >= cX) {\n          xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n          yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n        }\n else {\n          mapPoints[0]=xPoint;\n          mapPoints[1]=yPoint;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPoint=mapPoints[0];\n          yPoint=mapPoints[1];\n          if (nextXPoint >= cX) {\n            mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n          }\n else {\n            mapPoints[0]=xPointZero;\n          }\n          mapPoints[1]=yPointZero;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPointZero=mapPoints[0];\n          yPointZero=mapPoints[1];\n        }\n      }\n    }\n    if (i == localStart) {\n      float localX=0;\n      float localY=getMeasuredHeight();\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        mapPoints[0]=localX - cX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n      }\n      line.chartPath.moveTo(localX,localY);\n      skipPoints[k]=false;\n    }\n    float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n    if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n      if (!skipPoints[k]) {\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPointZero,yPointZero);\n        }\n      }\n      skipPoints[k]=true;\n    }\n else {\n      if (skipPoints[k]) {\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPointZero,yPointZero);\n        }\n      }\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPoint,yPoint);\n      }\n      skipPoints[k]=false;\n    }\n    if (i == localEnd) {\n      float localX=getMeasuredWidth();\n      float localY=getMeasuredHeight();\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        mapPoints[0]=localX + cX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n      }\n else {\n        line.chartPath.lineTo(localX,localY);\n      }\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        x1=transitionParams.startX[k];\n        y1=transitionParams.startY[k];\n        dX=cX - x1;\n        dY=cY - y1;\n        float angleK=dY / dX;\n        if (angleK > 0) {\n          angle=(float)Math.toDegrees(-Math.atan(angleK));\n        }\n else {\n          angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n        }\n        angle-=90;\n        localX=transitionParams.startX[k];\n        localY=transitionParams.startY[k];\n        mapPoints[0]=localX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n        int endQuarter;\n        int startQuarter;\n        if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n          if (transitionParams.angle[k] == -180f) {\n            endQuarter=0;\n            startQuarter=0;\n          }\n else {\n            endQuarter=0;\n            startQuarter=3;\n          }\n        }\n else {\n          endQuarter=quarterForPoint(xPoint,yPoint);\n          startQuarter=quarterForPoint(localX,localY);\n        }\n        for (int q=endQuarter; q <= startQuarter; q++) {\n          if (q == 0) {\n            line.chartPath.lineTo(getMeasuredWidth(),0);\n          }\n else           if (q == 1) {\n            line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n          }\n else           if (q == 2) {\n            line.chartPath.lineTo(0,getMeasuredHeight());\n          }\n else {\n            line.chartPath.lineTo(0,0);\n          }\n        }\n      }\n    }\n    stackOffset+=height;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1352,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 12360,
        "startLineNumber" : 108,
        "startColumnNumber" : 12,
        "endLineNumber" : 357,
        "endColumnNumber" : 13
      },
      "nodeContext" : "for (int i=localStart; i <= localEnd; i++) {\n  float stackOffset=0;\n  float sum=0;\n  int lastEnabled=0;\n  int drawingLinesCount=0;\n  for (int k=0; k < lines.size(); k++) {\n    LineViewData line=lines.get(k);\n    if (!line.enabled && line.alpha == 0)     continue;\n    if (line.line.y[i] > 0) {\n      sum+=line.line.y[i] * line.alpha;\n      drawingLinesCount++;\n    }\n    lastEnabled=k;\n  }\n  for (int k=0; k < lines.size(); k++) {\n    LineViewData line=lines.get(k);\n    if (!line.enabled && line.alpha == 0)     continue;\n    int[] y=line.line.y;\n    float yPercentage;\n    if (drawingLinesCount == 1) {\n      if (y[i] == 0) {\n        yPercentage=0;\n      }\n else {\n        yPercentage=line.alpha;\n      }\n    }\n else {\n      if (sum == 0) {\n        yPercentage=0;\n      }\n else {\n        yPercentage=y[i] * line.alpha / sum;\n      }\n    }\n    float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n    float nextXPoint;\n    if (i == localEnd) {\n      nextXPoint=getMeasuredWidth();\n    }\n else {\n      nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n    }\n    if (yPercentage == 0 && k == lastEnabled) {\n      hasEmptyPoint=true;\n    }\n    float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n    float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n    startFromY[k]=yPoint;\n    float angle=0;\n    float yPointZero=getMeasuredHeight() - chartBottom;\n    float xPointZero=xPoint;\n    if (i == localEnd) {\n      endXPoint=xPoint;\n    }\n else     if (i == localStart) {\n      startXPoint=xPoint;\n    }\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      if (xPoint < cX) {\n        x1=transitionParams.startX[k];\n        y1=transitionParams.startY[k];\n      }\n else {\n        x1=transitionParams.endX[k];\n        y1=transitionParams.endY[k];\n      }\n      dX=cX - x1;\n      dY=cY - y1;\n      float yTo=dY * (xPoint - x1) / dX + y1;\n      yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n      yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n      float angleK=dY / dX;\n      if (angleK > 0) {\n        angle=(float)Math.toDegrees(-Math.atan(angleK));\n      }\n else {\n        angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n      }\n      angle-=90;\n      if (xPoint >= cX) {\n        mapPoints[0]=xPoint;\n        mapPoints[1]=yPoint;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle,cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPoint=mapPoints[0];\n        yPoint=mapPoints[1];\n        if (xPoint < cX)         xPoint=cX;\n        mapPoints[0]=xPointZero;\n        mapPoints[1]=yPointZero;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle,cX,cY);\n        matrix.mapPoints(mapPoints);\n        yPointZero=mapPoints[1];\n        if (xPointZero < cX)         xPointZero=cX;\n      }\n else {\n        if (nextXPoint >= cX) {\n          xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n          yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n        }\n else {\n          mapPoints[0]=xPoint;\n          mapPoints[1]=yPoint;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPoint=mapPoints[0];\n          yPoint=mapPoints[1];\n          if (nextXPoint >= cX) {\n            mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n          }\n else {\n            mapPoints[0]=xPointZero;\n          }\n          mapPoints[1]=yPointZero;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPointZero=mapPoints[0];\n          yPointZero=mapPoints[1];\n        }\n      }\n    }\n    if (i == localStart) {\n      float localX=0;\n      float localY=getMeasuredHeight();\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        mapPoints[0]=localX - cX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n      }\n      line.chartPath.moveTo(localX,localY);\n      skipPoints[k]=false;\n    }\n    float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n    if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n      if (!skipPoints[k]) {\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPointZero,yPointZero);\n        }\n      }\n      skipPoints[k]=true;\n    }\n else {\n      if (skipPoints[k]) {\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPointZero,yPointZero);\n        }\n      }\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPoint,yPoint);\n      }\n      skipPoints[k]=false;\n    }\n    if (i == localEnd) {\n      float localX=getMeasuredWidth();\n      float localY=getMeasuredHeight();\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        mapPoints[0]=localX + cX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n      }\n else {\n        line.chartPath.lineTo(localX,localY);\n      }\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        x1=transitionParams.startX[k];\n        y1=transitionParams.startY[k];\n        dX=cX - x1;\n        dY=cY - y1;\n        float angleK=dY / dX;\n        if (angleK > 0) {\n          angle=(float)Math.toDegrees(-Math.atan(angleK));\n        }\n else {\n          angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n        }\n        angle-=90;\n        localX=transitionParams.startX[k];\n        localY=transitionParams.startY[k];\n        mapPoints[0]=localX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n        int endQuarter;\n        int startQuarter;\n        if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n          if (transitionParams.angle[k] == -180f) {\n            endQuarter=0;\n            startQuarter=0;\n          }\n else {\n            endQuarter=0;\n            startQuarter=3;\n          }\n        }\n else {\n          endQuarter=quarterForPoint(xPoint,yPoint);\n          startQuarter=quarterForPoint(localX,localY);\n        }\n        for (int q=endQuarter; q <= startQuarter; q++) {\n          if (q == 0) {\n            line.chartPath.lineTo(getMeasuredWidth(),0);\n          }\n else           if (q == 1) {\n            line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n          }\n else           if (q == 2) {\n            line.chartPath.lineTo(0,getMeasuredHeight());\n          }\n else {\n            line.chartPath.lineTo(0,0);\n          }\n        }\n      }\n    }\n    stackOffset+=height;\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 1363,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 15771,
        "startLineNumber" : 40,
        "startColumnNumber" : 31,
        "endLineNumber" : 375,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n  float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n  float cX=chartArea.centerX();\n  float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n  for (int k=0; k < lines.size(); k++) {\n    lines.get(k).chartPath.reset();\n    lines.get(k).chartPathPicker.reset();\n  }\n  canvas.save();\n  if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n    skipPoints=new boolean[chartData.lines.size()];\n    startFromY=new float[chartData.lines.size()];\n  }\n  boolean hasEmptyPoint=false;\n  int transitionAlpha=255;\n  float transitionProgressHalf=0;\n  if (transitionMode == TRANSITION_MODE_PARENT) {\n    transitionProgressHalf=transitionParams.progress / 0.6f;\n    if (transitionProgressHalf > 1f) {\n      transitionProgressHalf=1f;\n    }\n    ovalPath.reset();\n    float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n    float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n    float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n    RectF rectF=new RectF();\n    rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n    ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n    canvas.clipPath(ovalPath);\n  }\n else   if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n    transitionAlpha=(int)(transitionParams.progress * 255);\n  }\n  float dX=0;\n  float dY=0;\n  float x1=0;\n  float y1=0;\n  float p;\n  if (chartData.xPercentage.length < 2) {\n    p=1f;\n  }\n else {\n    p=chartData.xPercentage[1] * fullWidth;\n  }\n  int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n  int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n  int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n  float startXPoint=0;\n  float endXPoint=0;\n  for (int i=localStart; i <= localEnd; i++) {\n    float stackOffset=0;\n    float sum=0;\n    int lastEnabled=0;\n    int drawingLinesCount=0;\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      if (line.line.y[i] > 0) {\n        sum+=line.line.y[i] * line.alpha;\n        drawingLinesCount++;\n      }\n      lastEnabled=k;\n    }\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      int[] y=line.line.y;\n      float yPercentage;\n      if (drawingLinesCount == 1) {\n        if (y[i] == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=line.alpha;\n        }\n      }\n else {\n        if (sum == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=y[i] * line.alpha / sum;\n        }\n      }\n      float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n      float nextXPoint;\n      if (i == localEnd) {\n        nextXPoint=getMeasuredWidth();\n      }\n else {\n        nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n      }\n      if (yPercentage == 0 && k == lastEnabled) {\n        hasEmptyPoint=true;\n      }\n      float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n      float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n      startFromY[k]=yPoint;\n      float angle=0;\n      float yPointZero=getMeasuredHeight() - chartBottom;\n      float xPointZero=xPoint;\n      if (i == localEnd) {\n        endXPoint=xPoint;\n      }\n else       if (i == localStart) {\n        startXPoint=xPoint;\n      }\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        if (xPoint < cX) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n        }\n else {\n          x1=transitionParams.endX[k];\n          y1=transitionParams.endY[k];\n        }\n        dX=cX - x1;\n        dY=cY - y1;\n        float yTo=dY * (xPoint - x1) / dX + y1;\n        yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        float angleK=dY / dX;\n        if (angleK > 0) {\n          angle=(float)Math.toDegrees(-Math.atan(angleK));\n        }\n else {\n          angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n        }\n        angle-=90;\n        if (xPoint >= cX) {\n          mapPoints[0]=xPoint;\n          mapPoints[1]=yPoint;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPoint=mapPoints[0];\n          yPoint=mapPoints[1];\n          if (xPoint < cX)           xPoint=cX;\n          mapPoints[0]=xPointZero;\n          mapPoints[1]=yPointZero;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          yPointZero=mapPoints[1];\n          if (xPointZero < cX)           xPointZero=cX;\n        }\n else {\n          if (nextXPoint >= cX) {\n            xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n            yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n          }\n else {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (nextXPoint >= cX) {\n              mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n            }\n else {\n              mapPoints[0]=xPointZero;\n            }\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPointZero=mapPoints[0];\n            yPointZero=mapPoints[1];\n          }\n        }\n      }\n      if (i == localStart) {\n        float localX=0;\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX - cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n        line.chartPath.moveTo(localX,localY);\n        skipPoints[k]=false;\n      }\n      float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n      if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n        if (!skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        skipPoints[k]=true;\n      }\n else {\n        if (skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPoint,yPoint);\n        }\n        skipPoints[k]=false;\n      }\n      if (i == localEnd) {\n        float localX=getMeasuredWidth();\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX + cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n else {\n          line.chartPath.lineTo(localX,localY);\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n          dX=cX - x1;\n          dY=cY - y1;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          localX=transitionParams.startX[k];\n          localY=transitionParams.startY[k];\n          mapPoints[0]=localX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n          int endQuarter;\n          int startQuarter;\n          if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n            if (transitionParams.angle[k] == -180f) {\n              endQuarter=0;\n              startQuarter=0;\n            }\n else {\n              endQuarter=0;\n              startQuarter=3;\n            }\n          }\n else {\n            endQuarter=quarterForPoint(xPoint,yPoint);\n            startQuarter=quarterForPoint(localX,localY);\n          }\n          for (int q=endQuarter; q <= startQuarter; q++) {\n            if (q == 0) {\n              line.chartPath.lineTo(getMeasuredWidth(),0);\n            }\n else             if (q == 1) {\n              line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n            }\n else             if (q == 2) {\n              line.chartPath.lineTo(0,getMeasuredHeight());\n            }\n else {\n              line.chartPath.lineTo(0,0);\n            }\n          }\n        }\n      }\n      stackOffset+=height;\n    }\n  }\n  canvas.save();\n  canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n  if (hasEmptyPoint) {\n    canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n  }\n  for (int k=lines.size() - 1; k >= 0; k--) {\n    LineViewData line=lines.get(k);\n    line.paint.setAlpha(transitionAlpha);\n    canvas.drawPath(line.chartPath,line.paint);\n    line.paint.setAlpha(255);\n  }\n  canvas.restore();\n  canvas.restore();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1828,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 15794,
        "startLineNumber" : 40,
        "startColumnNumber" : 8,
        "endLineNumber" : 375,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (chartData != null) {\n  float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n  float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n  float cX=chartArea.centerX();\n  float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n  for (int k=0; k < lines.size(); k++) {\n    lines.get(k).chartPath.reset();\n    lines.get(k).chartPathPicker.reset();\n  }\n  canvas.save();\n  if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n    skipPoints=new boolean[chartData.lines.size()];\n    startFromY=new float[chartData.lines.size()];\n  }\n  boolean hasEmptyPoint=false;\n  int transitionAlpha=255;\n  float transitionProgressHalf=0;\n  if (transitionMode == TRANSITION_MODE_PARENT) {\n    transitionProgressHalf=transitionParams.progress / 0.6f;\n    if (transitionProgressHalf > 1f) {\n      transitionProgressHalf=1f;\n    }\n    ovalPath.reset();\n    float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n    float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n    float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n    RectF rectF=new RectF();\n    rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n    ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n    canvas.clipPath(ovalPath);\n  }\n else   if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n    transitionAlpha=(int)(transitionParams.progress * 255);\n  }\n  float dX=0;\n  float dY=0;\n  float x1=0;\n  float y1=0;\n  float p;\n  if (chartData.xPercentage.length < 2) {\n    p=1f;\n  }\n else {\n    p=chartData.xPercentage[1] * fullWidth;\n  }\n  int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n  int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n  int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n  float startXPoint=0;\n  float endXPoint=0;\n  for (int i=localStart; i <= localEnd; i++) {\n    float stackOffset=0;\n    float sum=0;\n    int lastEnabled=0;\n    int drawingLinesCount=0;\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      if (line.line.y[i] > 0) {\n        sum+=line.line.y[i] * line.alpha;\n        drawingLinesCount++;\n      }\n      lastEnabled=k;\n    }\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      int[] y=line.line.y;\n      float yPercentage;\n      if (drawingLinesCount == 1) {\n        if (y[i] == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=line.alpha;\n        }\n      }\n else {\n        if (sum == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=y[i] * line.alpha / sum;\n        }\n      }\n      float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n      float nextXPoint;\n      if (i == localEnd) {\n        nextXPoint=getMeasuredWidth();\n      }\n else {\n        nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n      }\n      if (yPercentage == 0 && k == lastEnabled) {\n        hasEmptyPoint=true;\n      }\n      float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n      float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n      startFromY[k]=yPoint;\n      float angle=0;\n      float yPointZero=getMeasuredHeight() - chartBottom;\n      float xPointZero=xPoint;\n      if (i == localEnd) {\n        endXPoint=xPoint;\n      }\n else       if (i == localStart) {\n        startXPoint=xPoint;\n      }\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        if (xPoint < cX) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n        }\n else {\n          x1=transitionParams.endX[k];\n          y1=transitionParams.endY[k];\n        }\n        dX=cX - x1;\n        dY=cY - y1;\n        float yTo=dY * (xPoint - x1) / dX + y1;\n        yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        float angleK=dY / dX;\n        if (angleK > 0) {\n          angle=(float)Math.toDegrees(-Math.atan(angleK));\n        }\n else {\n          angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n        }\n        angle-=90;\n        if (xPoint >= cX) {\n          mapPoints[0]=xPoint;\n          mapPoints[1]=yPoint;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPoint=mapPoints[0];\n          yPoint=mapPoints[1];\n          if (xPoint < cX)           xPoint=cX;\n          mapPoints[0]=xPointZero;\n          mapPoints[1]=yPointZero;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          yPointZero=mapPoints[1];\n          if (xPointZero < cX)           xPointZero=cX;\n        }\n else {\n          if (nextXPoint >= cX) {\n            xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n            yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n          }\n else {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (nextXPoint >= cX) {\n              mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n            }\n else {\n              mapPoints[0]=xPointZero;\n            }\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPointZero=mapPoints[0];\n            yPointZero=mapPoints[1];\n          }\n        }\n      }\n      if (i == localStart) {\n        float localX=0;\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX - cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n        line.chartPath.moveTo(localX,localY);\n        skipPoints[k]=false;\n      }\n      float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n      if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n        if (!skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        skipPoints[k]=true;\n      }\n else {\n        if (skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPoint,yPoint);\n        }\n        skipPoints[k]=false;\n      }\n      if (i == localEnd) {\n        float localX=getMeasuredWidth();\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX + cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n else {\n          line.chartPath.lineTo(localX,localY);\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n          dX=cX - x1;\n          dY=cY - y1;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          localX=transitionParams.startX[k];\n          localY=transitionParams.startY[k];\n          mapPoints[0]=localX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n          int endQuarter;\n          int startQuarter;\n          if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n            if (transitionParams.angle[k] == -180f) {\n              endQuarter=0;\n              startQuarter=0;\n            }\n else {\n              endQuarter=0;\n              startQuarter=3;\n            }\n          }\n else {\n            endQuarter=quarterForPoint(xPoint,yPoint);\n            startQuarter=quarterForPoint(localX,localY);\n          }\n          for (int q=endQuarter; q <= startQuarter; q++) {\n            if (q == 0) {\n              line.chartPath.lineTo(getMeasuredWidth(),0);\n            }\n else             if (q == 1) {\n              line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n            }\n else             if (q == 2) {\n              line.chartPath.lineTo(0,getMeasuredHeight());\n            }\n else {\n              line.chartPath.lineTo(0,0);\n            }\n          }\n        }\n      }\n      stackOffset+=height;\n    }\n  }\n  canvas.save();\n  canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n  if (hasEmptyPoint) {\n    canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n  }\n  for (int k=lines.size() - 1; k >= 0; k--) {\n    LineViewData line=lines.get(k);\n    line.paint.setAlpha(transitionAlpha);\n    canvas.drawPath(line.chartPath,line.paint);\n    line.paint.setAlpha(255);\n  }\n  canvas.restore();\n  canvas.restore();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1832,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 15810,
        "startLineNumber" : 39,
        "startColumnNumber" : 44,
        "endLineNumber" : 376,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (chartData != null) {\n    float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n    float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n    float cX=chartArea.centerX();\n    float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n    for (int k=0; k < lines.size(); k++) {\n      lines.get(k).chartPath.reset();\n      lines.get(k).chartPathPicker.reset();\n    }\n    canvas.save();\n    if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n      skipPoints=new boolean[chartData.lines.size()];\n      startFromY=new float[chartData.lines.size()];\n    }\n    boolean hasEmptyPoint=false;\n    int transitionAlpha=255;\n    float transitionProgressHalf=0;\n    if (transitionMode == TRANSITION_MODE_PARENT) {\n      transitionProgressHalf=transitionParams.progress / 0.6f;\n      if (transitionProgressHalf > 1f) {\n        transitionProgressHalf=1f;\n      }\n      ovalPath.reset();\n      float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n      float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n      float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n      RectF rectF=new RectF();\n      rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n      ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n      canvas.clipPath(ovalPath);\n    }\n else     if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n      transitionAlpha=(int)(transitionParams.progress * 255);\n    }\n    float dX=0;\n    float dY=0;\n    float x1=0;\n    float y1=0;\n    float p;\n    if (chartData.xPercentage.length < 2) {\n      p=1f;\n    }\n else {\n      p=chartData.xPercentage[1] * fullWidth;\n    }\n    int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n    int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n    int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n    float startXPoint=0;\n    float endXPoint=0;\n    for (int i=localStart; i <= localEnd; i++) {\n      float stackOffset=0;\n      float sum=0;\n      int lastEnabled=0;\n      int drawingLinesCount=0;\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        if (line.line.y[i] > 0) {\n          sum+=line.line.y[i] * line.alpha;\n          drawingLinesCount++;\n        }\n        lastEnabled=k;\n      }\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        int[] y=line.line.y;\n        float yPercentage;\n        if (drawingLinesCount == 1) {\n          if (y[i] == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=line.alpha;\n          }\n        }\n else {\n          if (sum == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=y[i] * line.alpha / sum;\n          }\n        }\n        float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n        float nextXPoint;\n        if (i == localEnd) {\n          nextXPoint=getMeasuredWidth();\n        }\n else {\n          nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n        }\n        if (yPercentage == 0 && k == lastEnabled) {\n          hasEmptyPoint=true;\n        }\n        float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n        float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n        startFromY[k]=yPoint;\n        float angle=0;\n        float yPointZero=getMeasuredHeight() - chartBottom;\n        float xPointZero=xPoint;\n        if (i == localEnd) {\n          endXPoint=xPoint;\n        }\n else         if (i == localStart) {\n          startXPoint=xPoint;\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          if (xPoint < cX) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n          }\n else {\n            x1=transitionParams.endX[k];\n            y1=transitionParams.endY[k];\n          }\n          dX=cX - x1;\n          dY=cY - y1;\n          float yTo=dY * (xPoint - x1) / dX + y1;\n          yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          if (xPoint >= cX) {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (xPoint < cX)             xPoint=cX;\n            mapPoints[0]=xPointZero;\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            yPointZero=mapPoints[1];\n            if (xPointZero < cX)             xPointZero=cX;\n          }\n else {\n            if (nextXPoint >= cX) {\n              xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n              yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n            }\n else {\n              mapPoints[0]=xPoint;\n              mapPoints[1]=yPoint;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPoint=mapPoints[0];\n              yPoint=mapPoints[1];\n              if (nextXPoint >= cX) {\n                mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n              }\n else {\n                mapPoints[0]=xPointZero;\n              }\n              mapPoints[1]=yPointZero;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPointZero=mapPoints[0];\n              yPointZero=mapPoints[1];\n            }\n          }\n        }\n        if (i == localStart) {\n          float localX=0;\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX - cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n          line.chartPath.moveTo(localX,localY);\n          skipPoints[k]=false;\n        }\n        float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n        if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n          if (!skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          skipPoints[k]=true;\n        }\n else {\n          if (skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPoint,yPoint);\n          }\n          skipPoints[k]=false;\n        }\n        if (i == localEnd) {\n          float localX=getMeasuredWidth();\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX + cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n else {\n            line.chartPath.lineTo(localX,localY);\n          }\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n            dX=cX - x1;\n            dY=cY - y1;\n            float angleK=dY / dX;\n            if (angleK > 0) {\n              angle=(float)Math.toDegrees(-Math.atan(angleK));\n            }\n else {\n              angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n            }\n            angle-=90;\n            localX=transitionParams.startX[k];\n            localY=transitionParams.startY[k];\n            mapPoints[0]=localX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n            int endQuarter;\n            int startQuarter;\n            if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n              if (transitionParams.angle[k] == -180f) {\n                endQuarter=0;\n                startQuarter=0;\n              }\n else {\n                endQuarter=0;\n                startQuarter=3;\n              }\n            }\n else {\n              endQuarter=quarterForPoint(xPoint,yPoint);\n              startQuarter=quarterForPoint(localX,localY);\n            }\n            for (int q=endQuarter; q <= startQuarter; q++) {\n              if (q == 0) {\n                line.chartPath.lineTo(getMeasuredWidth(),0);\n              }\n else               if (q == 1) {\n                line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n              }\n else               if (q == 2) {\n                line.chartPath.lineTo(0,getMeasuredHeight());\n              }\n else {\n                line.chartPath.lineTo(0,0);\n              }\n            }\n          }\n        }\n        stackOffset+=height;\n      }\n    }\n    canvas.save();\n    canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n    if (hasEmptyPoint) {\n      canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n    }\n    for (int k=lines.size() - 1; k >= 0; k--) {\n      LineViewData line=lines.get(k);\n      line.paint.setAlpha(transitionAlpha);\n      canvas.drawPath(line.chartPath,line.paint);\n      line.paint.setAlpha(255);\n    }\n    canvas.restore();\n    canvas.restore();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1833,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 15864,
        "startLineNumber" : 38,
        "startColumnNumber" : 4,
        "endLineNumber" : 376,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@Override protected void drawChart(Canvas canvas){\n  if (chartData != null) {\n    float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n    float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n    float cX=chartArea.centerX();\n    float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n    for (int k=0; k < lines.size(); k++) {\n      lines.get(k).chartPath.reset();\n      lines.get(k).chartPathPicker.reset();\n    }\n    canvas.save();\n    if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n      skipPoints=new boolean[chartData.lines.size()];\n      startFromY=new float[chartData.lines.size()];\n    }\n    boolean hasEmptyPoint=false;\n    int transitionAlpha=255;\n    float transitionProgressHalf=0;\n    if (transitionMode == TRANSITION_MODE_PARENT) {\n      transitionProgressHalf=transitionParams.progress / 0.6f;\n      if (transitionProgressHalf > 1f) {\n        transitionProgressHalf=1f;\n      }\n      ovalPath.reset();\n      float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n      float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n      float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n      RectF rectF=new RectF();\n      rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n      ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n      canvas.clipPath(ovalPath);\n    }\n else     if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n      transitionAlpha=(int)(transitionParams.progress * 255);\n    }\n    float dX=0;\n    float dY=0;\n    float x1=0;\n    float y1=0;\n    float p;\n    if (chartData.xPercentage.length < 2) {\n      p=1f;\n    }\n else {\n      p=chartData.xPercentage[1] * fullWidth;\n    }\n    int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n    int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n    int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n    float startXPoint=0;\n    float endXPoint=0;\n    for (int i=localStart; i <= localEnd; i++) {\n      float stackOffset=0;\n      float sum=0;\n      int lastEnabled=0;\n      int drawingLinesCount=0;\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        if (line.line.y[i] > 0) {\n          sum+=line.line.y[i] * line.alpha;\n          drawingLinesCount++;\n        }\n        lastEnabled=k;\n      }\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        int[] y=line.line.y;\n        float yPercentage;\n        if (drawingLinesCount == 1) {\n          if (y[i] == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=line.alpha;\n          }\n        }\n else {\n          if (sum == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=y[i] * line.alpha / sum;\n          }\n        }\n        float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n        float nextXPoint;\n        if (i == localEnd) {\n          nextXPoint=getMeasuredWidth();\n        }\n else {\n          nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n        }\n        if (yPercentage == 0 && k == lastEnabled) {\n          hasEmptyPoint=true;\n        }\n        float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n        float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n        startFromY[k]=yPoint;\n        float angle=0;\n        float yPointZero=getMeasuredHeight() - chartBottom;\n        float xPointZero=xPoint;\n        if (i == localEnd) {\n          endXPoint=xPoint;\n        }\n else         if (i == localStart) {\n          startXPoint=xPoint;\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          if (xPoint < cX) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n          }\n else {\n            x1=transitionParams.endX[k];\n            y1=transitionParams.endY[k];\n          }\n          dX=cX - x1;\n          dY=cY - y1;\n          float yTo=dY * (xPoint - x1) / dX + y1;\n          yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          if (xPoint >= cX) {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (xPoint < cX)             xPoint=cX;\n            mapPoints[0]=xPointZero;\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            yPointZero=mapPoints[1];\n            if (xPointZero < cX)             xPointZero=cX;\n          }\n else {\n            if (nextXPoint >= cX) {\n              xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n              yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n            }\n else {\n              mapPoints[0]=xPoint;\n              mapPoints[1]=yPoint;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPoint=mapPoints[0];\n              yPoint=mapPoints[1];\n              if (nextXPoint >= cX) {\n                mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n              }\n else {\n                mapPoints[0]=xPointZero;\n              }\n              mapPoints[1]=yPointZero;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPointZero=mapPoints[0];\n              yPointZero=mapPoints[1];\n            }\n          }\n        }\n        if (i == localStart) {\n          float localX=0;\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX - cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n          line.chartPath.moveTo(localX,localY);\n          skipPoints[k]=false;\n        }\n        float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n        if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n          if (!skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          skipPoints[k]=true;\n        }\n else {\n          if (skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPoint,yPoint);\n          }\n          skipPoints[k]=false;\n        }\n        if (i == localEnd) {\n          float localX=getMeasuredWidth();\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX + cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n else {\n            line.chartPath.lineTo(localX,localY);\n          }\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n            dX=cX - x1;\n            dY=cY - y1;\n            float angleK=dY / dX;\n            if (angleK > 0) {\n              angle=(float)Math.toDegrees(-Math.atan(angleK));\n            }\n else {\n              angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n            }\n            angle-=90;\n            localX=transitionParams.startX[k];\n            localY=transitionParams.startY[k];\n            mapPoints[0]=localX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n            int endQuarter;\n            int startQuarter;\n            if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n              if (transitionParams.angle[k] == -180f) {\n                endQuarter=0;\n                startQuarter=0;\n              }\n else {\n                endQuarter=0;\n                startQuarter=3;\n              }\n            }\n else {\n              endQuarter=quarterForPoint(xPoint,yPoint);\n              startQuarter=quarterForPoint(localX,localY);\n            }\n            for (int q=endQuarter; q <= startQuarter; q++) {\n              if (q == 0) {\n                line.chartPath.lineTo(getMeasuredWidth(),0);\n              }\n else               if (q == 1) {\n                line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n              }\n else               if (q == 2) {\n                line.chartPath.lineTo(0,getMeasuredHeight());\n              }\n else {\n                line.chartPath.lineTo(0,0);\n              }\n            }\n          }\n        }\n        stackOffset+=height;\n      }\n    }\n    canvas.save();\n    canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n    if (hasEmptyPoint) {\n      canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n    }\n    for (int k=lines.size() - 1; k >= 0; k--) {\n      LineViewData line=lines.get(k);\n      line.paint.setAlpha(transitionAlpha);\n      canvas.drawPath(line.chartPath,line.paint);\n      line.paint.setAlpha(255);\n    }\n    canvas.restore();\n    canvas.restore();\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1843,
      "astHeight" : 24
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 79,
        "startLineNumber" : 181,
        "startColumnNumber" : 24,
        "endLineNumber" : 181,
        "endColumnNumber" : 103
      },
      "nodeContext" : "yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 13,
      "astHeight" : 7
    },
    "tokenLength" : 5,
    "type" : "float"
  }, {
    "nodeContext" : "yPoint * (1f - transitionProgressHalf)",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 38,
      "startLineNumber" : 213,
      "startColumnNumber" : 54,
      "endLineNumber" : 213,
      "endColumnNumber" : 92
    },
    "astNodeNumber" : 6,
    "astHeight" : 4,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 68,
        "startLineNumber" : 213,
        "startColumnNumber" : 54,
        "endLineNumber" : 213,
        "endColumnNumber" : 122
      },
      "nodeContext" : "yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 10,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.Assignment,rightHandSide]",
      "nodePosition" : {
        "charLength" : 77,
        "startLineNumber" : 213,
        "startColumnNumber" : 45,
        "endLineNumber" : 213,
        "endColumnNumber" : 122
      },
      "nodeContext" : "yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf",
      "nodeType" : "Assignment",
      "astNodeNumber" : 12,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ExpressionStatement,expression]",
      "nodePosition" : {
        "charLength" : 90,
        "startLineNumber" : 213,
        "startColumnNumber" : 32,
        "endLineNumber" : 213,
        "endColumnNumber" : 122
      },
      "nodeContext" : "yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf",
      "nodeType" : "Assignment",
      "astNodeNumber" : 14,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 91,
        "startLineNumber" : 213,
        "startColumnNumber" : 32,
        "endLineNumber" : 213,
        "endColumnNumber" : 123
      },
      "nodeContext" : "yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 15,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 279,
        "startLineNumber" : 211,
        "startColumnNumber" : 50,
        "endLineNumber" : 214,
        "endColumnNumber" : 29
      },
      "nodeContext" : "{\n  xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n  yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 31,
      "astHeight" : 9
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1580,
        "startLineNumber" : 211,
        "startColumnNumber" : 28,
        "endLineNumber" : 235,
        "endColumnNumber" : 29
      },
      "nodeContext" : "if (nextXPoint >= cX) {\n  xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n  yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n}\n else {\n  mapPoints[0]=xPoint;\n  mapPoints[1]=yPoint;\n  matrix.reset();\n  matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n  matrix.mapPoints(mapPoints);\n  xPoint=mapPoints[0];\n  yPoint=mapPoints[1];\n  if (nextXPoint >= cX) {\n    mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n  }\n else {\n    mapPoints[0]=xPointZero;\n  }\n  mapPoints[1]=yPointZero;\n  matrix.reset();\n  matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n  matrix.mapPoints(mapPoints);\n  xPointZero=mapPoints[0];\n  yPointZero=mapPoints[1];\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 169,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 1636,
        "startLineNumber" : 210,
        "startColumnNumber" : 31,
        "endLineNumber" : 236,
        "endColumnNumber" : 25
      },
      "nodeContext" : "{\n  if (nextXPoint >= cX) {\n    xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n    yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n  }\n else {\n    mapPoints[0]=xPoint;\n    mapPoints[1]=yPoint;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n    matrix.mapPoints(mapPoints);\n    xPoint=mapPoints[0];\n    yPoint=mapPoints[1];\n    if (nextXPoint >= cX) {\n      mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n    }\n else {\n      mapPoints[0]=xPointZero;\n    }\n    mapPoints[1]=yPointZero;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n    matrix.mapPoints(mapPoints);\n    xPointZero=mapPoints[0];\n    yPointZero=mapPoints[1];\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 170,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2564,
        "startLineNumber" : 192,
        "startColumnNumber" : 24,
        "endLineNumber" : 236,
        "endColumnNumber" : 25
      },
      "nodeContext" : "if (xPoint >= cX) {\n  mapPoints[0]=xPoint;\n  mapPoints[1]=yPoint;\n  matrix.reset();\n  matrix.postRotate(transitionParams.progress * angle,cX,cY);\n  matrix.mapPoints(mapPoints);\n  xPoint=mapPoints[0];\n  yPoint=mapPoints[1];\n  if (xPoint < cX)   xPoint=cX;\n  mapPoints[0]=xPointZero;\n  mapPoints[1]=yPointZero;\n  matrix.reset();\n  matrix.postRotate(transitionParams.progress * angle,cX,cY);\n  matrix.mapPoints(mapPoints);\n  yPointZero=mapPoints[1];\n  if (xPointZero < cX)   xPointZero=cX;\n}\n else {\n  if (nextXPoint >= cX) {\n    xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n    yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n  }\n else {\n    mapPoints[0]=xPoint;\n    mapPoints[1]=yPoint;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n    matrix.mapPoints(mapPoints);\n    xPoint=mapPoints[0];\n    yPoint=mapPoints[1];\n    if (nextXPoint >= cX) {\n      mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n    }\n else {\n      mapPoints[0]=xPointZero;\n    }\n    mapPoints[1]=yPointZero;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n    matrix.mapPoints(mapPoints);\n    xPointZero=mapPoints[0];\n    yPointZero=mapPoints[1];\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 273,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 3671,
        "startLineNumber" : 168,
        "startColumnNumber" : 86,
        "endLineNumber" : 237,
        "endColumnNumber" : 21
      },
      "nodeContext" : "{\n  if (xPoint < cX) {\n    x1=transitionParams.startX[k];\n    y1=transitionParams.startY[k];\n  }\n else {\n    x1=transitionParams.endX[k];\n    y1=transitionParams.endY[k];\n  }\n  dX=cX - x1;\n  dY=cY - y1;\n  float yTo=dY * (xPoint - x1) / dX + y1;\n  yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n  yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n  float angleK=dY / dX;\n  if (angleK > 0) {\n    angle=(float)Math.toDegrees(-Math.atan(angleK));\n  }\n else {\n    angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n  }\n  angle-=90;\n  if (xPoint >= cX) {\n    mapPoints[0]=xPoint;\n    mapPoints[1]=yPoint;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle,cX,cY);\n    matrix.mapPoints(mapPoints);\n    xPoint=mapPoints[0];\n    yPoint=mapPoints[1];\n    if (xPoint < cX)     xPoint=cX;\n    mapPoints[0]=xPointZero;\n    mapPoints[1]=yPointZero;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle,cX,cY);\n    matrix.mapPoints(mapPoints);\n    yPointZero=mapPoints[1];\n    if (xPointZero < cX)     xPointZero=cX;\n  }\n else {\n    if (nextXPoint >= cX) {\n      xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n      yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n    }\n else {\n      mapPoints[0]=xPoint;\n      mapPoints[1]=yPoint;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPoint=mapPoints[0];\n      yPoint=mapPoints[1];\n      if (nextXPoint >= cX) {\n        mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n      }\n else {\n        mapPoints[0]=xPointZero;\n      }\n      mapPoints[1]=yPointZero;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPointZero=mapPoints[0];\n      yPointZero=mapPoints[1];\n    }\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 409,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3737,
        "startLineNumber" : 168,
        "startColumnNumber" : 20,
        "endLineNumber" : 237,
        "endColumnNumber" : 21
      },
      "nodeContext" : "if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n  if (xPoint < cX) {\n    x1=transitionParams.startX[k];\n    y1=transitionParams.startY[k];\n  }\n else {\n    x1=transitionParams.endX[k];\n    y1=transitionParams.endY[k];\n  }\n  dX=cX - x1;\n  dY=cY - y1;\n  float yTo=dY * (xPoint - x1) / dX + y1;\n  yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n  yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n  float angleK=dY / dX;\n  if (angleK > 0) {\n    angle=(float)Math.toDegrees(-Math.atan(angleK));\n  }\n else {\n    angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n  }\n  angle-=90;\n  if (xPoint >= cX) {\n    mapPoints[0]=xPoint;\n    mapPoints[1]=yPoint;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle,cX,cY);\n    matrix.mapPoints(mapPoints);\n    xPoint=mapPoints[0];\n    yPoint=mapPoints[1];\n    if (xPoint < cX)     xPoint=cX;\n    mapPoints[0]=xPointZero;\n    mapPoints[1]=yPointZero;\n    matrix.reset();\n    matrix.postRotate(transitionParams.progress * angle,cX,cY);\n    matrix.mapPoints(mapPoints);\n    yPointZero=mapPoints[1];\n    if (xPointZero < cX)     xPointZero=cX;\n  }\n else {\n    if (nextXPoint >= cX) {\n      xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n      yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n    }\n else {\n      mapPoints[0]=xPoint;\n      mapPoints[1]=yPoint;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPoint=mapPoints[0];\n      yPoint=mapPoints[1];\n      if (nextXPoint >= cX) {\n        mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n      }\n else {\n        mapPoints[0]=xPointZero;\n      }\n      mapPoints[1]=yPointZero;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPointZero=mapPoints[0];\n      yPointZero=mapPoints[1];\n    }\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 417,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 11685,
        "startLineNumber" : 124,
        "startColumnNumber" : 55,
        "endLineNumber" : 356,
        "endColumnNumber" : 17
      },
      "nodeContext" : "{\n  LineViewData line=lines.get(k);\n  if (!line.enabled && line.alpha == 0)   continue;\n  int[] y=line.line.y;\n  float yPercentage;\n  if (drawingLinesCount == 1) {\n    if (y[i] == 0) {\n      yPercentage=0;\n    }\n else {\n      yPercentage=line.alpha;\n    }\n  }\n else {\n    if (sum == 0) {\n      yPercentage=0;\n    }\n else {\n      yPercentage=y[i] * line.alpha / sum;\n    }\n  }\n  float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n  float nextXPoint;\n  if (i == localEnd) {\n    nextXPoint=getMeasuredWidth();\n  }\n else {\n    nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n  }\n  if (yPercentage == 0 && k == lastEnabled) {\n    hasEmptyPoint=true;\n  }\n  float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n  float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n  startFromY[k]=yPoint;\n  float angle=0;\n  float yPointZero=getMeasuredHeight() - chartBottom;\n  float xPointZero=xPoint;\n  if (i == localEnd) {\n    endXPoint=xPoint;\n  }\n else   if (i == localStart) {\n    startXPoint=xPoint;\n  }\n  if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n    if (xPoint < cX) {\n      x1=transitionParams.startX[k];\n      y1=transitionParams.startY[k];\n    }\n else {\n      x1=transitionParams.endX[k];\n      y1=transitionParams.endY[k];\n    }\n    dX=cX - x1;\n    dY=cY - y1;\n    float yTo=dY * (xPoint - x1) / dX + y1;\n    yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n    yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n    float angleK=dY / dX;\n    if (angleK > 0) {\n      angle=(float)Math.toDegrees(-Math.atan(angleK));\n    }\n else {\n      angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n    }\n    angle-=90;\n    if (xPoint >= cX) {\n      mapPoints[0]=xPoint;\n      mapPoints[1]=yPoint;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle,cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPoint=mapPoints[0];\n      yPoint=mapPoints[1];\n      if (xPoint < cX)       xPoint=cX;\n      mapPoints[0]=xPointZero;\n      mapPoints[1]=yPointZero;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle,cX,cY);\n      matrix.mapPoints(mapPoints);\n      yPointZero=mapPoints[1];\n      if (xPointZero < cX)       xPointZero=cX;\n    }\n else {\n      if (nextXPoint >= cX) {\n        xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n        yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n      }\n else {\n        mapPoints[0]=xPoint;\n        mapPoints[1]=yPoint;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPoint=mapPoints[0];\n        yPoint=mapPoints[1];\n        if (nextXPoint >= cX) {\n          mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n        }\n else {\n          mapPoints[0]=xPointZero;\n        }\n        mapPoints[1]=yPointZero;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPointZero=mapPoints[0];\n        yPointZero=mapPoints[1];\n      }\n    }\n  }\n  if (i == localStart) {\n    float localX=0;\n    float localY=getMeasuredHeight();\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      mapPoints[0]=localX - cX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n    }\n    line.chartPath.moveTo(localX,localY);\n    skipPoints[k]=false;\n  }\n  float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n  if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n    if (!skipPoints[k]) {\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPointZero,yPointZero);\n      }\n    }\n    skipPoints[k]=true;\n  }\n else {\n    if (skipPoints[k]) {\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPointZero,yPointZero);\n      }\n    }\n    if (k == lastEnabled) {\n      line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n    }\n else {\n      line.chartPath.lineTo(xPoint,yPoint);\n    }\n    skipPoints[k]=false;\n  }\n  if (i == localEnd) {\n    float localX=getMeasuredWidth();\n    float localY=getMeasuredHeight();\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      mapPoints[0]=localX + cX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n    }\n else {\n      line.chartPath.lineTo(localX,localY);\n    }\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      x1=transitionParams.startX[k];\n      y1=transitionParams.startY[k];\n      dX=cX - x1;\n      dY=cY - y1;\n      float angleK=dY / dX;\n      if (angleK > 0) {\n        angle=(float)Math.toDegrees(-Math.atan(angleK));\n      }\n else {\n        angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n      }\n      angle-=90;\n      localX=transitionParams.startX[k];\n      localY=transitionParams.startY[k];\n      mapPoints[0]=localX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n      int endQuarter;\n      int startQuarter;\n      if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n        if (transitionParams.angle[k] == -180f) {\n          endQuarter=0;\n          startQuarter=0;\n        }\n else {\n          endQuarter=0;\n          startQuarter=3;\n        }\n      }\n else {\n        endQuarter=quarterForPoint(xPoint,yPoint);\n        startQuarter=quarterForPoint(localX,localY);\n      }\n      for (int q=endQuarter; q <= startQuarter; q++) {\n        if (q == 0) {\n          line.chartPath.lineTo(getMeasuredWidth(),0);\n        }\n else         if (q == 1) {\n          line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n        }\n else         if (q == 2) {\n          line.chartPath.lineTo(0,getMeasuredHeight());\n        }\n else {\n          line.chartPath.lineTo(0,0);\n        }\n      }\n    }\n  }\n  stackOffset+=height;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1251,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 11724,
        "startLineNumber" : 124,
        "startColumnNumber" : 16,
        "endLineNumber" : 356,
        "endColumnNumber" : 17
      },
      "nodeContext" : "for (int k=0; k < lines.size(); k++) {\n  LineViewData line=lines.get(k);\n  if (!line.enabled && line.alpha == 0)   continue;\n  int[] y=line.line.y;\n  float yPercentage;\n  if (drawingLinesCount == 1) {\n    if (y[i] == 0) {\n      yPercentage=0;\n    }\n else {\n      yPercentage=line.alpha;\n    }\n  }\n else {\n    if (sum == 0) {\n      yPercentage=0;\n    }\n else {\n      yPercentage=y[i] * line.alpha / sum;\n    }\n  }\n  float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n  float nextXPoint;\n  if (i == localEnd) {\n    nextXPoint=getMeasuredWidth();\n  }\n else {\n    nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n  }\n  if (yPercentage == 0 && k == lastEnabled) {\n    hasEmptyPoint=true;\n  }\n  float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n  float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n  startFromY[k]=yPoint;\n  float angle=0;\n  float yPointZero=getMeasuredHeight() - chartBottom;\n  float xPointZero=xPoint;\n  if (i == localEnd) {\n    endXPoint=xPoint;\n  }\n else   if (i == localStart) {\n    startXPoint=xPoint;\n  }\n  if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n    if (xPoint < cX) {\n      x1=transitionParams.startX[k];\n      y1=transitionParams.startY[k];\n    }\n else {\n      x1=transitionParams.endX[k];\n      y1=transitionParams.endY[k];\n    }\n    dX=cX - x1;\n    dY=cY - y1;\n    float yTo=dY * (xPoint - x1) / dX + y1;\n    yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n    yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n    float angleK=dY / dX;\n    if (angleK > 0) {\n      angle=(float)Math.toDegrees(-Math.atan(angleK));\n    }\n else {\n      angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n    }\n    angle-=90;\n    if (xPoint >= cX) {\n      mapPoints[0]=xPoint;\n      mapPoints[1]=yPoint;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle,cX,cY);\n      matrix.mapPoints(mapPoints);\n      xPoint=mapPoints[0];\n      yPoint=mapPoints[1];\n      if (xPoint < cX)       xPoint=cX;\n      mapPoints[0]=xPointZero;\n      mapPoints[1]=yPointZero;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle,cX,cY);\n      matrix.mapPoints(mapPoints);\n      yPointZero=mapPoints[1];\n      if (xPointZero < cX)       xPointZero=cX;\n    }\n else {\n      if (nextXPoint >= cX) {\n        xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n        yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n      }\n else {\n        mapPoints[0]=xPoint;\n        mapPoints[1]=yPoint;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPoint=mapPoints[0];\n        yPoint=mapPoints[1];\n        if (nextXPoint >= cX) {\n          mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n        }\n else {\n          mapPoints[0]=xPointZero;\n        }\n        mapPoints[1]=yPointZero;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPointZero=mapPoints[0];\n        yPointZero=mapPoints[1];\n      }\n    }\n  }\n  if (i == localStart) {\n    float localX=0;\n    float localY=getMeasuredHeight();\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      mapPoints[0]=localX - cX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n    }\n    line.chartPath.moveTo(localX,localY);\n    skipPoints[k]=false;\n  }\n  float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n  if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n    if (!skipPoints[k]) {\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPointZero,yPointZero);\n      }\n    }\n    skipPoints[k]=true;\n  }\n else {\n    if (skipPoints[k]) {\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPointZero,yPointZero);\n      }\n    }\n    if (k == lastEnabled) {\n      line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n    }\n else {\n      line.chartPath.lineTo(xPoint,yPoint);\n    }\n    skipPoints[k]=false;\n  }\n  if (i == localEnd) {\n    float localX=getMeasuredWidth();\n    float localY=getMeasuredHeight();\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      mapPoints[0]=localX + cX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n    }\n else {\n      line.chartPath.lineTo(localX,localY);\n    }\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      x1=transitionParams.startX[k];\n      y1=transitionParams.startY[k];\n      dX=cX - x1;\n      dY=cY - y1;\n      float angleK=dY / dX;\n      if (angleK > 0) {\n        angle=(float)Math.toDegrees(-Math.atan(angleK));\n      }\n else {\n        angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n      }\n      angle-=90;\n      localX=transitionParams.startX[k];\n      localY=transitionParams.startY[k];\n      mapPoints[0]=localX;\n      mapPoints[1]=localY;\n      matrix.reset();\n      matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n      matrix.mapPoints(mapPoints);\n      localX=mapPoints[0];\n      localY=mapPoints[1];\n      int endQuarter;\n      int startQuarter;\n      if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n        if (transitionParams.angle[k] == -180f) {\n          endQuarter=0;\n          startQuarter=0;\n        }\n else {\n          endQuarter=0;\n          startQuarter=3;\n        }\n      }\n else {\n        endQuarter=quarterForPoint(xPoint,yPoint);\n        startQuarter=quarterForPoint(localX,localY);\n      }\n      for (int q=endQuarter; q <= startQuarter; q++) {\n        if (q == 0) {\n          line.chartPath.lineTo(getMeasuredWidth(),0);\n        }\n else         if (q == 1) {\n          line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n        }\n else         if (q == 2) {\n          line.chartPath.lineTo(0,getMeasuredHeight());\n        }\n else {\n          line.chartPath.lineTo(0,0);\n        }\n      }\n    }\n  }\n  stackOffset+=height;\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 1264,
      "astHeight" : 18
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 12315,
        "startLineNumber" : 108,
        "startColumnNumber" : 57,
        "endLineNumber" : 357,
        "endColumnNumber" : 13
      },
      "nodeContext" : "{\n  float stackOffset=0;\n  float sum=0;\n  int lastEnabled=0;\n  int drawingLinesCount=0;\n  for (int k=0; k < lines.size(); k++) {\n    LineViewData line=lines.get(k);\n    if (!line.enabled && line.alpha == 0)     continue;\n    if (line.line.y[i] > 0) {\n      sum+=line.line.y[i] * line.alpha;\n      drawingLinesCount++;\n    }\n    lastEnabled=k;\n  }\n  for (int k=0; k < lines.size(); k++) {\n    LineViewData line=lines.get(k);\n    if (!line.enabled && line.alpha == 0)     continue;\n    int[] y=line.line.y;\n    float yPercentage;\n    if (drawingLinesCount == 1) {\n      if (y[i] == 0) {\n        yPercentage=0;\n      }\n else {\n        yPercentage=line.alpha;\n      }\n    }\n else {\n      if (sum == 0) {\n        yPercentage=0;\n      }\n else {\n        yPercentage=y[i] * line.alpha / sum;\n      }\n    }\n    float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n    float nextXPoint;\n    if (i == localEnd) {\n      nextXPoint=getMeasuredWidth();\n    }\n else {\n      nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n    }\n    if (yPercentage == 0 && k == lastEnabled) {\n      hasEmptyPoint=true;\n    }\n    float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n    float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n    startFromY[k]=yPoint;\n    float angle=0;\n    float yPointZero=getMeasuredHeight() - chartBottom;\n    float xPointZero=xPoint;\n    if (i == localEnd) {\n      endXPoint=xPoint;\n    }\n else     if (i == localStart) {\n      startXPoint=xPoint;\n    }\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      if (xPoint < cX) {\n        x1=transitionParams.startX[k];\n        y1=transitionParams.startY[k];\n      }\n else {\n        x1=transitionParams.endX[k];\n        y1=transitionParams.endY[k];\n      }\n      dX=cX - x1;\n      dY=cY - y1;\n      float yTo=dY * (xPoint - x1) / dX + y1;\n      yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n      yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n      float angleK=dY / dX;\n      if (angleK > 0) {\n        angle=(float)Math.toDegrees(-Math.atan(angleK));\n      }\n else {\n        angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n      }\n      angle-=90;\n      if (xPoint >= cX) {\n        mapPoints[0]=xPoint;\n        mapPoints[1]=yPoint;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle,cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPoint=mapPoints[0];\n        yPoint=mapPoints[1];\n        if (xPoint < cX)         xPoint=cX;\n        mapPoints[0]=xPointZero;\n        mapPoints[1]=yPointZero;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle,cX,cY);\n        matrix.mapPoints(mapPoints);\n        yPointZero=mapPoints[1];\n        if (xPointZero < cX)         xPointZero=cX;\n      }\n else {\n        if (nextXPoint >= cX) {\n          xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n          yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n        }\n else {\n          mapPoints[0]=xPoint;\n          mapPoints[1]=yPoint;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPoint=mapPoints[0];\n          yPoint=mapPoints[1];\n          if (nextXPoint >= cX) {\n            mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n          }\n else {\n            mapPoints[0]=xPointZero;\n          }\n          mapPoints[1]=yPointZero;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPointZero=mapPoints[0];\n          yPointZero=mapPoints[1];\n        }\n      }\n    }\n    if (i == localStart) {\n      float localX=0;\n      float localY=getMeasuredHeight();\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        mapPoints[0]=localX - cX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n      }\n      line.chartPath.moveTo(localX,localY);\n      skipPoints[k]=false;\n    }\n    float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n    if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n      if (!skipPoints[k]) {\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPointZero,yPointZero);\n        }\n      }\n      skipPoints[k]=true;\n    }\n else {\n      if (skipPoints[k]) {\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPointZero,yPointZero);\n        }\n      }\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPoint,yPoint);\n      }\n      skipPoints[k]=false;\n    }\n    if (i == localEnd) {\n      float localX=getMeasuredWidth();\n      float localY=getMeasuredHeight();\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        mapPoints[0]=localX + cX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n      }\n else {\n        line.chartPath.lineTo(localX,localY);\n      }\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        x1=transitionParams.startX[k];\n        y1=transitionParams.startY[k];\n        dX=cX - x1;\n        dY=cY - y1;\n        float angleK=dY / dX;\n        if (angleK > 0) {\n          angle=(float)Math.toDegrees(-Math.atan(angleK));\n        }\n else {\n          angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n        }\n        angle-=90;\n        localX=transitionParams.startX[k];\n        localY=transitionParams.startY[k];\n        mapPoints[0]=localX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n        int endQuarter;\n        int startQuarter;\n        if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n          if (transitionParams.angle[k] == -180f) {\n            endQuarter=0;\n            startQuarter=0;\n          }\n else {\n            endQuarter=0;\n            startQuarter=3;\n          }\n        }\n else {\n          endQuarter=quarterForPoint(xPoint,yPoint);\n          startQuarter=quarterForPoint(localX,localY);\n        }\n        for (int q=endQuarter; q <= startQuarter; q++) {\n          if (q == 0) {\n            line.chartPath.lineTo(getMeasuredWidth(),0);\n          }\n else           if (q == 1) {\n            line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n          }\n else           if (q == 2) {\n            line.chartPath.lineTo(0,getMeasuredHeight());\n          }\n else {\n            line.chartPath.lineTo(0,0);\n          }\n        }\n      }\n    }\n    stackOffset+=height;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1352,
      "astHeight" : 19
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 12360,
        "startLineNumber" : 108,
        "startColumnNumber" : 12,
        "endLineNumber" : 357,
        "endColumnNumber" : 13
      },
      "nodeContext" : "for (int i=localStart; i <= localEnd; i++) {\n  float stackOffset=0;\n  float sum=0;\n  int lastEnabled=0;\n  int drawingLinesCount=0;\n  for (int k=0; k < lines.size(); k++) {\n    LineViewData line=lines.get(k);\n    if (!line.enabled && line.alpha == 0)     continue;\n    if (line.line.y[i] > 0) {\n      sum+=line.line.y[i] * line.alpha;\n      drawingLinesCount++;\n    }\n    lastEnabled=k;\n  }\n  for (int k=0; k < lines.size(); k++) {\n    LineViewData line=lines.get(k);\n    if (!line.enabled && line.alpha == 0)     continue;\n    int[] y=line.line.y;\n    float yPercentage;\n    if (drawingLinesCount == 1) {\n      if (y[i] == 0) {\n        yPercentage=0;\n      }\n else {\n        yPercentage=line.alpha;\n      }\n    }\n else {\n      if (sum == 0) {\n        yPercentage=0;\n      }\n else {\n        yPercentage=y[i] * line.alpha / sum;\n      }\n    }\n    float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n    float nextXPoint;\n    if (i == localEnd) {\n      nextXPoint=getMeasuredWidth();\n    }\n else {\n      nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n    }\n    if (yPercentage == 0 && k == lastEnabled) {\n      hasEmptyPoint=true;\n    }\n    float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n    float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n    startFromY[k]=yPoint;\n    float angle=0;\n    float yPointZero=getMeasuredHeight() - chartBottom;\n    float xPointZero=xPoint;\n    if (i == localEnd) {\n      endXPoint=xPoint;\n    }\n else     if (i == localStart) {\n      startXPoint=xPoint;\n    }\n    if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n      if (xPoint < cX) {\n        x1=transitionParams.startX[k];\n        y1=transitionParams.startY[k];\n      }\n else {\n        x1=transitionParams.endX[k];\n        y1=transitionParams.endY[k];\n      }\n      dX=cX - x1;\n      dY=cY - y1;\n      float yTo=dY * (xPoint - x1) / dX + y1;\n      yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n      yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n      float angleK=dY / dX;\n      if (angleK > 0) {\n        angle=(float)Math.toDegrees(-Math.atan(angleK));\n      }\n else {\n        angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n      }\n      angle-=90;\n      if (xPoint >= cX) {\n        mapPoints[0]=xPoint;\n        mapPoints[1]=yPoint;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle,cX,cY);\n        matrix.mapPoints(mapPoints);\n        xPoint=mapPoints[0];\n        yPoint=mapPoints[1];\n        if (xPoint < cX)         xPoint=cX;\n        mapPoints[0]=xPointZero;\n        mapPoints[1]=yPointZero;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle,cX,cY);\n        matrix.mapPoints(mapPoints);\n        yPointZero=mapPoints[1];\n        if (xPointZero < cX)         xPointZero=cX;\n      }\n else {\n        if (nextXPoint >= cX) {\n          xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n          yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n        }\n else {\n          mapPoints[0]=xPoint;\n          mapPoints[1]=yPoint;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPoint=mapPoints[0];\n          yPoint=mapPoints[1];\n          if (nextXPoint >= cX) {\n            mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n          }\n else {\n            mapPoints[0]=xPointZero;\n          }\n          mapPoints[1]=yPointZero;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPointZero=mapPoints[0];\n          yPointZero=mapPoints[1];\n        }\n      }\n    }\n    if (i == localStart) {\n      float localX=0;\n      float localY=getMeasuredHeight();\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        mapPoints[0]=localX - cX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n      }\n      line.chartPath.moveTo(localX,localY);\n      skipPoints[k]=false;\n    }\n    float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n    if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n      if (!skipPoints[k]) {\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPointZero,yPointZero);\n        }\n      }\n      skipPoints[k]=true;\n    }\n else {\n      if (skipPoints[k]) {\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPointZero,yPointZero);\n        }\n      }\n      if (k == lastEnabled) {\n        line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n      }\n else {\n        line.chartPath.lineTo(xPoint,yPoint);\n      }\n      skipPoints[k]=false;\n    }\n    if (i == localEnd) {\n      float localX=getMeasuredWidth();\n      float localY=getMeasuredHeight();\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        mapPoints[0]=localX + cX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n      }\n else {\n        line.chartPath.lineTo(localX,localY);\n      }\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        x1=transitionParams.startX[k];\n        y1=transitionParams.startY[k];\n        dX=cX - x1;\n        dY=cY - y1;\n        float angleK=dY / dX;\n        if (angleK > 0) {\n          angle=(float)Math.toDegrees(-Math.atan(angleK));\n        }\n else {\n          angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n        }\n        angle-=90;\n        localX=transitionParams.startX[k];\n        localY=transitionParams.startY[k];\n        mapPoints[0]=localX;\n        mapPoints[1]=localY;\n        matrix.reset();\n        matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n        matrix.mapPoints(mapPoints);\n        localX=mapPoints[0];\n        localY=mapPoints[1];\n        int endQuarter;\n        int startQuarter;\n        if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n          if (transitionParams.angle[k] == -180f) {\n            endQuarter=0;\n            startQuarter=0;\n          }\n else {\n            endQuarter=0;\n            startQuarter=3;\n          }\n        }\n else {\n          endQuarter=quarterForPoint(xPoint,yPoint);\n          startQuarter=quarterForPoint(localX,localY);\n        }\n        for (int q=endQuarter; q <= startQuarter; q++) {\n          if (q == 0) {\n            line.chartPath.lineTo(getMeasuredWidth(),0);\n          }\n else           if (q == 1) {\n            line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n          }\n else           if (q == 2) {\n            line.chartPath.lineTo(0,getMeasuredHeight());\n          }\n else {\n            line.chartPath.lineTo(0,0);\n          }\n        }\n      }\n    }\n    stackOffset+=height;\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 1363,
      "astHeight" : 20
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 15771,
        "startLineNumber" : 40,
        "startColumnNumber" : 31,
        "endLineNumber" : 375,
        "endColumnNumber" : 9
      },
      "nodeContext" : "{\n  float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n  float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n  float cX=chartArea.centerX();\n  float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n  for (int k=0; k < lines.size(); k++) {\n    lines.get(k).chartPath.reset();\n    lines.get(k).chartPathPicker.reset();\n  }\n  canvas.save();\n  if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n    skipPoints=new boolean[chartData.lines.size()];\n    startFromY=new float[chartData.lines.size()];\n  }\n  boolean hasEmptyPoint=false;\n  int transitionAlpha=255;\n  float transitionProgressHalf=0;\n  if (transitionMode == TRANSITION_MODE_PARENT) {\n    transitionProgressHalf=transitionParams.progress / 0.6f;\n    if (transitionProgressHalf > 1f) {\n      transitionProgressHalf=1f;\n    }\n    ovalPath.reset();\n    float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n    float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n    float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n    RectF rectF=new RectF();\n    rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n    ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n    canvas.clipPath(ovalPath);\n  }\n else   if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n    transitionAlpha=(int)(transitionParams.progress * 255);\n  }\n  float dX=0;\n  float dY=0;\n  float x1=0;\n  float y1=0;\n  float p;\n  if (chartData.xPercentage.length < 2) {\n    p=1f;\n  }\n else {\n    p=chartData.xPercentage[1] * fullWidth;\n  }\n  int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n  int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n  int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n  float startXPoint=0;\n  float endXPoint=0;\n  for (int i=localStart; i <= localEnd; i++) {\n    float stackOffset=0;\n    float sum=0;\n    int lastEnabled=0;\n    int drawingLinesCount=0;\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      if (line.line.y[i] > 0) {\n        sum+=line.line.y[i] * line.alpha;\n        drawingLinesCount++;\n      }\n      lastEnabled=k;\n    }\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      int[] y=line.line.y;\n      float yPercentage;\n      if (drawingLinesCount == 1) {\n        if (y[i] == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=line.alpha;\n        }\n      }\n else {\n        if (sum == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=y[i] * line.alpha / sum;\n        }\n      }\n      float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n      float nextXPoint;\n      if (i == localEnd) {\n        nextXPoint=getMeasuredWidth();\n      }\n else {\n        nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n      }\n      if (yPercentage == 0 && k == lastEnabled) {\n        hasEmptyPoint=true;\n      }\n      float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n      float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n      startFromY[k]=yPoint;\n      float angle=0;\n      float yPointZero=getMeasuredHeight() - chartBottom;\n      float xPointZero=xPoint;\n      if (i == localEnd) {\n        endXPoint=xPoint;\n      }\n else       if (i == localStart) {\n        startXPoint=xPoint;\n      }\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        if (xPoint < cX) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n        }\n else {\n          x1=transitionParams.endX[k];\n          y1=transitionParams.endY[k];\n        }\n        dX=cX - x1;\n        dY=cY - y1;\n        float yTo=dY * (xPoint - x1) / dX + y1;\n        yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        float angleK=dY / dX;\n        if (angleK > 0) {\n          angle=(float)Math.toDegrees(-Math.atan(angleK));\n        }\n else {\n          angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n        }\n        angle-=90;\n        if (xPoint >= cX) {\n          mapPoints[0]=xPoint;\n          mapPoints[1]=yPoint;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPoint=mapPoints[0];\n          yPoint=mapPoints[1];\n          if (xPoint < cX)           xPoint=cX;\n          mapPoints[0]=xPointZero;\n          mapPoints[1]=yPointZero;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          yPointZero=mapPoints[1];\n          if (xPointZero < cX)           xPointZero=cX;\n        }\n else {\n          if (nextXPoint >= cX) {\n            xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n            yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n          }\n else {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (nextXPoint >= cX) {\n              mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n            }\n else {\n              mapPoints[0]=xPointZero;\n            }\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPointZero=mapPoints[0];\n            yPointZero=mapPoints[1];\n          }\n        }\n      }\n      if (i == localStart) {\n        float localX=0;\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX - cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n        line.chartPath.moveTo(localX,localY);\n        skipPoints[k]=false;\n      }\n      float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n      if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n        if (!skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        skipPoints[k]=true;\n      }\n else {\n        if (skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPoint,yPoint);\n        }\n        skipPoints[k]=false;\n      }\n      if (i == localEnd) {\n        float localX=getMeasuredWidth();\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX + cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n else {\n          line.chartPath.lineTo(localX,localY);\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n          dX=cX - x1;\n          dY=cY - y1;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          localX=transitionParams.startX[k];\n          localY=transitionParams.startY[k];\n          mapPoints[0]=localX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n          int endQuarter;\n          int startQuarter;\n          if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n            if (transitionParams.angle[k] == -180f) {\n              endQuarter=0;\n              startQuarter=0;\n            }\n else {\n              endQuarter=0;\n              startQuarter=3;\n            }\n          }\n else {\n            endQuarter=quarterForPoint(xPoint,yPoint);\n            startQuarter=quarterForPoint(localX,localY);\n          }\n          for (int q=endQuarter; q <= startQuarter; q++) {\n            if (q == 0) {\n              line.chartPath.lineTo(getMeasuredWidth(),0);\n            }\n else             if (q == 1) {\n              line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n            }\n else             if (q == 2) {\n              line.chartPath.lineTo(0,getMeasuredHeight());\n            }\n else {\n              line.chartPath.lineTo(0,0);\n            }\n          }\n        }\n      }\n      stackOffset+=height;\n    }\n  }\n  canvas.save();\n  canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n  if (hasEmptyPoint) {\n    canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n  }\n  for (int k=lines.size() - 1; k >= 0; k--) {\n    LineViewData line=lines.get(k);\n    line.paint.setAlpha(transitionAlpha);\n    canvas.drawPath(line.chartPath,line.paint);\n    line.paint.setAlpha(255);\n  }\n  canvas.restore();\n  canvas.restore();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1828,
      "astHeight" : 21
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 15794,
        "startLineNumber" : 40,
        "startColumnNumber" : 8,
        "endLineNumber" : 375,
        "endColumnNumber" : 9
      },
      "nodeContext" : "if (chartData != null) {\n  float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n  float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n  float cX=chartArea.centerX();\n  float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n  for (int k=0; k < lines.size(); k++) {\n    lines.get(k).chartPath.reset();\n    lines.get(k).chartPathPicker.reset();\n  }\n  canvas.save();\n  if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n    skipPoints=new boolean[chartData.lines.size()];\n    startFromY=new float[chartData.lines.size()];\n  }\n  boolean hasEmptyPoint=false;\n  int transitionAlpha=255;\n  float transitionProgressHalf=0;\n  if (transitionMode == TRANSITION_MODE_PARENT) {\n    transitionProgressHalf=transitionParams.progress / 0.6f;\n    if (transitionProgressHalf > 1f) {\n      transitionProgressHalf=1f;\n    }\n    ovalPath.reset();\n    float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n    float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n    float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n    RectF rectF=new RectF();\n    rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n    ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n    canvas.clipPath(ovalPath);\n  }\n else   if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n    transitionAlpha=(int)(transitionParams.progress * 255);\n  }\n  float dX=0;\n  float dY=0;\n  float x1=0;\n  float y1=0;\n  float p;\n  if (chartData.xPercentage.length < 2) {\n    p=1f;\n  }\n else {\n    p=chartData.xPercentage[1] * fullWidth;\n  }\n  int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n  int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n  int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n  float startXPoint=0;\n  float endXPoint=0;\n  for (int i=localStart; i <= localEnd; i++) {\n    float stackOffset=0;\n    float sum=0;\n    int lastEnabled=0;\n    int drawingLinesCount=0;\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      if (line.line.y[i] > 0) {\n        sum+=line.line.y[i] * line.alpha;\n        drawingLinesCount++;\n      }\n      lastEnabled=k;\n    }\n    for (int k=0; k < lines.size(); k++) {\n      LineViewData line=lines.get(k);\n      if (!line.enabled && line.alpha == 0)       continue;\n      int[] y=line.line.y;\n      float yPercentage;\n      if (drawingLinesCount == 1) {\n        if (y[i] == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=line.alpha;\n        }\n      }\n else {\n        if (sum == 0) {\n          yPercentage=0;\n        }\n else {\n          yPercentage=y[i] * line.alpha / sum;\n        }\n      }\n      float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n      float nextXPoint;\n      if (i == localEnd) {\n        nextXPoint=getMeasuredWidth();\n      }\n else {\n        nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n      }\n      if (yPercentage == 0 && k == lastEnabled) {\n        hasEmptyPoint=true;\n      }\n      float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n      float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n      startFromY[k]=yPoint;\n      float angle=0;\n      float yPointZero=getMeasuredHeight() - chartBottom;\n      float xPointZero=xPoint;\n      if (i == localEnd) {\n        endXPoint=xPoint;\n      }\n else       if (i == localStart) {\n        startXPoint=xPoint;\n      }\n      if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n        if (xPoint < cX) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n        }\n else {\n          x1=transitionParams.endX[k];\n          y1=transitionParams.endY[k];\n        }\n        dX=cX - x1;\n        dY=cY - y1;\n        float yTo=dY * (xPoint - x1) / dX + y1;\n        yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n        float angleK=dY / dX;\n        if (angleK > 0) {\n          angle=(float)Math.toDegrees(-Math.atan(angleK));\n        }\n else {\n          angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n        }\n        angle-=90;\n        if (xPoint >= cX) {\n          mapPoints[0]=xPoint;\n          mapPoints[1]=yPoint;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          xPoint=mapPoints[0];\n          yPoint=mapPoints[1];\n          if (xPoint < cX)           xPoint=cX;\n          mapPoints[0]=xPointZero;\n          mapPoints[1]=yPointZero;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle,cX,cY);\n          matrix.mapPoints(mapPoints);\n          yPointZero=mapPoints[1];\n          if (xPointZero < cX)           xPointZero=cX;\n        }\n else {\n          if (nextXPoint >= cX) {\n            xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n            yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n          }\n else {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (nextXPoint >= cX) {\n              mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n            }\n else {\n              mapPoints[0]=xPointZero;\n            }\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPointZero=mapPoints[0];\n            yPointZero=mapPoints[1];\n          }\n        }\n      }\n      if (i == localStart) {\n        float localX=0;\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX - cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n        line.chartPath.moveTo(localX,localY);\n        skipPoints[k]=false;\n      }\n      float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n      if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n        if (!skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        skipPoints[k]=true;\n      }\n else {\n        if (skipPoints[k]) {\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPointZero,yPointZero);\n          }\n        }\n        if (k == lastEnabled) {\n          line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n        }\n else {\n          line.chartPath.lineTo(xPoint,yPoint);\n        }\n        skipPoints[k]=false;\n      }\n      if (i == localEnd) {\n        float localX=getMeasuredWidth();\n        float localY=getMeasuredHeight();\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          mapPoints[0]=localX + cX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n        }\n else {\n          line.chartPath.lineTo(localX,localY);\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          x1=transitionParams.startX[k];\n          y1=transitionParams.startY[k];\n          dX=cX - x1;\n          dY=cY - y1;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          localX=transitionParams.startX[k];\n          localY=transitionParams.startY[k];\n          mapPoints[0]=localX;\n          mapPoints[1]=localY;\n          matrix.reset();\n          matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n          matrix.mapPoints(mapPoints);\n          localX=mapPoints[0];\n          localY=mapPoints[1];\n          int endQuarter;\n          int startQuarter;\n          if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n            if (transitionParams.angle[k] == -180f) {\n              endQuarter=0;\n              startQuarter=0;\n            }\n else {\n              endQuarter=0;\n              startQuarter=3;\n            }\n          }\n else {\n            endQuarter=quarterForPoint(xPoint,yPoint);\n            startQuarter=quarterForPoint(localX,localY);\n          }\n          for (int q=endQuarter; q <= startQuarter; q++) {\n            if (q == 0) {\n              line.chartPath.lineTo(getMeasuredWidth(),0);\n            }\n else             if (q == 1) {\n              line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n            }\n else             if (q == 2) {\n              line.chartPath.lineTo(0,getMeasuredHeight());\n            }\n else {\n              line.chartPath.lineTo(0,0);\n            }\n          }\n        }\n      }\n      stackOffset+=height;\n    }\n  }\n  canvas.save();\n  canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n  if (hasEmptyPoint) {\n    canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n  }\n  for (int k=lines.size() - 1; k >= 0; k--) {\n    LineViewData line=lines.get(k);\n    line.paint.setAlpha(transitionAlpha);\n    canvas.drawPath(line.chartPath,line.paint);\n    line.paint.setAlpha(255);\n  }\n  canvas.restore();\n  canvas.restore();\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 1832,
      "astHeight" : 22
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 15810,
        "startLineNumber" : 39,
        "startColumnNumber" : 44,
        "endLineNumber" : 376,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  if (chartData != null) {\n    float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n    float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n    float cX=chartArea.centerX();\n    float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n    for (int k=0; k < lines.size(); k++) {\n      lines.get(k).chartPath.reset();\n      lines.get(k).chartPathPicker.reset();\n    }\n    canvas.save();\n    if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n      skipPoints=new boolean[chartData.lines.size()];\n      startFromY=new float[chartData.lines.size()];\n    }\n    boolean hasEmptyPoint=false;\n    int transitionAlpha=255;\n    float transitionProgressHalf=0;\n    if (transitionMode == TRANSITION_MODE_PARENT) {\n      transitionProgressHalf=transitionParams.progress / 0.6f;\n      if (transitionProgressHalf > 1f) {\n        transitionProgressHalf=1f;\n      }\n      ovalPath.reset();\n      float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n      float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n      float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n      RectF rectF=new RectF();\n      rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n      ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n      canvas.clipPath(ovalPath);\n    }\n else     if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n      transitionAlpha=(int)(transitionParams.progress * 255);\n    }\n    float dX=0;\n    float dY=0;\n    float x1=0;\n    float y1=0;\n    float p;\n    if (chartData.xPercentage.length < 2) {\n      p=1f;\n    }\n else {\n      p=chartData.xPercentage[1] * fullWidth;\n    }\n    int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n    int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n    int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n    float startXPoint=0;\n    float endXPoint=0;\n    for (int i=localStart; i <= localEnd; i++) {\n      float stackOffset=0;\n      float sum=0;\n      int lastEnabled=0;\n      int drawingLinesCount=0;\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        if (line.line.y[i] > 0) {\n          sum+=line.line.y[i] * line.alpha;\n          drawingLinesCount++;\n        }\n        lastEnabled=k;\n      }\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        int[] y=line.line.y;\n        float yPercentage;\n        if (drawingLinesCount == 1) {\n          if (y[i] == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=line.alpha;\n          }\n        }\n else {\n          if (sum == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=y[i] * line.alpha / sum;\n          }\n        }\n        float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n        float nextXPoint;\n        if (i == localEnd) {\n          nextXPoint=getMeasuredWidth();\n        }\n else {\n          nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n        }\n        if (yPercentage == 0 && k == lastEnabled) {\n          hasEmptyPoint=true;\n        }\n        float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n        float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n        startFromY[k]=yPoint;\n        float angle=0;\n        float yPointZero=getMeasuredHeight() - chartBottom;\n        float xPointZero=xPoint;\n        if (i == localEnd) {\n          endXPoint=xPoint;\n        }\n else         if (i == localStart) {\n          startXPoint=xPoint;\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          if (xPoint < cX) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n          }\n else {\n            x1=transitionParams.endX[k];\n            y1=transitionParams.endY[k];\n          }\n          dX=cX - x1;\n          dY=cY - y1;\n          float yTo=dY * (xPoint - x1) / dX + y1;\n          yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          if (xPoint >= cX) {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (xPoint < cX)             xPoint=cX;\n            mapPoints[0]=xPointZero;\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            yPointZero=mapPoints[1];\n            if (xPointZero < cX)             xPointZero=cX;\n          }\n else {\n            if (nextXPoint >= cX) {\n              xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n              yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n            }\n else {\n              mapPoints[0]=xPoint;\n              mapPoints[1]=yPoint;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPoint=mapPoints[0];\n              yPoint=mapPoints[1];\n              if (nextXPoint >= cX) {\n                mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n              }\n else {\n                mapPoints[0]=xPointZero;\n              }\n              mapPoints[1]=yPointZero;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPointZero=mapPoints[0];\n              yPointZero=mapPoints[1];\n            }\n          }\n        }\n        if (i == localStart) {\n          float localX=0;\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX - cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n          line.chartPath.moveTo(localX,localY);\n          skipPoints[k]=false;\n        }\n        float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n        if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n          if (!skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          skipPoints[k]=true;\n        }\n else {\n          if (skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPoint,yPoint);\n          }\n          skipPoints[k]=false;\n        }\n        if (i == localEnd) {\n          float localX=getMeasuredWidth();\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX + cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n else {\n            line.chartPath.lineTo(localX,localY);\n          }\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n            dX=cX - x1;\n            dY=cY - y1;\n            float angleK=dY / dX;\n            if (angleK > 0) {\n              angle=(float)Math.toDegrees(-Math.atan(angleK));\n            }\n else {\n              angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n            }\n            angle-=90;\n            localX=transitionParams.startX[k];\n            localY=transitionParams.startY[k];\n            mapPoints[0]=localX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n            int endQuarter;\n            int startQuarter;\n            if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n              if (transitionParams.angle[k] == -180f) {\n                endQuarter=0;\n                startQuarter=0;\n              }\n else {\n                endQuarter=0;\n                startQuarter=3;\n              }\n            }\n else {\n              endQuarter=quarterForPoint(xPoint,yPoint);\n              startQuarter=quarterForPoint(localX,localY);\n            }\n            for (int q=endQuarter; q <= startQuarter; q++) {\n              if (q == 0) {\n                line.chartPath.lineTo(getMeasuredWidth(),0);\n              }\n else               if (q == 1) {\n                line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n              }\n else               if (q == 2) {\n                line.chartPath.lineTo(0,getMeasuredHeight());\n              }\n else {\n                line.chartPath.lineTo(0,0);\n              }\n            }\n          }\n        }\n        stackOffset+=height;\n      }\n    }\n    canvas.save();\n    canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n    if (hasEmptyPoint) {\n      canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n    }\n    for (int k=lines.size() - 1; k >= 0; k--) {\n      LineViewData line=lines.get(k);\n      line.paint.setAlpha(transitionAlpha);\n      canvas.drawPath(line.chartPath,line.paint);\n      line.paint.setAlpha(255);\n    }\n    canvas.restore();\n    canvas.restore();\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1833,
      "astHeight" : 23
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 15864,
        "startLineNumber" : 38,
        "startColumnNumber" : 4,
        "endLineNumber" : 376,
        "endColumnNumber" : 5
      },
      "nodeContext" : "@Override protected void drawChart(Canvas canvas){\n  if (chartData != null) {\n    float fullWidth=(chartWidth / (pickerDelegate.pickerEnd - pickerDelegate.pickerStart));\n    float offset=fullWidth * (pickerDelegate.pickerStart) - HORIZONTAL_PADDING;\n    float cX=chartArea.centerX();\n    float cY=chartArea.centerY() + AndroidUtilities.dp(16);\n    for (int k=0; k < lines.size(); k++) {\n      lines.get(k).chartPath.reset();\n      lines.get(k).chartPathPicker.reset();\n    }\n    canvas.save();\n    if (skipPoints == null || skipPoints.length < chartData.lines.size()) {\n      skipPoints=new boolean[chartData.lines.size()];\n      startFromY=new float[chartData.lines.size()];\n    }\n    boolean hasEmptyPoint=false;\n    int transitionAlpha=255;\n    float transitionProgressHalf=0;\n    if (transitionMode == TRANSITION_MODE_PARENT) {\n      transitionProgressHalf=transitionParams.progress / 0.6f;\n      if (transitionProgressHalf > 1f) {\n        transitionProgressHalf=1f;\n      }\n      ovalPath.reset();\n      float radiusStart=(chartArea.width() > chartArea.height() ? chartArea.width() : chartArea.height());\n      float radiusEnd=(chartArea.width() > chartArea.height() ? chartArea.height() : chartArea.width()) * 0.45f;\n      float radius=radiusEnd + ((radiusStart - radiusEnd) / 2) * (1 - transitionParams.progress);\n      RectF rectF=new RectF();\n      rectF.set(cX - radius,cY - radius,cX + radius,cY + radius);\n      ovalPath.addRoundRect(rectF,radius,radius,Path.Direction.CW);\n      canvas.clipPath(ovalPath);\n    }\n else     if (transitionMode == TRANSITION_MODE_ALPHA_ENTER) {\n      transitionAlpha=(int)(transitionParams.progress * 255);\n    }\n    float dX=0;\n    float dY=0;\n    float x1=0;\n    float y1=0;\n    float p;\n    if (chartData.xPercentage.length < 2) {\n      p=1f;\n    }\n else {\n      p=chartData.xPercentage[1] * fullWidth;\n    }\n    int additionalPoints=(int)(HORIZONTAL_PADDING / p) + 1;\n    int localStart=Math.max(0,startXIndex - additionalPoints - 1);\n    int localEnd=Math.min(chartData.xPercentage.length - 1,endXIndex + additionalPoints + 1);\n    float startXPoint=0;\n    float endXPoint=0;\n    for (int i=localStart; i <= localEnd; i++) {\n      float stackOffset=0;\n      float sum=0;\n      int lastEnabled=0;\n      int drawingLinesCount=0;\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        if (line.line.y[i] > 0) {\n          sum+=line.line.y[i] * line.alpha;\n          drawingLinesCount++;\n        }\n        lastEnabled=k;\n      }\n      for (int k=0; k < lines.size(); k++) {\n        LineViewData line=lines.get(k);\n        if (!line.enabled && line.alpha == 0)         continue;\n        int[] y=line.line.y;\n        float yPercentage;\n        if (drawingLinesCount == 1) {\n          if (y[i] == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=line.alpha;\n          }\n        }\n else {\n          if (sum == 0) {\n            yPercentage=0;\n          }\n else {\n            yPercentage=y[i] * line.alpha / sum;\n          }\n        }\n        float xPoint=chartData.xPercentage[i] * fullWidth - offset;\n        float nextXPoint;\n        if (i == localEnd) {\n          nextXPoint=getMeasuredWidth();\n        }\n else {\n          nextXPoint=chartData.xPercentage[i + 1] * fullWidth - offset;\n        }\n        if (yPercentage == 0 && k == lastEnabled) {\n          hasEmptyPoint=true;\n        }\n        float height=(yPercentage) * (getMeasuredHeight() - chartBottom - SIGNATURE_TEXT_HEIGHT);\n        float yPoint=getMeasuredHeight() - chartBottom - height- stackOffset;\n        startFromY[k]=yPoint;\n        float angle=0;\n        float yPointZero=getMeasuredHeight() - chartBottom;\n        float xPointZero=xPoint;\n        if (i == localEnd) {\n          endXPoint=xPoint;\n        }\n else         if (i == localStart) {\n          startXPoint=xPoint;\n        }\n        if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n          if (xPoint < cX) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n          }\n else {\n            x1=transitionParams.endX[k];\n            y1=transitionParams.endY[k];\n          }\n          dX=cX - x1;\n          dY=cY - y1;\n          float yTo=dY * (xPoint - x1) / dX + y1;\n          yPoint=yPoint * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          yPointZero=yPointZero * (1f - transitionProgressHalf) + yTo * transitionProgressHalf;\n          float angleK=dY / dX;\n          if (angleK > 0) {\n            angle=(float)Math.toDegrees(-Math.atan(angleK));\n          }\n else {\n            angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n          }\n          angle-=90;\n          if (xPoint >= cX) {\n            mapPoints[0]=xPoint;\n            mapPoints[1]=yPoint;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            xPoint=mapPoints[0];\n            yPoint=mapPoints[1];\n            if (xPoint < cX)             xPoint=cX;\n            mapPoints[0]=xPointZero;\n            mapPoints[1]=yPointZero;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle,cX,cY);\n            matrix.mapPoints(mapPoints);\n            yPointZero=mapPoints[1];\n            if (xPointZero < cX)             xPointZero=cX;\n          }\n else {\n            if (nextXPoint >= cX) {\n              xPointZero=xPoint=xPoint * (1f - transitionProgressHalf) + cX * transitionProgressHalf;\n              yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n            }\n else {\n              mapPoints[0]=xPoint;\n              mapPoints[1]=yPoint;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPoint=mapPoints[0];\n              yPoint=mapPoints[1];\n              if (nextXPoint >= cX) {\n                mapPoints[0]=xPointZero * (1f - transitionParams.progress) + cX * transitionParams.progress;\n              }\n else {\n                mapPoints[0]=xPointZero;\n              }\n              mapPoints[1]=yPointZero;\n              matrix.reset();\n              matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n              matrix.mapPoints(mapPoints);\n              xPointZero=mapPoints[0];\n              yPointZero=mapPoints[1];\n            }\n          }\n        }\n        if (i == localStart) {\n          float localX=0;\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX - cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n          line.chartPath.moveTo(localX,localY);\n          skipPoints[k]=false;\n        }\n        float transitionProgress=transitionParams == null ? 0f : transitionParams.progress;\n        if (yPercentage == 0 && (i > 0 && y[i - 1] == 0) && (i < localEnd && y[i + 1] == 0) && transitionMode != TRANSITION_MODE_PARENT) {\n          if (!skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          skipPoints[k]=true;\n        }\n else {\n          if (skipPoints[k]) {\n            if (k == lastEnabled) {\n              line.chartPath.lineTo(xPointZero,yPointZero * (1f - transitionProgress));\n            }\n else {\n              line.chartPath.lineTo(xPointZero,yPointZero);\n            }\n          }\n          if (k == lastEnabled) {\n            line.chartPath.lineTo(xPoint,yPoint * (1f - transitionProgress));\n          }\n else {\n            line.chartPath.lineTo(xPoint,yPoint);\n          }\n          skipPoints[k]=false;\n        }\n        if (i == localEnd) {\n          float localX=getMeasuredWidth();\n          float localY=getMeasuredHeight();\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            mapPoints[0]=localX + cX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n          }\n else {\n            line.chartPath.lineTo(localX,localY);\n          }\n          if (transitionMode == TRANSITION_MODE_PARENT && k != lastEnabled) {\n            x1=transitionParams.startX[k];\n            y1=transitionParams.startY[k];\n            dX=cX - x1;\n            dY=cY - y1;\n            float angleK=dY / dX;\n            if (angleK > 0) {\n              angle=(float)Math.toDegrees(-Math.atan(angleK));\n            }\n else {\n              angle=(float)Math.toDegrees(Math.atan(Math.abs(angleK)));\n            }\n            angle-=90;\n            localX=transitionParams.startX[k];\n            localY=transitionParams.startY[k];\n            mapPoints[0]=localX;\n            mapPoints[1]=localY;\n            matrix.reset();\n            matrix.postRotate(transitionParams.progress * angle + transitionParams.progress * transitionParams.angle[k],cX,cY);\n            matrix.mapPoints(mapPoints);\n            localX=mapPoints[0];\n            localY=mapPoints[1];\n            int endQuarter;\n            int startQuarter;\n            if (Math.abs(xPoint - localX) < 0.001 && ((localY < cY && yPoint < cY) || (localY > cY && yPoint > cY))) {\n              if (transitionParams.angle[k] == -180f) {\n                endQuarter=0;\n                startQuarter=0;\n              }\n else {\n                endQuarter=0;\n                startQuarter=3;\n              }\n            }\n else {\n              endQuarter=quarterForPoint(xPoint,yPoint);\n              startQuarter=quarterForPoint(localX,localY);\n            }\n            for (int q=endQuarter; q <= startQuarter; q++) {\n              if (q == 0) {\n                line.chartPath.lineTo(getMeasuredWidth(),0);\n              }\n else               if (q == 1) {\n                line.chartPath.lineTo(getMeasuredWidth(),getMeasuredHeight());\n              }\n else               if (q == 2) {\n                line.chartPath.lineTo(0,getMeasuredHeight());\n              }\n else {\n                line.chartPath.lineTo(0,0);\n              }\n            }\n          }\n        }\n        stackOffset+=height;\n      }\n    }\n    canvas.save();\n    canvas.clipRect(startXPoint,SIGNATURE_TEXT_HEIGHT,endXPoint,getMeasuredHeight() - chartBottom);\n    if (hasEmptyPoint) {\n      canvas.drawColor(Theme.getColor(Theme.key_statisticChartLineEmpty));\n    }\n    for (int k=lines.size() - 1; k >= 0; k--) {\n      LineViewData line=lines.get(k);\n      line.paint.setAlpha(transitionAlpha);\n      canvas.drawPath(line.chartPath,line.paint);\n      line.paint.setAlpha(255);\n    }\n    canvas.restore();\n    canvas.restore();\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1843,
      "astHeight" : 24
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 91,
        "startLineNumber" : 213,
        "startColumnNumber" : 32,
        "endLineNumber" : 213,
        "endColumnNumber" : 123
      },
      "nodeContext" : "yPointZero=yPoint=yPoint * (1f - transitionProgressHalf) + cY * transitionProgressHalf;\n",
      "nodeType" : "ExpressionStatement",
      "astNodeNumber" : 15,
      "astHeight" : 8
    },
    "tokenLength" : 5,
    "type" : "float"
  } ],
  "positionList" : [ {
    "charLength" : 38,
    "startLineNumber" : 181,
    "startColumnNumber" : 33,
    "endLineNumber" : 181,
    "endColumnNumber" : 71
  }, {
    "charLength" : 38,
    "startLineNumber" : 213,
    "startColumnNumber" : 54,
    "endLineNumber" : 213,
    "endColumnNumber" : 92
  } ],
  "layoutRelationDataList" : [ {
    "firstKey" : 0,
    "secondKey" : 1,
    "layout" : 3
  }, {
    "firstKey" : 1,
    "secondKey" : 0,
    "layout" : 8
  } ]
}