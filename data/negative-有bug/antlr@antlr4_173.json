{
  "id" : 173,
  "expression" : "endState == null",
  "projectName" : "antlr@antlr4",
  "commitID" : "f2b93e550cd912be3973743d09206db98f4092c9",
  "filePath" : "/runtime/Java/src/org/antlr/v4/runtime/atn/ATNDeserializer.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "endState == null",
    "nodeType" : "InfixExpression",
    "nodePosition" : {
      "charLength" : 16,
      "startLineNumber" : 507,
      "startColumnNumber" : 9,
      "endLineNumber" : 507,
      "endColumnNumber" : 25
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 151,
        "startLineNumber" : 507,
        "startColumnNumber" : 5,
        "endLineNumber" : 509,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (endState == null) {\n  throw new UnsupportedOperationException(\"Couldn't identify final state of the precedence rule prefix section.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 10,
      "astHeight" : 6
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 903,
        "startLineNumber" : 484,
        "startColumnNumber" : 53,
        "endLineNumber" : 512,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  endState=null;\n  for (  ATNState state : atn.states) {\n    if (state.ruleIndex != i) {\n      continue;\n    }\n    if (!(state instanceof StarLoopEntryState)) {\n      continue;\n    }\n    ATNState maybeLoopEndState=state.transition(state.getNumberOfTransitions() - 1).target;\n    if (!(maybeLoopEndState instanceof LoopEndState)) {\n      continue;\n    }\n    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\n      endState=state;\n      break;\n    }\n  }\n  if (endState == null) {\n    throw new UnsupportedOperationException(\"Couldn't identify final state of the precedence rule prefix section.\");\n  }\n  excludeTransition=((StarLoopEntryState)endState).loopBackState.transition(0);\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 98,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1012,
        "startLineNumber" : 484,
        "startColumnNumber" : 4,
        "endLineNumber" : 515,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (atn.ruleToStartState[i].isLeftRecursiveRule) {\n  endState=null;\n  for (  ATNState state : atn.states) {\n    if (state.ruleIndex != i) {\n      continue;\n    }\n    if (!(state instanceof StarLoopEntryState)) {\n      continue;\n    }\n    ATNState maybeLoopEndState=state.transition(state.getNumberOfTransitions() - 1).target;\n    if (!(maybeLoopEndState instanceof LoopEndState)) {\n      continue;\n    }\n    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\n      endState=state;\n      break;\n    }\n  }\n  if (endState == null) {\n    throw new UnsupportedOperationException(\"Couldn't identify final state of the precedence rule prefix section.\");\n  }\n  excludeTransition=((StarLoopEntryState)endState).loopBackState.transition(0);\n}\n else {\n  endState=atn.ruleToStopState[i];\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 115,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 2594,
        "startLineNumber" : 468,
        "startColumnNumber" : 57,
        "endLineNumber" : 544,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  BasicBlockStartState bypassStart=new BasicBlockStartState();\n  bypassStart.ruleIndex=i;\n  atn.addState(bypassStart);\n  BlockEndState bypassStop=new BlockEndState();\n  bypassStop.ruleIndex=i;\n  atn.addState(bypassStop);\n  bypassStart.endState=bypassStop;\n  atn.defineDecisionState(bypassStart);\n  bypassStop.startState=bypassStart;\n  ATNState endState;\n  Transition excludeTransition=null;\n  if (atn.ruleToStartState[i].isLeftRecursiveRule) {\n    endState=null;\n    for (    ATNState state : atn.states) {\n      if (state.ruleIndex != i) {\n        continue;\n      }\n      if (!(state instanceof StarLoopEntryState)) {\n        continue;\n      }\n      ATNState maybeLoopEndState=state.transition(state.getNumberOfTransitions() - 1).target;\n      if (!(maybeLoopEndState instanceof LoopEndState)) {\n        continue;\n      }\n      if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\n        endState=state;\n        break;\n      }\n    }\n    if (endState == null) {\n      throw new UnsupportedOperationException(\"Couldn't identify final state of the precedence rule prefix section.\");\n    }\n    excludeTransition=((StarLoopEntryState)endState).loopBackState.transition(0);\n  }\n else {\n    endState=atn.ruleToStopState[i];\n  }\n  for (  ATNState state : atn.states) {\n    for (    Transition transition : state.transitions) {\n      if (transition == excludeTransition) {\n        continue;\n      }\n      if (transition.target == endState) {\n        transition.target=bypassStop;\n      }\n    }\n  }\n  while (atn.ruleToStartState[i].getNumberOfTransitions() > 0) {\n    Transition transition=atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].getNumberOfTransitions() - 1);\n    bypassStart.addTransition(transition);\n  }\n  atn.ruleToStartState[i].addTransition(new EpsilonTransition(bypassStart));\n  bypassStop.addTransition(new EpsilonTransition(endState));\n  ATNState matchState=new BasicState();\n  atn.addState(matchState);\n  matchState.addTransition(new AtomTransition(bypassStop,atn.ruleToTokenType[i]));\n  bypassStart.addTransition(new EpsilonTransition(matchState));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 310,
      "astHeight" : 12
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 2648,
        "startLineNumber" : 468,
        "startColumnNumber" : 3,
        "endLineNumber" : 544,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int i=0; i < atn.ruleToStartState.length; i++) {\n  BasicBlockStartState bypassStart=new BasicBlockStartState();\n  bypassStart.ruleIndex=i;\n  atn.addState(bypassStart);\n  BlockEndState bypassStop=new BlockEndState();\n  bypassStop.ruleIndex=i;\n  atn.addState(bypassStop);\n  bypassStart.endState=bypassStop;\n  atn.defineDecisionState(bypassStart);\n  bypassStop.startState=bypassStart;\n  ATNState endState;\n  Transition excludeTransition=null;\n  if (atn.ruleToStartState[i].isLeftRecursiveRule) {\n    endState=null;\n    for (    ATNState state : atn.states) {\n      if (state.ruleIndex != i) {\n        continue;\n      }\n      if (!(state instanceof StarLoopEntryState)) {\n        continue;\n      }\n      ATNState maybeLoopEndState=state.transition(state.getNumberOfTransitions() - 1).target;\n      if (!(maybeLoopEndState instanceof LoopEndState)) {\n        continue;\n      }\n      if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\n        endState=state;\n        break;\n      }\n    }\n    if (endState == null) {\n      throw new UnsupportedOperationException(\"Couldn't identify final state of the precedence rule prefix section.\");\n    }\n    excludeTransition=((StarLoopEntryState)endState).loopBackState.transition(0);\n  }\n else {\n    endState=atn.ruleToStopState[i];\n  }\n  for (  ATNState state : atn.states) {\n    for (    Transition transition : state.transitions) {\n      if (transition == excludeTransition) {\n        continue;\n      }\n      if (transition.target == endState) {\n        transition.target=bypassStop;\n      }\n    }\n  }\n  while (atn.ruleToStartState[i].getNumberOfTransitions() > 0) {\n    Transition transition=atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].getNumberOfTransitions() - 1);\n    bypassStart.addTransition(transition);\n  }\n  atn.ruleToStartState[i].addTransition(new EpsilonTransition(bypassStart));\n  bypassStop.addTransition(new EpsilonTransition(endState));\n  ATNState matchState=new BasicState();\n  atn.addState(matchState);\n  matchState.addTransition(new AtomTransition(bypassStop,atn.ruleToTokenType[i]));\n  bypassStart.addTransition(new EpsilonTransition(matchState));\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 325,
      "astHeight" : 13
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 2960,
        "startLineNumber" : 462,
        "startColumnNumber" : 101,
        "endLineNumber" : 550,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  atn.ruleToTokenType=new int[atn.ruleToStartState.length];\n  for (int i=0; i < atn.ruleToStartState.length; i++) {\n    atn.ruleToTokenType[i]=atn.maxTokenType + i + 1;\n  }\n  for (int i=0; i < atn.ruleToStartState.length; i++) {\n    BasicBlockStartState bypassStart=new BasicBlockStartState();\n    bypassStart.ruleIndex=i;\n    atn.addState(bypassStart);\n    BlockEndState bypassStop=new BlockEndState();\n    bypassStop.ruleIndex=i;\n    atn.addState(bypassStop);\n    bypassStart.endState=bypassStop;\n    atn.defineDecisionState(bypassStart);\n    bypassStop.startState=bypassStart;\n    ATNState endState;\n    Transition excludeTransition=null;\n    if (atn.ruleToStartState[i].isLeftRecursiveRule) {\n      endState=null;\n      for (      ATNState state : atn.states) {\n        if (state.ruleIndex != i) {\n          continue;\n        }\n        if (!(state instanceof StarLoopEntryState)) {\n          continue;\n        }\n        ATNState maybeLoopEndState=state.transition(state.getNumberOfTransitions() - 1).target;\n        if (!(maybeLoopEndState instanceof LoopEndState)) {\n          continue;\n        }\n        if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\n          endState=state;\n          break;\n        }\n      }\n      if (endState == null) {\n        throw new UnsupportedOperationException(\"Couldn't identify final state of the precedence rule prefix section.\");\n      }\n      excludeTransition=((StarLoopEntryState)endState).loopBackState.transition(0);\n    }\n else {\n      endState=atn.ruleToStopState[i];\n    }\n    for (    ATNState state : atn.states) {\n      for (      Transition transition : state.transitions) {\n        if (transition == excludeTransition) {\n          continue;\n        }\n        if (transition.target == endState) {\n          transition.target=bypassStop;\n        }\n      }\n    }\n    while (atn.ruleToStartState[i].getNumberOfTransitions() > 0) {\n      Transition transition=atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].getNumberOfTransitions() - 1);\n      bypassStart.addTransition(transition);\n    }\n    atn.ruleToStartState[i].addTransition(new EpsilonTransition(bypassStart));\n    bypassStop.addTransition(new EpsilonTransition(endState));\n    ATNState matchState=new BasicState();\n    atn.addState(matchState);\n    matchState.addTransition(new AtomTransition(bypassStop,atn.ruleToTokenType[i]));\n    bypassStart.addTransition(new EpsilonTransition(matchState));\n  }\n  if (deserializationOptions.isVerifyATN()) {\n    verifyATN(atn);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 378,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 3059,
        "startLineNumber" : 462,
        "startColumnNumber" : 2,
        "endLineNumber" : 550,
        "endColumnNumber" : 3
      },
      "nodeContext" : "if (deserializationOptions.isGenerateRuleBypassTransitions() && atn.grammarType == ATNType.PARSER) {\n  atn.ruleToTokenType=new int[atn.ruleToStartState.length];\n  for (int i=0; i < atn.ruleToStartState.length; i++) {\n    atn.ruleToTokenType[i]=atn.maxTokenType + i + 1;\n  }\n  for (int i=0; i < atn.ruleToStartState.length; i++) {\n    BasicBlockStartState bypassStart=new BasicBlockStartState();\n    bypassStart.ruleIndex=i;\n    atn.addState(bypassStart);\n    BlockEndState bypassStop=new BlockEndState();\n    bypassStop.ruleIndex=i;\n    atn.addState(bypassStop);\n    bypassStart.endState=bypassStop;\n    atn.defineDecisionState(bypassStart);\n    bypassStop.startState=bypassStart;\n    ATNState endState;\n    Transition excludeTransition=null;\n    if (atn.ruleToStartState[i].isLeftRecursiveRule) {\n      endState=null;\n      for (      ATNState state : atn.states) {\n        if (state.ruleIndex != i) {\n          continue;\n        }\n        if (!(state instanceof StarLoopEntryState)) {\n          continue;\n        }\n        ATNState maybeLoopEndState=state.transition(state.getNumberOfTransitions() - 1).target;\n        if (!(maybeLoopEndState instanceof LoopEndState)) {\n          continue;\n        }\n        if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\n          endState=state;\n          break;\n        }\n      }\n      if (endState == null) {\n        throw new UnsupportedOperationException(\"Couldn't identify final state of the precedence rule prefix section.\");\n      }\n      excludeTransition=((StarLoopEntryState)endState).loopBackState.transition(0);\n    }\n else {\n      endState=atn.ruleToStopState[i];\n    }\n    for (    ATNState state : atn.states) {\n      for (      Transition transition : state.transitions) {\n        if (transition == excludeTransition) {\n          continue;\n        }\n        if (transition.target == endState) {\n          transition.target=bypassStop;\n        }\n      }\n    }\n    while (atn.ruleToStartState[i].getNumberOfTransitions() > 0) {\n      Transition transition=atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].getNumberOfTransitions() - 1);\n      bypassStart.addTransition(transition);\n    }\n    atn.ruleToStartState[i].addTransition(new EpsilonTransition(bypassStart));\n    bypassStop.addTransition(new EpsilonTransition(endState));\n    ATNState matchState=new BasicState();\n    atn.addState(matchState);\n    matchState.addTransition(new AtomTransition(bypassStop,atn.ruleToTokenType[i]));\n    bypassStart.addTransition(new EpsilonTransition(matchState));\n  }\n  if (deserializationOptions.isVerifyATN()) {\n    verifyATN(atn);\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 390,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 13753,
        "startLineNumber" : 161,
        "startColumnNumber" : 37,
        "endLineNumber" : 553,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  data=data.clone();\n  for (int i=1; i < data.length; i++) {\n    data[i]=(char)(data[i] - 2);\n  }\n  int p=0;\n  int version=toInt(data[p++]);\n  if (version != SERIALIZED_VERSION) {\n    String reason=String.format(Locale.getDefault(),\"Could not deserialize ATN with version %d (expected %d).\",version,SERIALIZED_VERSION);\n    throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(),reason));\n  }\n  UUID uuid=toUUID(data,p);\n  p+=8;\n  if (!SUPPORTED_UUIDS.contains(uuid)) {\n    String reason=String.format(Locale.getDefault(),\"Could not deserialize ATN with UUID %s (expected %s or a legacy UUID).\",uuid,SERIALIZED_UUID);\n    throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(),reason));\n  }\n  boolean supportsPrecedencePredicates=isFeatureSupported(ADDED_PRECEDENCE_TRANSITIONS,uuid);\n  boolean supportsLexerActions=isFeatureSupported(ADDED_LEXER_ACTIONS,uuid);\n  ATNType grammarType=ATNType.values()[toInt(data[p++])];\n  int maxTokenType=toInt(data[p++]);\n  ATN atn=new ATN(grammarType,maxTokenType);\n  List<Pair<LoopEndState,Integer>> loopBackStateNumbers=new ArrayList<Pair<LoopEndState,Integer>>();\n  List<Pair<BlockStartState,Integer>> endStateNumbers=new ArrayList<Pair<BlockStartState,Integer>>();\n  int nstates=toInt(data[p++]);\n  for (int i=0; i < nstates; i++) {\n    int stype=toInt(data[p++]);\n    if (stype == ATNState.INVALID_TYPE) {\n      atn.addState(null);\n      continue;\n    }\n    int ruleIndex=toInt(data[p++]);\n    if (ruleIndex == Character.MAX_VALUE) {\n      ruleIndex=-1;\n    }\n    ATNState s=stateFactory(stype,ruleIndex);\n    if (stype == ATNState.LOOP_END) {\n      int loopBackStateNumber=toInt(data[p++]);\n      loopBackStateNumbers.add(new Pair<LoopEndState,Integer>((LoopEndState)s,loopBackStateNumber));\n    }\n else     if (s instanceof BlockStartState) {\n      int endStateNumber=toInt(data[p++]);\n      endStateNumbers.add(new Pair<BlockStartState,Integer>((BlockStartState)s,endStateNumber));\n    }\n    atn.addState(s);\n  }\n  for (  Pair<LoopEndState,Integer> pair : loopBackStateNumbers) {\n    pair.a.loopBackState=atn.states.get(pair.b);\n  }\n  for (  Pair<BlockStartState,Integer> pair : endStateNumbers) {\n    pair.a.endState=(BlockEndState)atn.states.get(pair.b);\n  }\n  int numNonGreedyStates=toInt(data[p++]);\n  for (int i=0; i < numNonGreedyStates; i++) {\n    int stateNumber=toInt(data[p++]);\n    ((DecisionState)atn.states.get(stateNumber)).nonGreedy=true;\n  }\n  if (supportsPrecedencePredicates) {\n    int numPrecedenceStates=toInt(data[p++]);\n    for (int i=0; i < numPrecedenceStates; i++) {\n      int stateNumber=toInt(data[p++]);\n      ((RuleStartState)atn.states.get(stateNumber)).isLeftRecursiveRule=true;\n    }\n  }\n  int nrules=toInt(data[p++]);\n  if (atn.grammarType == ATNType.LEXER) {\n    atn.ruleToTokenType=new int[nrules];\n  }\n  atn.ruleToStartState=new RuleStartState[nrules];\n  for (int i=0; i < nrules; i++) {\n    int s=toInt(data[p++]);\n    RuleStartState startState=(RuleStartState)atn.states.get(s);\n    atn.ruleToStartState[i]=startState;\n    if (atn.grammarType == ATNType.LEXER) {\n      int tokenType=toInt(data[p++]);\n      if (tokenType == 0xFFFF) {\n        tokenType=Token.EOF;\n      }\n      atn.ruleToTokenType[i]=tokenType;\n      if (!isFeatureSupported(ADDED_LEXER_ACTIONS,uuid)) {\n        int actionIndexIgnored=toInt(data[p++]);\n      }\n    }\n  }\n  atn.ruleToStopState=new RuleStopState[nrules];\n  for (  ATNState state : atn.states) {\n    if (!(state instanceof RuleStopState)) {\n      continue;\n    }\n    RuleStopState stopState=(RuleStopState)state;\n    atn.ruleToStopState[state.ruleIndex]=stopState;\n    atn.ruleToStartState[state.ruleIndex].stopState=stopState;\n  }\n  int nmodes=toInt(data[p++]);\n  for (int i=0; i < nmodes; i++) {\n    int s=toInt(data[p++]);\n    atn.modeToStartState.add((TokensStartState)atn.states.get(s));\n  }\n  List<IntervalSet> sets=new ArrayList<IntervalSet>();\n  p=deserializeSets(data,p,sets,getUnicodeDeserializer(UnicodeDeserializingMode.UNICODE_BMP));\n  if (isFeatureSupported(ADDED_UNICODE_SMP,uuid)) {\n    p=deserializeSets(data,p,sets,getUnicodeDeserializer(UnicodeDeserializingMode.UNICODE_SMP));\n  }\n  int nedges=toInt(data[p++]);\n  for (int i=0; i < nedges; i++) {\n    int src=toInt(data[p]);\n    int trg=toInt(data[p + 1]);\n    int ttype=toInt(data[p + 2]);\n    int arg1=toInt(data[p + 3]);\n    int arg2=toInt(data[p + 4]);\n    int arg3=toInt(data[p + 5]);\n    Transition trans=edgeFactory(atn,ttype,src,trg,arg1,arg2,arg3,sets);\n    ATNState srcState=atn.states.get(src);\n    srcState.addTransition(trans);\n    p+=6;\n  }\n  for (  ATNState state : atn.states) {\n    for (int i=0; i < state.getNumberOfTransitions(); i++) {\n      Transition t=state.transition(i);\n      if (!(t instanceof RuleTransition)) {\n        continue;\n      }\n      RuleTransition ruleTransition=(RuleTransition)t;\n      int outermostPrecedenceReturn=-1;\n      if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isLeftRecursiveRule) {\n        if (ruleTransition.precedence == 0) {\n          outermostPrecedenceReturn=ruleTransition.target.ruleIndex;\n        }\n      }\n      EpsilonTransition returnTransition=new EpsilonTransition(ruleTransition.followState,outermostPrecedenceReturn);\n      atn.ruleToStopState[ruleTransition.target.ruleIndex].addTransition(returnTransition);\n    }\n  }\n  for (  ATNState state : atn.states) {\n    if (state instanceof BlockStartState) {\n      if (((BlockStartState)state).endState == null) {\n        throw new IllegalStateException();\n      }\n      if (((BlockStartState)state).endState.startState != null) {\n        throw new IllegalStateException();\n      }\n      ((BlockStartState)state).endState.startState=(BlockStartState)state;\n    }\n    if (state instanceof PlusLoopbackState) {\n      PlusLoopbackState loopbackState=(PlusLoopbackState)state;\n      for (int i=0; i < loopbackState.getNumberOfTransitions(); i++) {\n        ATNState target=loopbackState.transition(i).target;\n        if (target instanceof PlusBlockStartState) {\n          ((PlusBlockStartState)target).loopBackState=loopbackState;\n        }\n      }\n    }\n else     if (state instanceof StarLoopbackState) {\n      StarLoopbackState loopbackState=(StarLoopbackState)state;\n      for (int i=0; i < loopbackState.getNumberOfTransitions(); i++) {\n        ATNState target=loopbackState.transition(i).target;\n        if (target instanceof StarLoopEntryState) {\n          ((StarLoopEntryState)target).loopBackState=loopbackState;\n        }\n      }\n    }\n  }\n  int ndecisions=toInt(data[p++]);\n  for (int i=1; i <= ndecisions; i++) {\n    int s=toInt(data[p++]);\n    DecisionState decState=(DecisionState)atn.states.get(s);\n    atn.decisionToState.add(decState);\n    decState.decision=i - 1;\n  }\n  if (atn.grammarType == ATNType.LEXER) {\n    if (supportsLexerActions) {\n      atn.lexerActions=new LexerAction[toInt(data[p++])];\n      for (int i=0; i < atn.lexerActions.length; i++) {\n        LexerActionType actionType=LexerActionType.values()[toInt(data[p++])];\n        int data1=toInt(data[p++]);\n        if (data1 == 0xFFFF) {\n          data1=-1;\n        }\n        int data2=toInt(data[p++]);\n        if (data2 == 0xFFFF) {\n          data2=-1;\n        }\n        LexerAction lexerAction=lexerActionFactory(actionType,data1,data2);\n        atn.lexerActions[i]=lexerAction;\n      }\n    }\n else {\n      List<LexerAction> legacyLexerActions=new ArrayList<LexerAction>();\n      for (      ATNState state : atn.states) {\n        for (int i=0; i < state.getNumberOfTransitions(); i++) {\n          Transition transition=state.transition(i);\n          if (!(transition instanceof ActionTransition)) {\n            continue;\n          }\n          int ruleIndex=((ActionTransition)transition).ruleIndex;\n          int actionIndex=((ActionTransition)transition).actionIndex;\n          LexerCustomAction lexerAction=new LexerCustomAction(ruleIndex,actionIndex);\n          state.setTransition(i,new ActionTransition(transition.target,ruleIndex,legacyLexerActions.size(),false));\n          legacyLexerActions.add(lexerAction);\n        }\n      }\n      atn.lexerActions=legacyLexerActions.toArray(new LexerAction[legacyLexerActions.size()]);\n    }\n  }\n  markPrecedenceDecisions(atn);\n  if (deserializationOptions.isVerifyATN()) {\n    verifyATN(atn);\n  }\n  if (deserializationOptions.isGenerateRuleBypassTransitions() && atn.grammarType == ATNType.PARSER) {\n    atn.ruleToTokenType=new int[atn.ruleToStartState.length];\n    for (int i=0; i < atn.ruleToStartState.length; i++) {\n      atn.ruleToTokenType[i]=atn.maxTokenType + i + 1;\n    }\n    for (int i=0; i < atn.ruleToStartState.length; i++) {\n      BasicBlockStartState bypassStart=new BasicBlockStartState();\n      bypassStart.ruleIndex=i;\n      atn.addState(bypassStart);\n      BlockEndState bypassStop=new BlockEndState();\n      bypassStop.ruleIndex=i;\n      atn.addState(bypassStop);\n      bypassStart.endState=bypassStop;\n      atn.defineDecisionState(bypassStart);\n      bypassStop.startState=bypassStart;\n      ATNState endState;\n      Transition excludeTransition=null;\n      if (atn.ruleToStartState[i].isLeftRecursiveRule) {\n        endState=null;\n        for (        ATNState state : atn.states) {\n          if (state.ruleIndex != i) {\n            continue;\n          }\n          if (!(state instanceof StarLoopEntryState)) {\n            continue;\n          }\n          ATNState maybeLoopEndState=state.transition(state.getNumberOfTransitions() - 1).target;\n          if (!(maybeLoopEndState instanceof LoopEndState)) {\n            continue;\n          }\n          if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\n            endState=state;\n            break;\n          }\n        }\n        if (endState == null) {\n          throw new UnsupportedOperationException(\"Couldn't identify final state of the precedence rule prefix section.\");\n        }\n        excludeTransition=((StarLoopEntryState)endState).loopBackState.transition(0);\n      }\n else {\n        endState=atn.ruleToStopState[i];\n      }\n      for (      ATNState state : atn.states) {\n        for (        Transition transition : state.transitions) {\n          if (transition == excludeTransition) {\n            continue;\n          }\n          if (transition.target == endState) {\n            transition.target=bypassStop;\n          }\n        }\n      }\n      while (atn.ruleToStartState[i].getNumberOfTransitions() > 0) {\n        Transition transition=atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].getNumberOfTransitions() - 1);\n        bypassStart.addTransition(transition);\n      }\n      atn.ruleToStartState[i].addTransition(new EpsilonTransition(bypassStart));\n      bypassStop.addTransition(new EpsilonTransition(endState));\n      ATNState matchState=new BasicState();\n      atn.addState(matchState);\n      matchState.addTransition(new AtomTransition(bypassStop,atn.ruleToTokenType[i]));\n      bypassStart.addTransition(new EpsilonTransition(matchState));\n    }\n    if (deserializationOptions.isVerifyATN()) {\n      verifyATN(atn);\n    }\n  }\n  return atn;\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1933,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 13824,
        "startLineNumber" : 160,
        "startColumnNumber" : 1,
        "endLineNumber" : 553,
        "endColumnNumber" : 2
      },
      "nodeContext" : "@SuppressWarnings(\"deprecation\") public ATN deserialize(char[] data){\n  data=data.clone();\n  for (int i=1; i < data.length; i++) {\n    data[i]=(char)(data[i] - 2);\n  }\n  int p=0;\n  int version=toInt(data[p++]);\n  if (version != SERIALIZED_VERSION) {\n    String reason=String.format(Locale.getDefault(),\"Could not deserialize ATN with version %d (expected %d).\",version,SERIALIZED_VERSION);\n    throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(),reason));\n  }\n  UUID uuid=toUUID(data,p);\n  p+=8;\n  if (!SUPPORTED_UUIDS.contains(uuid)) {\n    String reason=String.format(Locale.getDefault(),\"Could not deserialize ATN with UUID %s (expected %s or a legacy UUID).\",uuid,SERIALIZED_UUID);\n    throw new UnsupportedOperationException(new InvalidClassException(ATN.class.getName(),reason));\n  }\n  boolean supportsPrecedencePredicates=isFeatureSupported(ADDED_PRECEDENCE_TRANSITIONS,uuid);\n  boolean supportsLexerActions=isFeatureSupported(ADDED_LEXER_ACTIONS,uuid);\n  ATNType grammarType=ATNType.values()[toInt(data[p++])];\n  int maxTokenType=toInt(data[p++]);\n  ATN atn=new ATN(grammarType,maxTokenType);\n  List<Pair<LoopEndState,Integer>> loopBackStateNumbers=new ArrayList<Pair<LoopEndState,Integer>>();\n  List<Pair<BlockStartState,Integer>> endStateNumbers=new ArrayList<Pair<BlockStartState,Integer>>();\n  int nstates=toInt(data[p++]);\n  for (int i=0; i < nstates; i++) {\n    int stype=toInt(data[p++]);\n    if (stype == ATNState.INVALID_TYPE) {\n      atn.addState(null);\n      continue;\n    }\n    int ruleIndex=toInt(data[p++]);\n    if (ruleIndex == Character.MAX_VALUE) {\n      ruleIndex=-1;\n    }\n    ATNState s=stateFactory(stype,ruleIndex);\n    if (stype == ATNState.LOOP_END) {\n      int loopBackStateNumber=toInt(data[p++]);\n      loopBackStateNumbers.add(new Pair<LoopEndState,Integer>((LoopEndState)s,loopBackStateNumber));\n    }\n else     if (s instanceof BlockStartState) {\n      int endStateNumber=toInt(data[p++]);\n      endStateNumbers.add(new Pair<BlockStartState,Integer>((BlockStartState)s,endStateNumber));\n    }\n    atn.addState(s);\n  }\n  for (  Pair<LoopEndState,Integer> pair : loopBackStateNumbers) {\n    pair.a.loopBackState=atn.states.get(pair.b);\n  }\n  for (  Pair<BlockStartState,Integer> pair : endStateNumbers) {\n    pair.a.endState=(BlockEndState)atn.states.get(pair.b);\n  }\n  int numNonGreedyStates=toInt(data[p++]);\n  for (int i=0; i < numNonGreedyStates; i++) {\n    int stateNumber=toInt(data[p++]);\n    ((DecisionState)atn.states.get(stateNumber)).nonGreedy=true;\n  }\n  if (supportsPrecedencePredicates) {\n    int numPrecedenceStates=toInt(data[p++]);\n    for (int i=0; i < numPrecedenceStates; i++) {\n      int stateNumber=toInt(data[p++]);\n      ((RuleStartState)atn.states.get(stateNumber)).isLeftRecursiveRule=true;\n    }\n  }\n  int nrules=toInt(data[p++]);\n  if (atn.grammarType == ATNType.LEXER) {\n    atn.ruleToTokenType=new int[nrules];\n  }\n  atn.ruleToStartState=new RuleStartState[nrules];\n  for (int i=0; i < nrules; i++) {\n    int s=toInt(data[p++]);\n    RuleStartState startState=(RuleStartState)atn.states.get(s);\n    atn.ruleToStartState[i]=startState;\n    if (atn.grammarType == ATNType.LEXER) {\n      int tokenType=toInt(data[p++]);\n      if (tokenType == 0xFFFF) {\n        tokenType=Token.EOF;\n      }\n      atn.ruleToTokenType[i]=tokenType;\n      if (!isFeatureSupported(ADDED_LEXER_ACTIONS,uuid)) {\n        int actionIndexIgnored=toInt(data[p++]);\n      }\n    }\n  }\n  atn.ruleToStopState=new RuleStopState[nrules];\n  for (  ATNState state : atn.states) {\n    if (!(state instanceof RuleStopState)) {\n      continue;\n    }\n    RuleStopState stopState=(RuleStopState)state;\n    atn.ruleToStopState[state.ruleIndex]=stopState;\n    atn.ruleToStartState[state.ruleIndex].stopState=stopState;\n  }\n  int nmodes=toInt(data[p++]);\n  for (int i=0; i < nmodes; i++) {\n    int s=toInt(data[p++]);\n    atn.modeToStartState.add((TokensStartState)atn.states.get(s));\n  }\n  List<IntervalSet> sets=new ArrayList<IntervalSet>();\n  p=deserializeSets(data,p,sets,getUnicodeDeserializer(UnicodeDeserializingMode.UNICODE_BMP));\n  if (isFeatureSupported(ADDED_UNICODE_SMP,uuid)) {\n    p=deserializeSets(data,p,sets,getUnicodeDeserializer(UnicodeDeserializingMode.UNICODE_SMP));\n  }\n  int nedges=toInt(data[p++]);\n  for (int i=0; i < nedges; i++) {\n    int src=toInt(data[p]);\n    int trg=toInt(data[p + 1]);\n    int ttype=toInt(data[p + 2]);\n    int arg1=toInt(data[p + 3]);\n    int arg2=toInt(data[p + 4]);\n    int arg3=toInt(data[p + 5]);\n    Transition trans=edgeFactory(atn,ttype,src,trg,arg1,arg2,arg3,sets);\n    ATNState srcState=atn.states.get(src);\n    srcState.addTransition(trans);\n    p+=6;\n  }\n  for (  ATNState state : atn.states) {\n    for (int i=0; i < state.getNumberOfTransitions(); i++) {\n      Transition t=state.transition(i);\n      if (!(t instanceof RuleTransition)) {\n        continue;\n      }\n      RuleTransition ruleTransition=(RuleTransition)t;\n      int outermostPrecedenceReturn=-1;\n      if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isLeftRecursiveRule) {\n        if (ruleTransition.precedence == 0) {\n          outermostPrecedenceReturn=ruleTransition.target.ruleIndex;\n        }\n      }\n      EpsilonTransition returnTransition=new EpsilonTransition(ruleTransition.followState,outermostPrecedenceReturn);\n      atn.ruleToStopState[ruleTransition.target.ruleIndex].addTransition(returnTransition);\n    }\n  }\n  for (  ATNState state : atn.states) {\n    if (state instanceof BlockStartState) {\n      if (((BlockStartState)state).endState == null) {\n        throw new IllegalStateException();\n      }\n      if (((BlockStartState)state).endState.startState != null) {\n        throw new IllegalStateException();\n      }\n      ((BlockStartState)state).endState.startState=(BlockStartState)state;\n    }\n    if (state instanceof PlusLoopbackState) {\n      PlusLoopbackState loopbackState=(PlusLoopbackState)state;\n      for (int i=0; i < loopbackState.getNumberOfTransitions(); i++) {\n        ATNState target=loopbackState.transition(i).target;\n        if (target instanceof PlusBlockStartState) {\n          ((PlusBlockStartState)target).loopBackState=loopbackState;\n        }\n      }\n    }\n else     if (state instanceof StarLoopbackState) {\n      StarLoopbackState loopbackState=(StarLoopbackState)state;\n      for (int i=0; i < loopbackState.getNumberOfTransitions(); i++) {\n        ATNState target=loopbackState.transition(i).target;\n        if (target instanceof StarLoopEntryState) {\n          ((StarLoopEntryState)target).loopBackState=loopbackState;\n        }\n      }\n    }\n  }\n  int ndecisions=toInt(data[p++]);\n  for (int i=1; i <= ndecisions; i++) {\n    int s=toInt(data[p++]);\n    DecisionState decState=(DecisionState)atn.states.get(s);\n    atn.decisionToState.add(decState);\n    decState.decision=i - 1;\n  }\n  if (atn.grammarType == ATNType.LEXER) {\n    if (supportsLexerActions) {\n      atn.lexerActions=new LexerAction[toInt(data[p++])];\n      for (int i=0; i < atn.lexerActions.length; i++) {\n        LexerActionType actionType=LexerActionType.values()[toInt(data[p++])];\n        int data1=toInt(data[p++]);\n        if (data1 == 0xFFFF) {\n          data1=-1;\n        }\n        int data2=toInt(data[p++]);\n        if (data2 == 0xFFFF) {\n          data2=-1;\n        }\n        LexerAction lexerAction=lexerActionFactory(actionType,data1,data2);\n        atn.lexerActions[i]=lexerAction;\n      }\n    }\n else {\n      List<LexerAction> legacyLexerActions=new ArrayList<LexerAction>();\n      for (      ATNState state : atn.states) {\n        for (int i=0; i < state.getNumberOfTransitions(); i++) {\n          Transition transition=state.transition(i);\n          if (!(transition instanceof ActionTransition)) {\n            continue;\n          }\n          int ruleIndex=((ActionTransition)transition).ruleIndex;\n          int actionIndex=((ActionTransition)transition).actionIndex;\n          LexerCustomAction lexerAction=new LexerCustomAction(ruleIndex,actionIndex);\n          state.setTransition(i,new ActionTransition(transition.target,ruleIndex,legacyLexerActions.size(),false));\n          legacyLexerActions.add(lexerAction);\n        }\n      }\n      atn.lexerActions=legacyLexerActions.toArray(new LexerAction[legacyLexerActions.size()]);\n    }\n  }\n  markPrecedenceDecisions(atn);\n  if (deserializationOptions.isVerifyATN()) {\n    verifyATN(atn);\n  }\n  if (deserializationOptions.isGenerateRuleBypassTransitions() && atn.grammarType == ATNType.PARSER) {\n    atn.ruleToTokenType=new int[atn.ruleToStartState.length];\n    for (int i=0; i < atn.ruleToStartState.length; i++) {\n      atn.ruleToTokenType[i]=atn.maxTokenType + i + 1;\n    }\n    for (int i=0; i < atn.ruleToStartState.length; i++) {\n      BasicBlockStartState bypassStart=new BasicBlockStartState();\n      bypassStart.ruleIndex=i;\n      atn.addState(bypassStart);\n      BlockEndState bypassStop=new BlockEndState();\n      bypassStop.ruleIndex=i;\n      atn.addState(bypassStop);\n      bypassStart.endState=bypassStop;\n      atn.defineDecisionState(bypassStart);\n      bypassStop.startState=bypassStart;\n      ATNState endState;\n      Transition excludeTransition=null;\n      if (atn.ruleToStartState[i].isLeftRecursiveRule) {\n        endState=null;\n        for (        ATNState state : atn.states) {\n          if (state.ruleIndex != i) {\n            continue;\n          }\n          if (!(state instanceof StarLoopEntryState)) {\n            continue;\n          }\n          ATNState maybeLoopEndState=state.transition(state.getNumberOfTransitions() - 1).target;\n          if (!(maybeLoopEndState instanceof LoopEndState)) {\n            continue;\n          }\n          if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\n            endState=state;\n            break;\n          }\n        }\n        if (endState == null) {\n          throw new UnsupportedOperationException(\"Couldn't identify final state of the precedence rule prefix section.\");\n        }\n        excludeTransition=((StarLoopEntryState)endState).loopBackState.transition(0);\n      }\n else {\n        endState=atn.ruleToStopState[i];\n      }\n      for (      ATNState state : atn.states) {\n        for (        Transition transition : state.transitions) {\n          if (transition == excludeTransition) {\n            continue;\n          }\n          if (transition.target == endState) {\n            transition.target=bypassStop;\n          }\n        }\n      }\n      while (atn.ruleToStartState[i].getNumberOfTransitions() > 0) {\n        Transition transition=atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].getNumberOfTransitions() - 1);\n        bypassStart.addTransition(transition);\n      }\n      atn.ruleToStartState[i].addTransition(new EpsilonTransition(bypassStart));\n      bypassStop.addTransition(new EpsilonTransition(endState));\n      ATNState matchState=new BasicState();\n      atn.addState(matchState);\n      matchState.addTransition(new AtomTransition(bypassStop,atn.ruleToTokenType[i]));\n      bypassStart.addTransition(new EpsilonTransition(matchState));\n    }\n    if (deserializationOptions.isVerifyATN()) {\n      verifyATN(atn);\n    }\n  }\n  return atn;\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1946,
      "astHeight" : 18
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 151,
        "startLineNumber" : 507,
        "startColumnNumber" : 5,
        "endLineNumber" : 509,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (endState == null) {\n  throw new UnsupportedOperationException(\"Couldn't identify final state of the precedence rule prefix section.\");\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 10,
      "astHeight" : 6
    },
    "tokenLength" : 3,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 16,
    "startLineNumber" : 507,
    "startColumnNumber" : 9,
    "endLineNumber" : 507,
    "endColumnNumber" : 25
  } ],
  "layoutRelationDataList" : [ ]
}