{
  "id" : 99,
  "expression" : "root",
  "projectName" : "skylot@jadx",
  "commitID" : "eb2a1734d3e02c19814f628e10bf80de5fb19772",
  "filePath" : "/jadx-gui/src/main/java/jadx/gui/plugins/mappings/MappingExporter.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "root",
    "nodeType" : "SimpleName",
    "nodePosition" : {
      "charLength" : 4,
      "startLineNumber" : 167,
      "startColumnNumber" : 24,
      "endLineNumber" : 167,
      "endColumnNumber" : 28
    },
    "astNodeNumber" : 1,
    "astHeight" : 1,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,expression]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 167,
        "startColumnNumber" : 24,
        "endLineNumber" : 167,
        "endColumnNumber" : 41
      },
      "nodeContext" : "root.getClasses()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4364,
        "startLineNumber" : 167,
        "startColumnNumber" : 3,
        "endLineNumber" : 253,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (ClassNode cls : root.getClasses()) {\n  ClassInfo classInfo=cls.getClassInfo();\n  String classPath=classInfo.makeRawFullName().replace('.','/');\n  String rawClassName=classInfo.getRawName();\n  if (classInfo.hasAlias() && !classInfo.getAliasShortName().equals(classInfo.getShortName()) && mappedClasses.contains(rawClassName)) {\n    mappingTree.visitClass(classPath);\n    String alias=classInfo.makeAliasRawFullName().replace('.','/');\n    if (alias.startsWith(Consts.DEFAULT_PACKAGE_NAME)) {\n      alias=alias.substring(Consts.DEFAULT_PACKAGE_NAME.length() + 1);\n    }\n    mappingTree.visitDstName(MappedElementKind.CLASS,0,alias);\n  }\n  if (comments.containsKey(rawClassName)) {\n    mappingTree.visitClass(classPath);\n    mappingTree.visitComment(MappedElementKind.CLASS,comments.get(rawClassName));\n  }\n  for (  FieldNode fld : cls.getFields()) {\n    FieldInfo fieldInfo=fld.getFieldInfo();\n    if (fieldInfo.hasAlias() && mappedFields.contains(rawClassName + fieldInfo.getShortId())) {\n      visitField(mappingTree,classPath,fieldInfo.getName(),TypeGen.signature(fieldInfo.getType()));\n      mappingTree.visitDstName(MappedElementKind.FIELD,0,fieldInfo.getAlias());\n    }\n    if (comments.containsKey(rawClassName + fieldInfo.getShortId())) {\n      visitField(mappingTree,classPath,fieldInfo.getName(),TypeGen.signature(fieldInfo.getType()));\n      mappingTree.visitComment(MappedElementKind.FIELD,comments.get(rawClassName + fieldInfo.getShortId()));\n    }\n  }\n  for (  MethodNode mth : cls.getMethods()) {\n    MethodInfo methodInfo=mth.getMethodInfo();\n    String methodName=methodInfo.getName();\n    String methodDesc=methodInfo.getShortId().substring(methodName.length());\n    if (methodInfo.hasAlias() && mappedMethods.contains(rawClassName + methodInfo.getShortId())) {\n      visitMethod(mappingTree,classPath,methodName,methodDesc);\n      mappingTree.visitDstName(MappedElementKind.METHOD,0,methodInfo.getAlias());\n    }\n    if (comments.containsKey(rawClassName + methodInfo.getShortId())) {\n      visitMethod(mappingTree,classPath,methodName,methodDesc);\n      mappingTree.visitComment(MappedElementKind.METHOD,comments.get(rawClassName + methodInfo.getShortId()));\n    }\n    if (!methodsWithMappedElements.contains(rawClassName + methodInfo.getShortId())) {\n      continue;\n    }\n    int lvtIndex=mth.getAccessFlags().isStatic() ? 0 : 1;\n    int lastArgLvIndex=lvtIndex - 1;\n    List<VarNode> args=collectMethodArgs(mth);\n    for (    VarNode arg : args) {\n      int lvIndex=arg.getReg() - args.get(0).getReg() + (mth.getAccessFlags().isStatic() ? 0 : 1);\n      String key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forVar(arg.getReg(),arg.getSsa());\n      if (mappedMethodArgsAndVars.containsKey(key)) {\n        visitMethodArg(mappingTree,classPath,methodName,methodDesc,args.indexOf(arg),lvIndex);\n        mappingTree.visitDstName(MappedElementKind.METHOD_ARG,0,mappedMethodArgsAndVars.get(key));\n        mappedMethodArgsAndVars.remove(key);\n      }\n      lastArgLvIndex=lvIndex;\n      lvtIndex++;\n    }\n    List<SimpleEntry<VarNode,Integer>> vars=collectMethodVars(mth);\n    for (    SimpleEntry<VarNode,Integer> entry : vars) {\n      VarNode var=entry.getKey();\n      int offset=entry.getValue();\n      int lvIndex=lastArgLvIndex + var.getReg() + (mth.getAccessFlags().isStatic() ? 0 : 1);\n      String key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forVar(var.getReg(),var.getSsa());\n      if (mappedMethodArgsAndVars.containsKey(key)) {\n        visitMethodVar(mappingTree,classPath,methodName,methodDesc,lvtIndex,lvIndex,offset);\n        mappingTree.visitDstName(MappedElementKind.METHOD_VAR,0,mappedMethodArgsAndVars.get(key));\n      }\n      key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forInsn(offset);\n      if (comments.containsKey(key)) {\n        visitMethodVar(mappingTree,classPath,methodName,methodDesc,lvtIndex,lvIndex,offset);\n        mappingTree.visitComment(MappedElementKind.METHOD_VAR,comments.get(key));\n      }\n      lvtIndex++;\n    }\n  }\n}\n",
      "nodeType" : "EnhancedForStatement",
      "astNodeNumber" : 606,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.TryStatement,body]",
      "nodePosition" : {
        "charLength" : 4862,
        "startLineNumber" : 153,
        "startColumnNumber" : 6,
        "endLineNumber" : 259,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  if (mappingFormat.hasSingleFile()) {\n    if (path.toFile().exists()) {\n      path.toFile().delete();\n    }\n    path.toFile().createNewFile();\n  }\n else {\n    FileUtils.makeDirs(path);\n  }\n  mappingTree.visitHeader();\n  mappingTree.visitNamespaces(\"official\",Arrays.asList(\"named\"));\n  mappingTree.visitContent();\n  for (  ClassNode cls : root.getClasses()) {\n    ClassInfo classInfo=cls.getClassInfo();\n    String classPath=classInfo.makeRawFullName().replace('.','/');\n    String rawClassName=classInfo.getRawName();\n    if (classInfo.hasAlias() && !classInfo.getAliasShortName().equals(classInfo.getShortName()) && mappedClasses.contains(rawClassName)) {\n      mappingTree.visitClass(classPath);\n      String alias=classInfo.makeAliasRawFullName().replace('.','/');\n      if (alias.startsWith(Consts.DEFAULT_PACKAGE_NAME)) {\n        alias=alias.substring(Consts.DEFAULT_PACKAGE_NAME.length() + 1);\n      }\n      mappingTree.visitDstName(MappedElementKind.CLASS,0,alias);\n    }\n    if (comments.containsKey(rawClassName)) {\n      mappingTree.visitClass(classPath);\n      mappingTree.visitComment(MappedElementKind.CLASS,comments.get(rawClassName));\n    }\n    for (    FieldNode fld : cls.getFields()) {\n      FieldInfo fieldInfo=fld.getFieldInfo();\n      if (fieldInfo.hasAlias() && mappedFields.contains(rawClassName + fieldInfo.getShortId())) {\n        visitField(mappingTree,classPath,fieldInfo.getName(),TypeGen.signature(fieldInfo.getType()));\n        mappingTree.visitDstName(MappedElementKind.FIELD,0,fieldInfo.getAlias());\n      }\n      if (comments.containsKey(rawClassName + fieldInfo.getShortId())) {\n        visitField(mappingTree,classPath,fieldInfo.getName(),TypeGen.signature(fieldInfo.getType()));\n        mappingTree.visitComment(MappedElementKind.FIELD,comments.get(rawClassName + fieldInfo.getShortId()));\n      }\n    }\n    for (    MethodNode mth : cls.getMethods()) {\n      MethodInfo methodInfo=mth.getMethodInfo();\n      String methodName=methodInfo.getName();\n      String methodDesc=methodInfo.getShortId().substring(methodName.length());\n      if (methodInfo.hasAlias() && mappedMethods.contains(rawClassName + methodInfo.getShortId())) {\n        visitMethod(mappingTree,classPath,methodName,methodDesc);\n        mappingTree.visitDstName(MappedElementKind.METHOD,0,methodInfo.getAlias());\n      }\n      if (comments.containsKey(rawClassName + methodInfo.getShortId())) {\n        visitMethod(mappingTree,classPath,methodName,methodDesc);\n        mappingTree.visitComment(MappedElementKind.METHOD,comments.get(rawClassName + methodInfo.getShortId()));\n      }\n      if (!methodsWithMappedElements.contains(rawClassName + methodInfo.getShortId())) {\n        continue;\n      }\n      int lvtIndex=mth.getAccessFlags().isStatic() ? 0 : 1;\n      int lastArgLvIndex=lvtIndex - 1;\n      List<VarNode> args=collectMethodArgs(mth);\n      for (      VarNode arg : args) {\n        int lvIndex=arg.getReg() - args.get(0).getReg() + (mth.getAccessFlags().isStatic() ? 0 : 1);\n        String key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forVar(arg.getReg(),arg.getSsa());\n        if (mappedMethodArgsAndVars.containsKey(key)) {\n          visitMethodArg(mappingTree,classPath,methodName,methodDesc,args.indexOf(arg),lvIndex);\n          mappingTree.visitDstName(MappedElementKind.METHOD_ARG,0,mappedMethodArgsAndVars.get(key));\n          mappedMethodArgsAndVars.remove(key);\n        }\n        lastArgLvIndex=lvIndex;\n        lvtIndex++;\n      }\n      List<SimpleEntry<VarNode,Integer>> vars=collectMethodVars(mth);\n      for (      SimpleEntry<VarNode,Integer> entry : vars) {\n        VarNode var=entry.getKey();\n        int offset=entry.getValue();\n        int lvIndex=lastArgLvIndex + var.getReg() + (mth.getAccessFlags().isStatic() ? 0 : 1);\n        String key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forVar(var.getReg(),var.getSsa());\n        if (mappedMethodArgsAndVars.containsKey(key)) {\n          visitMethodVar(mappingTree,classPath,methodName,methodDesc,lvtIndex,lvIndex,offset);\n          mappingTree.visitDstName(MappedElementKind.METHOD_VAR,0,mappedMethodArgsAndVars.get(key));\n        }\n        key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forInsn(offset);\n        if (comments.containsKey(key)) {\n          visitMethodVar(mappingTree,classPath,methodName,methodDesc,lvtIndex,lvIndex,offset);\n          mappingTree.visitComment(MappedElementKind.METHOD_VAR,comments.get(key));\n        }\n        lvtIndex++;\n      }\n    }\n  }\n  MappingWriter writer=MappingWriter.create(path,mappingFormat);\n  mappingTree.accept(writer);\n  mappingTree.visitEnd();\n  writer.close();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 677,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 4982,
        "startLineNumber" : 153,
        "startColumnNumber" : 2,
        "endLineNumber" : 261,
        "endColumnNumber" : 3
      },
      "nodeContext" : "try {\n  if (mappingFormat.hasSingleFile()) {\n    if (path.toFile().exists()) {\n      path.toFile().delete();\n    }\n    path.toFile().createNewFile();\n  }\n else {\n    FileUtils.makeDirs(path);\n  }\n  mappingTree.visitHeader();\n  mappingTree.visitNamespaces(\"official\",Arrays.asList(\"named\"));\n  mappingTree.visitContent();\n  for (  ClassNode cls : root.getClasses()) {\n    ClassInfo classInfo=cls.getClassInfo();\n    String classPath=classInfo.makeRawFullName().replace('.','/');\n    String rawClassName=classInfo.getRawName();\n    if (classInfo.hasAlias() && !classInfo.getAliasShortName().equals(classInfo.getShortName()) && mappedClasses.contains(rawClassName)) {\n      mappingTree.visitClass(classPath);\n      String alias=classInfo.makeAliasRawFullName().replace('.','/');\n      if (alias.startsWith(Consts.DEFAULT_PACKAGE_NAME)) {\n        alias=alias.substring(Consts.DEFAULT_PACKAGE_NAME.length() + 1);\n      }\n      mappingTree.visitDstName(MappedElementKind.CLASS,0,alias);\n    }\n    if (comments.containsKey(rawClassName)) {\n      mappingTree.visitClass(classPath);\n      mappingTree.visitComment(MappedElementKind.CLASS,comments.get(rawClassName));\n    }\n    for (    FieldNode fld : cls.getFields()) {\n      FieldInfo fieldInfo=fld.getFieldInfo();\n      if (fieldInfo.hasAlias() && mappedFields.contains(rawClassName + fieldInfo.getShortId())) {\n        visitField(mappingTree,classPath,fieldInfo.getName(),TypeGen.signature(fieldInfo.getType()));\n        mappingTree.visitDstName(MappedElementKind.FIELD,0,fieldInfo.getAlias());\n      }\n      if (comments.containsKey(rawClassName + fieldInfo.getShortId())) {\n        visitField(mappingTree,classPath,fieldInfo.getName(),TypeGen.signature(fieldInfo.getType()));\n        mappingTree.visitComment(MappedElementKind.FIELD,comments.get(rawClassName + fieldInfo.getShortId()));\n      }\n    }\n    for (    MethodNode mth : cls.getMethods()) {\n      MethodInfo methodInfo=mth.getMethodInfo();\n      String methodName=methodInfo.getName();\n      String methodDesc=methodInfo.getShortId().substring(methodName.length());\n      if (methodInfo.hasAlias() && mappedMethods.contains(rawClassName + methodInfo.getShortId())) {\n        visitMethod(mappingTree,classPath,methodName,methodDesc);\n        mappingTree.visitDstName(MappedElementKind.METHOD,0,methodInfo.getAlias());\n      }\n      if (comments.containsKey(rawClassName + methodInfo.getShortId())) {\n        visitMethod(mappingTree,classPath,methodName,methodDesc);\n        mappingTree.visitComment(MappedElementKind.METHOD,comments.get(rawClassName + methodInfo.getShortId()));\n      }\n      if (!methodsWithMappedElements.contains(rawClassName + methodInfo.getShortId())) {\n        continue;\n      }\n      int lvtIndex=mth.getAccessFlags().isStatic() ? 0 : 1;\n      int lastArgLvIndex=lvtIndex - 1;\n      List<VarNode> args=collectMethodArgs(mth);\n      for (      VarNode arg : args) {\n        int lvIndex=arg.getReg() - args.get(0).getReg() + (mth.getAccessFlags().isStatic() ? 0 : 1);\n        String key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forVar(arg.getReg(),arg.getSsa());\n        if (mappedMethodArgsAndVars.containsKey(key)) {\n          visitMethodArg(mappingTree,classPath,methodName,methodDesc,args.indexOf(arg),lvIndex);\n          mappingTree.visitDstName(MappedElementKind.METHOD_ARG,0,mappedMethodArgsAndVars.get(key));\n          mappedMethodArgsAndVars.remove(key);\n        }\n        lastArgLvIndex=lvIndex;\n        lvtIndex++;\n      }\n      List<SimpleEntry<VarNode,Integer>> vars=collectMethodVars(mth);\n      for (      SimpleEntry<VarNode,Integer> entry : vars) {\n        VarNode var=entry.getKey();\n        int offset=entry.getValue();\n        int lvIndex=lastArgLvIndex + var.getReg() + (mth.getAccessFlags().isStatic() ? 0 : 1);\n        String key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forVar(var.getReg(),var.getSsa());\n        if (mappedMethodArgsAndVars.containsKey(key)) {\n          visitMethodVar(mappingTree,classPath,methodName,methodDesc,lvtIndex,lvIndex,offset);\n          mappingTree.visitDstName(MappedElementKind.METHOD_VAR,0,mappedMethodArgsAndVars.get(key));\n        }\n        key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forInsn(offset);\n        if (comments.containsKey(key)) {\n          visitMethodVar(mappingTree,classPath,methodName,methodDesc,lvtIndex,lvIndex,offset);\n          mappingTree.visitComment(MappedElementKind.METHOD_VAR,comments.get(key));\n        }\n        lvtIndex++;\n      }\n    }\n  }\n  MappingWriter writer=MappingWriter.create(path,mappingFormat);\n  mappingTree.accept(writer);\n  mappingTree.visitEnd();\n  writer.close();\n}\n catch (IOException e) {\n  LOG.error(\"Failed to save deobfuscation map file '{}'\",path.toAbsolutePath(),e);\n}\n",
      "nodeType" : "TryStatement",
      "astNodeNumber" : 693,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 7088,
        "startLineNumber" : 112,
        "startColumnNumber" : 91,
        "endLineNumber" : 262,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  MemoryMappingTree mappingTree=new MemoryMappingTree();\n  Set<String> mappedClasses=new HashSet<>();\n  Set<String> mappedFields=new HashSet<>();\n  Set<String> mappedMethods=new HashSet<>();\n  Set<String> methodsWithMappedElements=new HashSet<>();\n  Map<String,String> mappedMethodArgsAndVars=new HashMap<>();\n  Map<String,String> comments=new HashMap<>();\n  for (  ICodeRename codeRename : codeData.getRenames()) {\n    if (codeRename.getNodeRef().getType().equals(RefType.CLASS)) {\n      mappedClasses.add(codeRename.getNodeRef().getDeclaringClass());\n    }\n else     if (codeRename.getNodeRef().getType().equals(RefType.FIELD)) {\n      mappedFields.add(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId());\n    }\n else     if (codeRename.getNodeRef().getType().equals(RefType.METHOD)) {\n      if (codeRename.getCodeRef() == null) {\n        mappedMethods.add(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId());\n      }\n else {\n        methodsWithMappedElements.add(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId());\n        mappedMethodArgsAndVars.put(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId() + codeRename.getCodeRef(),codeRename.getNewName());\n      }\n    }\n  }\n  for (  ICodeComment codeComment : codeData.getComments()) {\n    comments.put(codeComment.getNodeRef().getDeclaringClass() + (codeComment.getNodeRef().getShortId() == null ? \"\" : codeComment.getNodeRef().getShortId()) + (codeComment.getCodeRef() == null ? \"\" : codeComment.getCodeRef()),codeComment.getComment());\n    if (codeComment.getCodeRef() != null) {\n      methodsWithMappedElements.add(codeComment.getNodeRef().getDeclaringClass() + codeComment.getNodeRef().getShortId());\n    }\n  }\n  try {\n    if (mappingFormat.hasSingleFile()) {\n      if (path.toFile().exists()) {\n        path.toFile().delete();\n      }\n      path.toFile().createNewFile();\n    }\n else {\n      FileUtils.makeDirs(path);\n    }\n    mappingTree.visitHeader();\n    mappingTree.visitNamespaces(\"official\",Arrays.asList(\"named\"));\n    mappingTree.visitContent();\n    for (    ClassNode cls : root.getClasses()) {\n      ClassInfo classInfo=cls.getClassInfo();\n      String classPath=classInfo.makeRawFullName().replace('.','/');\n      String rawClassName=classInfo.getRawName();\n      if (classInfo.hasAlias() && !classInfo.getAliasShortName().equals(classInfo.getShortName()) && mappedClasses.contains(rawClassName)) {\n        mappingTree.visitClass(classPath);\n        String alias=classInfo.makeAliasRawFullName().replace('.','/');\n        if (alias.startsWith(Consts.DEFAULT_PACKAGE_NAME)) {\n          alias=alias.substring(Consts.DEFAULT_PACKAGE_NAME.length() + 1);\n        }\n        mappingTree.visitDstName(MappedElementKind.CLASS,0,alias);\n      }\n      if (comments.containsKey(rawClassName)) {\n        mappingTree.visitClass(classPath);\n        mappingTree.visitComment(MappedElementKind.CLASS,comments.get(rawClassName));\n      }\n      for (      FieldNode fld : cls.getFields()) {\n        FieldInfo fieldInfo=fld.getFieldInfo();\n        if (fieldInfo.hasAlias() && mappedFields.contains(rawClassName + fieldInfo.getShortId())) {\n          visitField(mappingTree,classPath,fieldInfo.getName(),TypeGen.signature(fieldInfo.getType()));\n          mappingTree.visitDstName(MappedElementKind.FIELD,0,fieldInfo.getAlias());\n        }\n        if (comments.containsKey(rawClassName + fieldInfo.getShortId())) {\n          visitField(mappingTree,classPath,fieldInfo.getName(),TypeGen.signature(fieldInfo.getType()));\n          mappingTree.visitComment(MappedElementKind.FIELD,comments.get(rawClassName + fieldInfo.getShortId()));\n        }\n      }\n      for (      MethodNode mth : cls.getMethods()) {\n        MethodInfo methodInfo=mth.getMethodInfo();\n        String methodName=methodInfo.getName();\n        String methodDesc=methodInfo.getShortId().substring(methodName.length());\n        if (methodInfo.hasAlias() && mappedMethods.contains(rawClassName + methodInfo.getShortId())) {\n          visitMethod(mappingTree,classPath,methodName,methodDesc);\n          mappingTree.visitDstName(MappedElementKind.METHOD,0,methodInfo.getAlias());\n        }\n        if (comments.containsKey(rawClassName + methodInfo.getShortId())) {\n          visitMethod(mappingTree,classPath,methodName,methodDesc);\n          mappingTree.visitComment(MappedElementKind.METHOD,comments.get(rawClassName + methodInfo.getShortId()));\n        }\n        if (!methodsWithMappedElements.contains(rawClassName + methodInfo.getShortId())) {\n          continue;\n        }\n        int lvtIndex=mth.getAccessFlags().isStatic() ? 0 : 1;\n        int lastArgLvIndex=lvtIndex - 1;\n        List<VarNode> args=collectMethodArgs(mth);\n        for (        VarNode arg : args) {\n          int lvIndex=arg.getReg() - args.get(0).getReg() + (mth.getAccessFlags().isStatic() ? 0 : 1);\n          String key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forVar(arg.getReg(),arg.getSsa());\n          if (mappedMethodArgsAndVars.containsKey(key)) {\n            visitMethodArg(mappingTree,classPath,methodName,methodDesc,args.indexOf(arg),lvIndex);\n            mappingTree.visitDstName(MappedElementKind.METHOD_ARG,0,mappedMethodArgsAndVars.get(key));\n            mappedMethodArgsAndVars.remove(key);\n          }\n          lastArgLvIndex=lvIndex;\n          lvtIndex++;\n        }\n        List<SimpleEntry<VarNode,Integer>> vars=collectMethodVars(mth);\n        for (        SimpleEntry<VarNode,Integer> entry : vars) {\n          VarNode var=entry.getKey();\n          int offset=entry.getValue();\n          int lvIndex=lastArgLvIndex + var.getReg() + (mth.getAccessFlags().isStatic() ? 0 : 1);\n          String key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forVar(var.getReg(),var.getSsa());\n          if (mappedMethodArgsAndVars.containsKey(key)) {\n            visitMethodVar(mappingTree,classPath,methodName,methodDesc,lvtIndex,lvIndex,offset);\n            mappingTree.visitDstName(MappedElementKind.METHOD_VAR,0,mappedMethodArgsAndVars.get(key));\n          }\n          key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forInsn(offset);\n          if (comments.containsKey(key)) {\n            visitMethodVar(mappingTree,classPath,methodName,methodDesc,lvtIndex,lvIndex,offset);\n            mappingTree.visitComment(MappedElementKind.METHOD_VAR,comments.get(key));\n          }\n          lvtIndex++;\n        }\n      }\n    }\n    MappingWriter writer=MappingWriter.create(path,mappingFormat);\n    mappingTree.accept(writer);\n    mappingTree.visitEnd();\n    writer.close();\n  }\n catch (  IOException e) {\n    LOG.error(\"Failed to save deobfuscation map file '{}'\",path.toAbsolutePath(),e);\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 976,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 7178,
        "startLineNumber" : 112,
        "startColumnNumber" : 1,
        "endLineNumber" : 262,
        "endColumnNumber" : 2
      },
      "nodeContext" : "public void exportMappings(Path path,JadxCodeData codeData,MappingFormat mappingFormat){\n  MemoryMappingTree mappingTree=new MemoryMappingTree();\n  Set<String> mappedClasses=new HashSet<>();\n  Set<String> mappedFields=new HashSet<>();\n  Set<String> mappedMethods=new HashSet<>();\n  Set<String> methodsWithMappedElements=new HashSet<>();\n  Map<String,String> mappedMethodArgsAndVars=new HashMap<>();\n  Map<String,String> comments=new HashMap<>();\n  for (  ICodeRename codeRename : codeData.getRenames()) {\n    if (codeRename.getNodeRef().getType().equals(RefType.CLASS)) {\n      mappedClasses.add(codeRename.getNodeRef().getDeclaringClass());\n    }\n else     if (codeRename.getNodeRef().getType().equals(RefType.FIELD)) {\n      mappedFields.add(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId());\n    }\n else     if (codeRename.getNodeRef().getType().equals(RefType.METHOD)) {\n      if (codeRename.getCodeRef() == null) {\n        mappedMethods.add(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId());\n      }\n else {\n        methodsWithMappedElements.add(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId());\n        mappedMethodArgsAndVars.put(codeRename.getNodeRef().getDeclaringClass() + codeRename.getNodeRef().getShortId() + codeRename.getCodeRef(),codeRename.getNewName());\n      }\n    }\n  }\n  for (  ICodeComment codeComment : codeData.getComments()) {\n    comments.put(codeComment.getNodeRef().getDeclaringClass() + (codeComment.getNodeRef().getShortId() == null ? \"\" : codeComment.getNodeRef().getShortId()) + (codeComment.getCodeRef() == null ? \"\" : codeComment.getCodeRef()),codeComment.getComment());\n    if (codeComment.getCodeRef() != null) {\n      methodsWithMappedElements.add(codeComment.getNodeRef().getDeclaringClass() + codeComment.getNodeRef().getShortId());\n    }\n  }\n  try {\n    if (mappingFormat.hasSingleFile()) {\n      if (path.toFile().exists()) {\n        path.toFile().delete();\n      }\n      path.toFile().createNewFile();\n    }\n else {\n      FileUtils.makeDirs(path);\n    }\n    mappingTree.visitHeader();\n    mappingTree.visitNamespaces(\"official\",Arrays.asList(\"named\"));\n    mappingTree.visitContent();\n    for (    ClassNode cls : root.getClasses()) {\n      ClassInfo classInfo=cls.getClassInfo();\n      String classPath=classInfo.makeRawFullName().replace('.','/');\n      String rawClassName=classInfo.getRawName();\n      if (classInfo.hasAlias() && !classInfo.getAliasShortName().equals(classInfo.getShortName()) && mappedClasses.contains(rawClassName)) {\n        mappingTree.visitClass(classPath);\n        String alias=classInfo.makeAliasRawFullName().replace('.','/');\n        if (alias.startsWith(Consts.DEFAULT_PACKAGE_NAME)) {\n          alias=alias.substring(Consts.DEFAULT_PACKAGE_NAME.length() + 1);\n        }\n        mappingTree.visitDstName(MappedElementKind.CLASS,0,alias);\n      }\n      if (comments.containsKey(rawClassName)) {\n        mappingTree.visitClass(classPath);\n        mappingTree.visitComment(MappedElementKind.CLASS,comments.get(rawClassName));\n      }\n      for (      FieldNode fld : cls.getFields()) {\n        FieldInfo fieldInfo=fld.getFieldInfo();\n        if (fieldInfo.hasAlias() && mappedFields.contains(rawClassName + fieldInfo.getShortId())) {\n          visitField(mappingTree,classPath,fieldInfo.getName(),TypeGen.signature(fieldInfo.getType()));\n          mappingTree.visitDstName(MappedElementKind.FIELD,0,fieldInfo.getAlias());\n        }\n        if (comments.containsKey(rawClassName + fieldInfo.getShortId())) {\n          visitField(mappingTree,classPath,fieldInfo.getName(),TypeGen.signature(fieldInfo.getType()));\n          mappingTree.visitComment(MappedElementKind.FIELD,comments.get(rawClassName + fieldInfo.getShortId()));\n        }\n      }\n      for (      MethodNode mth : cls.getMethods()) {\n        MethodInfo methodInfo=mth.getMethodInfo();\n        String methodName=methodInfo.getName();\n        String methodDesc=methodInfo.getShortId().substring(methodName.length());\n        if (methodInfo.hasAlias() && mappedMethods.contains(rawClassName + methodInfo.getShortId())) {\n          visitMethod(mappingTree,classPath,methodName,methodDesc);\n          mappingTree.visitDstName(MappedElementKind.METHOD,0,methodInfo.getAlias());\n        }\n        if (comments.containsKey(rawClassName + methodInfo.getShortId())) {\n          visitMethod(mappingTree,classPath,methodName,methodDesc);\n          mappingTree.visitComment(MappedElementKind.METHOD,comments.get(rawClassName + methodInfo.getShortId()));\n        }\n        if (!methodsWithMappedElements.contains(rawClassName + methodInfo.getShortId())) {\n          continue;\n        }\n        int lvtIndex=mth.getAccessFlags().isStatic() ? 0 : 1;\n        int lastArgLvIndex=lvtIndex - 1;\n        List<VarNode> args=collectMethodArgs(mth);\n        for (        VarNode arg : args) {\n          int lvIndex=arg.getReg() - args.get(0).getReg() + (mth.getAccessFlags().isStatic() ? 0 : 1);\n          String key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forVar(arg.getReg(),arg.getSsa());\n          if (mappedMethodArgsAndVars.containsKey(key)) {\n            visitMethodArg(mappingTree,classPath,methodName,methodDesc,args.indexOf(arg),lvIndex);\n            mappingTree.visitDstName(MappedElementKind.METHOD_ARG,0,mappedMethodArgsAndVars.get(key));\n            mappedMethodArgsAndVars.remove(key);\n          }\n          lastArgLvIndex=lvIndex;\n          lvtIndex++;\n        }\n        List<SimpleEntry<VarNode,Integer>> vars=collectMethodVars(mth);\n        for (        SimpleEntry<VarNode,Integer> entry : vars) {\n          VarNode var=entry.getKey();\n          int offset=entry.getValue();\n          int lvIndex=lastArgLvIndex + var.getReg() + (mth.getAccessFlags().isStatic() ? 0 : 1);\n          String key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forVar(var.getReg(),var.getSsa());\n          if (mappedMethodArgsAndVars.containsKey(key)) {\n            visitMethodVar(mappingTree,classPath,methodName,methodDesc,lvtIndex,lvIndex,offset);\n            mappingTree.visitDstName(MappedElementKind.METHOD_VAR,0,mappedMethodArgsAndVars.get(key));\n          }\n          key=rawClassName + methodInfo.getShortId() + JadxCodeRef.forInsn(offset);\n          if (comments.containsKey(key)) {\n            visitMethodVar(mappingTree,classPath,methodName,methodDesc,lvtIndex,lvIndex,offset);\n            mappingTree.visitComment(MappedElementKind.METHOD_VAR,comments.get(key));\n          }\n          lvtIndex++;\n        }\n      }\n    }\n    MappingWriter writer=MappingWriter.create(path,mappingFormat);\n    mappingTree.accept(writer);\n    mappingTree.visitEnd();\n    writer.close();\n  }\n catch (  IOException e) {\n    LOG.error(\"Failed to save deobfuscation map file '{}'\",path.toAbsolutePath(),e);\n  }\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 992,
      "astHeight" : 18
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.EnhancedForStatement,expression]",
      "nodePosition" : {
        "charLength" : 17,
        "startLineNumber" : 167,
        "startColumnNumber" : 24,
        "endLineNumber" : 167,
        "endColumnNumber" : 41
      },
      "nodeContext" : "root.getClasses()",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 3,
      "astHeight" : 2
    },
    "tokenLength" : 1,
    "type" : "jadx.core.dex.nodes.RootNode"
  } ],
  "positionList" : [ {
    "charLength" : 4,
    "startLineNumber" : 167,
    "startColumnNumber" : 24,
    "endLineNumber" : 167,
    "endColumnNumber" : 28
  } ],
  "layoutRelationDataList" : [ ]
}