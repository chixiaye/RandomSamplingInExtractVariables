{
  "id" : 189,
  "expression" : "MathUtils.isPowerOfTwo(texWidth)",
  "projectName" : "libgdx@libgdx",
  "commitID" : "3485b16e8979c0141421bc80cb8831b7a0403f67",
  "filePath" : "/extensions/gdx-tools/src/com/badlogic/gdx/tools/ktx/KTXProcessor.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "MathUtils.isPowerOfTwo(texWidth)",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 32,
      "startLineNumber" : 172,
      "startColumnNumber" : 11,
      "endLineNumber" : 172,
      "endColumnNumber" : 43
    },
    "astNodeNumber" : 4,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.InfixExpression,leftOperand]",
      "nodePosition" : {
        "charLength" : 33,
        "startLineNumber" : 172,
        "startColumnNumber" : 10,
        "endLineNumber" : 172,
        "endColumnNumber" : 43
      },
      "nodeContext" : "!MathUtils.isPowerOfTwo(texWidth)",
      "nodeType" : "PrefixExpression",
      "astNodeNumber" : 5,
      "astHeight" : 3
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 172,
        "startColumnNumber" : 10,
        "endLineNumber" : 172,
        "endColumnNumber" : 81
      },
      "nodeContext" : "!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 216,
        "startLineNumber" : 172,
        "startColumnNumber" : 6,
        "endLineNumber" : 174,
        "endColumnNumber" : 99
      },
      "nodeContext" : "if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight)) throw new GdxRuntimeException(\"Invalid input : mipmap generation is only available for power of two textures : \" + file);\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 19,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,thenStatement]",
      "nodePosition" : {
        "charLength" : 379,
        "startLineNumber" : 171,
        "startColumnNumber" : 23,
        "endLineNumber" : 177,
        "endColumnNumber" : 6
      },
      "nodeContext" : "{\n  if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight))   throw new GdxRuntimeException(\"Invalid input : mipmap generation is only available for power of two textures : \" + file);\n  nLevels=Math.max(Integer.SIZE - Integer.numberOfLeadingZeros(texWidth),Integer.SIZE - Integer.numberOfLeadingZeros(texHeight));\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 42,
      "astHeight" : 7
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 397,
        "startLineNumber" : 171,
        "startColumnNumber" : 5,
        "endLineNumber" : 177,
        "endColumnNumber" : 6
      },
      "nodeContext" : "if (isGenMipMaps) {\n  if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight))   throw new GdxRuntimeException(\"Invalid input : mipmap generation is only available for power of two textures : \" + file);\n  nLevels=Math.max(Integer.SIZE - Integer.numberOfLeadingZeros(texWidth),Integer.SIZE - Integer.numberOfLeadingZeros(texHeight));\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 44,
      "astHeight" : 8
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,elseStatement]",
      "nodePosition" : {
        "charLength" : 1355,
        "startLineNumber" : 146,
        "startColumnNumber" : 11,
        "endLineNumber" : 178,
        "endColumnNumber" : 5
      },
      "nodeContext" : "{\n  file=new FileHandle(args[face]);\n  System.out.println(\"Processing : \" + file + \" for face #\"+ face);\n  if (file.name().toLowerCase().endsWith(\".ktx\") || file.name().toLowerCase().endsWith(\".zktx\")) {\n    if (ktx == null || ktx.getNumberOfFaces() != 6) {\n      ktxDispose=DISPOSE_FACE;\n      ktx=new KTXTextureData(file,false);\n      ktx.prepare();\n    }\n    nLevels=ktx.getNumberOfMipMapLevels();\n    texWidth=ktx.getWidth();\n    texHeight=ktx.getHeight();\n  }\n else   if (file.name().toLowerCase().endsWith(\".etc1\")) {\n    etc1=new ETC1Data(file);\n    nLevels=1;\n    texWidth=etc1.width;\n    texHeight=etc1.height;\n  }\n else {\n    facePixmap=new Pixmap(file);\n    facePixmap.setBlending(Blending.None);\n    facePixmap.setFilter(Filter.BiLinear);\n    nLevels=1;\n    texWidth=facePixmap.getWidth();\n    texHeight=facePixmap.getHeight();\n  }\n  if (isGenMipMaps) {\n    if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight))     throw new GdxRuntimeException(\"Invalid input : mipmap generation is only available for power of two textures : \" + file);\n    nLevels=Math.max(Integer.SIZE - Integer.numberOfLeadingZeros(texWidth),Integer.SIZE - Integer.numberOfLeadingZeros(texHeight));\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 200,
      "astHeight" : 10
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 1553,
        "startLineNumber" : 142,
        "startColumnNumber" : 4,
        "endLineNumber" : 178,
        "endColumnNumber" : 5
      },
      "nodeContext" : "if (ktx != null && ktx.getNumberOfFaces() == 6) {\n  nLevels=ktx.getNumberOfMipMapLevels();\n  ktxFace=face;\n}\n else {\n  file=new FileHandle(args[face]);\n  System.out.println(\"Processing : \" + file + \" for face #\"+ face);\n  if (file.name().toLowerCase().endsWith(\".ktx\") || file.name().toLowerCase().endsWith(\".zktx\")) {\n    if (ktx == null || ktx.getNumberOfFaces() != 6) {\n      ktxDispose=DISPOSE_FACE;\n      ktx=new KTXTextureData(file,false);\n      ktx.prepare();\n    }\n    nLevels=ktx.getNumberOfMipMapLevels();\n    texWidth=ktx.getWidth();\n    texHeight=ktx.getHeight();\n  }\n else   if (file.name().toLowerCase().endsWith(\".etc1\")) {\n    etc1=new ETC1Data(file);\n    nLevels=1;\n    texWidth=etc1.width;\n    texHeight=etc1.height;\n  }\n else {\n    facePixmap=new Pixmap(file);\n    facePixmap.setBlending(Blending.None);\n    facePixmap.setFilter(Filter.BiLinear);\n    nLevels=1;\n    texWidth=facePixmap.getWidth();\n    texHeight=facePixmap.getHeight();\n  }\n  if (isGenMipMaps) {\n    if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight))     throw new GdxRuntimeException(\"Invalid input : mipmap generation is only available for power of two textures : \" + file);\n    nLevels=Math.max(Integer.SIZE - Integer.numberOfLeadingZeros(texWidth),Integer.SIZE - Integer.numberOfLeadingZeros(texHeight));\n  }\n}\n",
      "nodeType" : "IfStatement",
      "astNodeNumber" : 221,
      "astHeight" : 11
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ForStatement,body]",
      "nodePosition" : {
        "charLength" : 5632,
        "startLineNumber" : 136,
        "startColumnNumber" : 45,
        "endLineNumber" : 275,
        "endColumnNumber" : 4
      },
      "nodeContext" : "{\n  ETC1Data etc1=null;\n  Pixmap facePixmap=null;\n  int ktxFace=0;\n  if (ktx != null && ktx.getNumberOfFaces() == 6) {\n    nLevels=ktx.getNumberOfMipMapLevels();\n    ktxFace=face;\n  }\n else {\n    file=new FileHandle(args[face]);\n    System.out.println(\"Processing : \" + file + \" for face #\"+ face);\n    if (file.name().toLowerCase().endsWith(\".ktx\") || file.name().toLowerCase().endsWith(\".zktx\")) {\n      if (ktx == null || ktx.getNumberOfFaces() != 6) {\n        ktxDispose=DISPOSE_FACE;\n        ktx=new KTXTextureData(file,false);\n        ktx.prepare();\n      }\n      nLevels=ktx.getNumberOfMipMapLevels();\n      texWidth=ktx.getWidth();\n      texHeight=ktx.getHeight();\n    }\n else     if (file.name().toLowerCase().endsWith(\".etc1\")) {\n      etc1=new ETC1Data(file);\n      nLevels=1;\n      texWidth=etc1.width;\n      texHeight=etc1.height;\n    }\n else {\n      facePixmap=new Pixmap(file);\n      facePixmap.setBlending(Blending.None);\n      facePixmap.setFilter(Filter.BiLinear);\n      nLevels=1;\n      texWidth=facePixmap.getWidth();\n      texHeight=facePixmap.getHeight();\n    }\n    if (isGenMipMaps) {\n      if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight))       throw new GdxRuntimeException(\"Invalid input : mipmap generation is only available for power of two textures : \" + file);\n      nLevels=Math.max(Integer.SIZE - Integer.numberOfLeadingZeros(texWidth),Integer.SIZE - Integer.numberOfLeadingZeros(texHeight));\n    }\n  }\n  images[face]=new Image[nLevels];\n  for (int level=0; level < nLevels; level++) {\n    int levelWidth=Math.max(1,texWidth >> level);\n    int levelHeight=Math.max(1,texHeight >> level);\n    Pixmap levelPixmap=null;\n    ETC1Data levelETCData=null;\n    if (ktx != null) {\n      ByteBuffer ktxData=ktx.getData(level,ktxFace);\n      if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)       levelETCData=new ETC1Data(levelWidth,levelHeight,ktxData,0);\n    }\n    if (ktx != null && levelETCData == null && facePixmap == null) {\n      ByteBuffer ktxData=ktx.getData(0,ktxFace);\n      if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)       facePixmap=ETC1.decodeImage(new ETC1Data(levelWidth,levelHeight,ktxData,0),Format.RGB888);\n    }\n    if (level == 0 && etc1 != null) {\n      levelETCData=etc1;\n    }\n    if (levelETCData == null && etc1 != null && facePixmap == null) {\n      facePixmap=ETC1.decodeImage(etc1,Format.RGB888);\n    }\n    if (levelETCData == null) {\n      levelPixmap=new Pixmap(levelWidth,levelHeight,facePixmap.getFormat());\n      levelPixmap.setBlending(Blending.None);\n      levelPixmap.setFilter(Filter.BiLinear);\n      levelPixmap.drawPixmap(facePixmap,0,0,facePixmap.getWidth(),facePixmap.getHeight(),0,0,levelPixmap.getWidth(),levelPixmap.getHeight());\n    }\n    if (levelETCData == null && levelPixmap == null)     throw new GdxRuntimeException(\"Failed to load data for face \" + face + \" / mipmap level \"+ level);\n    if (isAlphaAtlas) {\n      if (levelPixmap == null)       levelPixmap=ETC1.decodeImage(levelETCData,Format.RGB888);\n      int w=levelPixmap.getWidth(), h=levelPixmap.getHeight();\n      Pixmap pm=new Pixmap(w,h * 2,levelPixmap.getFormat());\n      pm.setBlending(Blending.None);\n      pm.setFilter(Filter.BiLinear);\n      pm.drawPixmap(levelPixmap,0,0);\n      for (int y=0; y < h; y++) {\n        for (int x=0; x < w; x++) {\n          int alpha=(levelPixmap.getPixel(x,y)) & 0x0FF;\n          pm.drawPixel(x,y + h,(alpha << 24) | (alpha << 16) | (alpha << 8)| 0x0FF);\n        }\n      }\n      levelPixmap.dispose();\n      levelPixmap=pm;\n      levelETCData=null;\n    }\n    if (levelETCData == null && isPackETC1) {\n      if (levelPixmap.getFormat() != Format.RGB888 && levelPixmap.getFormat() != Format.RGB565) {\n        if (!isAlphaAtlas)         System.out.println(\"Converting from \" + levelPixmap.getFormat() + \" to RGB888 for ETC1 compression\");\n        Pixmap tmp=new Pixmap(levelPixmap.getWidth(),levelPixmap.getHeight(),Format.RGB888);\n        tmp.setBlending(Blending.None);\n        tmp.setFilter(Filter.BiLinear);\n        tmp.drawPixmap(levelPixmap,0,0,0,0,levelPixmap.getWidth(),levelPixmap.getHeight());\n        levelPixmap.dispose();\n        levelPixmap=tmp;\n      }\n      levelETCData=ETC1.encodeImagePKM(levelPixmap);\n      levelPixmap.dispose();\n      levelPixmap=null;\n    }\n    images[face][level]=new Image();\n    images[face][level].etcData=levelETCData;\n    images[face][level].pixmap=levelPixmap;\n    if (levelPixmap != null) {\n      levelPixmap.dispose();\n      facePixmap=null;\n    }\n  }\n  if (facePixmap != null) {\n    facePixmap.dispose();\n    facePixmap=null;\n  }\n  if (etc1 != null) {\n    etc1.dispose();\n    etc1=null;\n  }\n  if (ktx != null && ktxDispose == DISPOSE_FACE) {\n    ktx.disposePreparedData();\n    ktx=null;\n  }\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 817,
      "astHeight" : 15
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 5674,
        "startLineNumber" : 136,
        "startColumnNumber" : 3,
        "endLineNumber" : 275,
        "endColumnNumber" : 4
      },
      "nodeContext" : "for (int face=0; face < nFaces; face++) {\n  ETC1Data etc1=null;\n  Pixmap facePixmap=null;\n  int ktxFace=0;\n  if (ktx != null && ktx.getNumberOfFaces() == 6) {\n    nLevels=ktx.getNumberOfMipMapLevels();\n    ktxFace=face;\n  }\n else {\n    file=new FileHandle(args[face]);\n    System.out.println(\"Processing : \" + file + \" for face #\"+ face);\n    if (file.name().toLowerCase().endsWith(\".ktx\") || file.name().toLowerCase().endsWith(\".zktx\")) {\n      if (ktx == null || ktx.getNumberOfFaces() != 6) {\n        ktxDispose=DISPOSE_FACE;\n        ktx=new KTXTextureData(file,false);\n        ktx.prepare();\n      }\n      nLevels=ktx.getNumberOfMipMapLevels();\n      texWidth=ktx.getWidth();\n      texHeight=ktx.getHeight();\n    }\n else     if (file.name().toLowerCase().endsWith(\".etc1\")) {\n      etc1=new ETC1Data(file);\n      nLevels=1;\n      texWidth=etc1.width;\n      texHeight=etc1.height;\n    }\n else {\n      facePixmap=new Pixmap(file);\n      facePixmap.setBlending(Blending.None);\n      facePixmap.setFilter(Filter.BiLinear);\n      nLevels=1;\n      texWidth=facePixmap.getWidth();\n      texHeight=facePixmap.getHeight();\n    }\n    if (isGenMipMaps) {\n      if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight))       throw new GdxRuntimeException(\"Invalid input : mipmap generation is only available for power of two textures : \" + file);\n      nLevels=Math.max(Integer.SIZE - Integer.numberOfLeadingZeros(texWidth),Integer.SIZE - Integer.numberOfLeadingZeros(texHeight));\n    }\n  }\n  images[face]=new Image[nLevels];\n  for (int level=0; level < nLevels; level++) {\n    int levelWidth=Math.max(1,texWidth >> level);\n    int levelHeight=Math.max(1,texHeight >> level);\n    Pixmap levelPixmap=null;\n    ETC1Data levelETCData=null;\n    if (ktx != null) {\n      ByteBuffer ktxData=ktx.getData(level,ktxFace);\n      if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)       levelETCData=new ETC1Data(levelWidth,levelHeight,ktxData,0);\n    }\n    if (ktx != null && levelETCData == null && facePixmap == null) {\n      ByteBuffer ktxData=ktx.getData(0,ktxFace);\n      if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)       facePixmap=ETC1.decodeImage(new ETC1Data(levelWidth,levelHeight,ktxData,0),Format.RGB888);\n    }\n    if (level == 0 && etc1 != null) {\n      levelETCData=etc1;\n    }\n    if (levelETCData == null && etc1 != null && facePixmap == null) {\n      facePixmap=ETC1.decodeImage(etc1,Format.RGB888);\n    }\n    if (levelETCData == null) {\n      levelPixmap=new Pixmap(levelWidth,levelHeight,facePixmap.getFormat());\n      levelPixmap.setBlending(Blending.None);\n      levelPixmap.setFilter(Filter.BiLinear);\n      levelPixmap.drawPixmap(facePixmap,0,0,facePixmap.getWidth(),facePixmap.getHeight(),0,0,levelPixmap.getWidth(),levelPixmap.getHeight());\n    }\n    if (levelETCData == null && levelPixmap == null)     throw new GdxRuntimeException(\"Failed to load data for face \" + face + \" / mipmap level \"+ level);\n    if (isAlphaAtlas) {\n      if (levelPixmap == null)       levelPixmap=ETC1.decodeImage(levelETCData,Format.RGB888);\n      int w=levelPixmap.getWidth(), h=levelPixmap.getHeight();\n      Pixmap pm=new Pixmap(w,h * 2,levelPixmap.getFormat());\n      pm.setBlending(Blending.None);\n      pm.setFilter(Filter.BiLinear);\n      pm.drawPixmap(levelPixmap,0,0);\n      for (int y=0; y < h; y++) {\n        for (int x=0; x < w; x++) {\n          int alpha=(levelPixmap.getPixel(x,y)) & 0x0FF;\n          pm.drawPixel(x,y + h,(alpha << 24) | (alpha << 16) | (alpha << 8)| 0x0FF);\n        }\n      }\n      levelPixmap.dispose();\n      levelPixmap=pm;\n      levelETCData=null;\n    }\n    if (levelETCData == null && isPackETC1) {\n      if (levelPixmap.getFormat() != Format.RGB888 && levelPixmap.getFormat() != Format.RGB565) {\n        if (!isAlphaAtlas)         System.out.println(\"Converting from \" + levelPixmap.getFormat() + \" to RGB888 for ETC1 compression\");\n        Pixmap tmp=new Pixmap(levelPixmap.getWidth(),levelPixmap.getHeight(),Format.RGB888);\n        tmp.setBlending(Blending.None);\n        tmp.setFilter(Filter.BiLinear);\n        tmp.drawPixmap(levelPixmap,0,0,0,0,levelPixmap.getWidth(),levelPixmap.getHeight());\n        levelPixmap.dispose();\n        levelPixmap=tmp;\n      }\n      levelETCData=ETC1.encodeImagePKM(levelPixmap);\n      levelPixmap.dispose();\n      levelPixmap=null;\n    }\n    images[face][level]=new Image();\n    images[face][level].etcData=levelETCData;\n    images[face][level].pixmap=levelPixmap;\n    if (levelPixmap != null) {\n      levelPixmap.dispose();\n      facePixmap=null;\n    }\n  }\n  if (facePixmap != null) {\n    facePixmap.dispose();\n    facePixmap=null;\n  }\n  if (etc1 != null) {\n    etc1.dispose();\n    etc1=null;\n  }\n  if (ktx != null && ktxDispose == DISPOSE_FACE) {\n    ktx.disposePreparedData();\n    ktx=null;\n  }\n}\n",
      "nodeType" : "ForStatement",
      "astNodeNumber" : 828,
      "astHeight" : 16
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 11318,
        "startLineNumber" : 76,
        "startColumnNumber" : 24,
        "endLineNumber" : 346,
        "endColumnNumber" : 3
      },
      "nodeContext" : "{\n  boolean isCubemap=args.length == 7 || args.length == 8 || args.length == 9;\n  boolean isTexture=args.length == 2 || args.length == 3 || args.length == 4;\n  boolean isPackETC1=false, isAlphaAtlas=false, isGenMipMaps=false;\n  if (!isCubemap && !isTexture) {\n    System.out.println(\"usage : KTXProcessor input_file output_file [-etc1|-etc1a] [-mipmaps]\");\n    System.out.println(\"  input_file  is the texture file to include in the output KTX or ZKTX file.\");\n    System.out.println(\"              for cube map, just provide 6 input files corresponding to the faces in the following order : X+, X-, Y+, Y-, Z+, Z-\");\n    System.out.println(\"  output_file is the path to the output file, its type is based on the extension which must be either KTX or ZKTX\");\n    System.out.println();\n    System.out.println(\"  options:\");\n    System.out.println(\"    -etc1    input file will be packed using ETC1 compression, dropping the alpha channel\");\n    System.out.println(\"    -etc1a   input file will be packed using ETC1 compression, doubling the height and placing the alpha channel in the bottom half\");\n    System.out.println(\"    -mipmaps input file will be processed to generate mipmaps\");\n    System.out.println();\n    System.out.println(\"  examples:\");\n    System.out.println(\"    KTXProcessor in.png out.ktx                                        Create a KTX file with the provided 2D texture\");\n    System.out.println(\"    KTXProcessor in.png out.zktx                                       Create a Zipped KTX file with the provided 2D texture\");\n    System.out.println(\"    KTXProcessor in.png out.zktx -mipmaps                              Create a Zipped KTX file with the provided 2D texture, generating all mipmap levels\");\n    System.out.println(\"    KTXProcessor px.ktx nx.ktx py.ktx ny.ktx pz.ktx nz.ktx out.zktx    Create a Zipped KTX file with the provided cubemap textures\");\n    System.out.println(\"    KTXProcessor in.ktx out.zktx                                       Convert a KTX file to a Zipped KTX file\");\n    System.exit(-1);\n  }\n  LwjglNativesLoader.load();\n  for (int i=0; i < args.length; i++) {\n    System.out.println(i + \" = \" + args[i]);\n    if (isTexture && i < 2)     continue;\n    if (isCubemap && i < 7)     continue;\n    if (\"-etc1\".equals(args[i]))     isPackETC1=true;\n    if (\"-etc1a\".equals(args[i]))     isAlphaAtlas=isPackETC1=true;\n    if (\"-mipmaps\".equals(args[i]))     isGenMipMaps=true;\n  }\n  File output=new File(args[isCubemap ? 6 : 1]);\n  int ktxDispose=DISPOSE_DONT;\n  KTXTextureData ktx=null;\n  FileHandle file=new FileHandle(args[0]);\n  if (file.name().toLowerCase().endsWith(\".ktx\") || file.name().toLowerCase().endsWith(\".zktx\")) {\n    ktx=new KTXTextureData(file,false);\n    if (ktx.getNumberOfFaces() == 6)     isCubemap=true;\n    ktxDispose=DISPOSE_PACK;\n  }\n  int nFaces=isCubemap ? 6 : 1;\n  Image[][] images=new Image[nFaces][];\n  int texWidth=-1, texHeight=-1, texFormat=-1, nLevels=0;\n  for (int face=0; face < nFaces; face++) {\n    ETC1Data etc1=null;\n    Pixmap facePixmap=null;\n    int ktxFace=0;\n    if (ktx != null && ktx.getNumberOfFaces() == 6) {\n      nLevels=ktx.getNumberOfMipMapLevels();\n      ktxFace=face;\n    }\n else {\n      file=new FileHandle(args[face]);\n      System.out.println(\"Processing : \" + file + \" for face #\"+ face);\n      if (file.name().toLowerCase().endsWith(\".ktx\") || file.name().toLowerCase().endsWith(\".zktx\")) {\n        if (ktx == null || ktx.getNumberOfFaces() != 6) {\n          ktxDispose=DISPOSE_FACE;\n          ktx=new KTXTextureData(file,false);\n          ktx.prepare();\n        }\n        nLevels=ktx.getNumberOfMipMapLevels();\n        texWidth=ktx.getWidth();\n        texHeight=ktx.getHeight();\n      }\n else       if (file.name().toLowerCase().endsWith(\".etc1\")) {\n        etc1=new ETC1Data(file);\n        nLevels=1;\n        texWidth=etc1.width;\n        texHeight=etc1.height;\n      }\n else {\n        facePixmap=new Pixmap(file);\n        facePixmap.setBlending(Blending.None);\n        facePixmap.setFilter(Filter.BiLinear);\n        nLevels=1;\n        texWidth=facePixmap.getWidth();\n        texHeight=facePixmap.getHeight();\n      }\n      if (isGenMipMaps) {\n        if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight))         throw new GdxRuntimeException(\"Invalid input : mipmap generation is only available for power of two textures : \" + file);\n        nLevels=Math.max(Integer.SIZE - Integer.numberOfLeadingZeros(texWidth),Integer.SIZE - Integer.numberOfLeadingZeros(texHeight));\n      }\n    }\n    images[face]=new Image[nLevels];\n    for (int level=0; level < nLevels; level++) {\n      int levelWidth=Math.max(1,texWidth >> level);\n      int levelHeight=Math.max(1,texHeight >> level);\n      Pixmap levelPixmap=null;\n      ETC1Data levelETCData=null;\n      if (ktx != null) {\n        ByteBuffer ktxData=ktx.getData(level,ktxFace);\n        if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)         levelETCData=new ETC1Data(levelWidth,levelHeight,ktxData,0);\n      }\n      if (ktx != null && levelETCData == null && facePixmap == null) {\n        ByteBuffer ktxData=ktx.getData(0,ktxFace);\n        if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)         facePixmap=ETC1.decodeImage(new ETC1Data(levelWidth,levelHeight,ktxData,0),Format.RGB888);\n      }\n      if (level == 0 && etc1 != null) {\n        levelETCData=etc1;\n      }\n      if (levelETCData == null && etc1 != null && facePixmap == null) {\n        facePixmap=ETC1.decodeImage(etc1,Format.RGB888);\n      }\n      if (levelETCData == null) {\n        levelPixmap=new Pixmap(levelWidth,levelHeight,facePixmap.getFormat());\n        levelPixmap.setBlending(Blending.None);\n        levelPixmap.setFilter(Filter.BiLinear);\n        levelPixmap.drawPixmap(facePixmap,0,0,facePixmap.getWidth(),facePixmap.getHeight(),0,0,levelPixmap.getWidth(),levelPixmap.getHeight());\n      }\n      if (levelETCData == null && levelPixmap == null)       throw new GdxRuntimeException(\"Failed to load data for face \" + face + \" / mipmap level \"+ level);\n      if (isAlphaAtlas) {\n        if (levelPixmap == null)         levelPixmap=ETC1.decodeImage(levelETCData,Format.RGB888);\n        int w=levelPixmap.getWidth(), h=levelPixmap.getHeight();\n        Pixmap pm=new Pixmap(w,h * 2,levelPixmap.getFormat());\n        pm.setBlending(Blending.None);\n        pm.setFilter(Filter.BiLinear);\n        pm.drawPixmap(levelPixmap,0,0);\n        for (int y=0; y < h; y++) {\n          for (int x=0; x < w; x++) {\n            int alpha=(levelPixmap.getPixel(x,y)) & 0x0FF;\n            pm.drawPixel(x,y + h,(alpha << 24) | (alpha << 16) | (alpha << 8)| 0x0FF);\n          }\n        }\n        levelPixmap.dispose();\n        levelPixmap=pm;\n        levelETCData=null;\n      }\n      if (levelETCData == null && isPackETC1) {\n        if (levelPixmap.getFormat() != Format.RGB888 && levelPixmap.getFormat() != Format.RGB565) {\n          if (!isAlphaAtlas)           System.out.println(\"Converting from \" + levelPixmap.getFormat() + \" to RGB888 for ETC1 compression\");\n          Pixmap tmp=new Pixmap(levelPixmap.getWidth(),levelPixmap.getHeight(),Format.RGB888);\n          tmp.setBlending(Blending.None);\n          tmp.setFilter(Filter.BiLinear);\n          tmp.drawPixmap(levelPixmap,0,0,0,0,levelPixmap.getWidth(),levelPixmap.getHeight());\n          levelPixmap.dispose();\n          levelPixmap=tmp;\n        }\n        levelETCData=ETC1.encodeImagePKM(levelPixmap);\n        levelPixmap.dispose();\n        levelPixmap=null;\n      }\n      images[face][level]=new Image();\n      images[face][level].etcData=levelETCData;\n      images[face][level].pixmap=levelPixmap;\n      if (levelPixmap != null) {\n        levelPixmap.dispose();\n        facePixmap=null;\n      }\n    }\n    if (facePixmap != null) {\n      facePixmap.dispose();\n      facePixmap=null;\n    }\n    if (etc1 != null) {\n      etc1.dispose();\n      etc1=null;\n    }\n    if (ktx != null && ktxDispose == DISPOSE_FACE) {\n      ktx.disposePreparedData();\n      ktx=null;\n    }\n  }\n  if (ktx != null) {\n    ktx.disposePreparedData();\n    ktx=null;\n  }\n  int glType, glTypeSize, glFormat, glInternalFormat, glBaseInternalFormat;\n  if (isPackETC1) {\n    glType=glFormat=0;\n    glTypeSize=1;\n    glInternalFormat=ETC1.ETC1_RGB8_OES;\n    glBaseInternalFormat=GL20.GL_RGB;\n  }\n else   if (images[0][0].pixmap != null) {\n    glType=images[0][0].pixmap.getGLType();\n    glTypeSize=1;\n    glFormat=images[0][0].pixmap.getGLFormat();\n    glInternalFormat=images[0][0].pixmap.getGLInternalFormat();\n    glBaseInternalFormat=glFormat;\n  }\n else   throw new GdxRuntimeException(\"Unsupported output format\");\n  int totalSize=12 + 13 * 4;\n  for (int level=0; level < nLevels; level++) {\n    System.out.println(\"Level: \" + level);\n    int faceLodSize=images[0][level].getSize();\n    int faceLodSizeRounded=(faceLodSize + 3) & ~3;\n    totalSize+=4;\n    totalSize+=nFaces * faceLodSizeRounded;\n  }\n  try {\n    DataOutputStream out;\n    if (output.getName().toLowerCase().endsWith(\".zktx\")) {\n      out=new DataOutputStream(new GZIPOutputStream(new FileOutputStream(output)));\n      out.writeInt(totalSize);\n    }\n else     out=new DataOutputStream(new FileOutputStream(output));\n    out.write(HEADER_MAGIC);\n    out.writeInt(0x04030201);\n    out.writeInt(glType);\n    out.writeInt(glTypeSize);\n    out.writeInt(glFormat);\n    out.writeInt(glInternalFormat);\n    out.writeInt(glBaseInternalFormat);\n    out.writeInt(texWidth);\n    out.writeInt(isAlphaAtlas ? (2 * texHeight) : texHeight);\n    out.writeInt(0);\n    out.writeInt(0);\n    out.writeInt(nFaces);\n    out.writeInt(nLevels);\n    out.writeInt(0);\n    for (int level=0; level < nLevels; level++) {\n      int faceLodSize=images[0][level].getSize();\n      int faceLodSizeRounded=(faceLodSize + 3) & ~3;\n      out.writeInt(faceLodSize);\n      for (int face=0; face < nFaces; face++) {\n        byte[] bytes=images[face][level].getBytes();\n        out.write(bytes);\n        for (int j=bytes.length; j < faceLodSizeRounded; j++)         out.write((byte)0x00);\n      }\n    }\n    out.close();\n    System.out.println(\"Finished\");\n  }\n catch (  Exception e) {\n    Gdx.app.error(\"KTXProcessor\",\"Error writing to file: \" + output.getName(),e);\n  }\n  Gdx.app.exit();\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 1619,
      "astHeight" : 17
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 11353,
        "startLineNumber" : 75,
        "startColumnNumber" : 2,
        "endLineNumber" : 346,
        "endColumnNumber" : 3
      },
      "nodeContext" : "@Override public void create(){\n  boolean isCubemap=args.length == 7 || args.length == 8 || args.length == 9;\n  boolean isTexture=args.length == 2 || args.length == 3 || args.length == 4;\n  boolean isPackETC1=false, isAlphaAtlas=false, isGenMipMaps=false;\n  if (!isCubemap && !isTexture) {\n    System.out.println(\"usage : KTXProcessor input_file output_file [-etc1|-etc1a] [-mipmaps]\");\n    System.out.println(\"  input_file  is the texture file to include in the output KTX or ZKTX file.\");\n    System.out.println(\"              for cube map, just provide 6 input files corresponding to the faces in the following order : X+, X-, Y+, Y-, Z+, Z-\");\n    System.out.println(\"  output_file is the path to the output file, its type is based on the extension which must be either KTX or ZKTX\");\n    System.out.println();\n    System.out.println(\"  options:\");\n    System.out.println(\"    -etc1    input file will be packed using ETC1 compression, dropping the alpha channel\");\n    System.out.println(\"    -etc1a   input file will be packed using ETC1 compression, doubling the height and placing the alpha channel in the bottom half\");\n    System.out.println(\"    -mipmaps input file will be processed to generate mipmaps\");\n    System.out.println();\n    System.out.println(\"  examples:\");\n    System.out.println(\"    KTXProcessor in.png out.ktx                                        Create a KTX file with the provided 2D texture\");\n    System.out.println(\"    KTXProcessor in.png out.zktx                                       Create a Zipped KTX file with the provided 2D texture\");\n    System.out.println(\"    KTXProcessor in.png out.zktx -mipmaps                              Create a Zipped KTX file with the provided 2D texture, generating all mipmap levels\");\n    System.out.println(\"    KTXProcessor px.ktx nx.ktx py.ktx ny.ktx pz.ktx nz.ktx out.zktx    Create a Zipped KTX file with the provided cubemap textures\");\n    System.out.println(\"    KTXProcessor in.ktx out.zktx                                       Convert a KTX file to a Zipped KTX file\");\n    System.exit(-1);\n  }\n  LwjglNativesLoader.load();\n  for (int i=0; i < args.length; i++) {\n    System.out.println(i + \" = \" + args[i]);\n    if (isTexture && i < 2)     continue;\n    if (isCubemap && i < 7)     continue;\n    if (\"-etc1\".equals(args[i]))     isPackETC1=true;\n    if (\"-etc1a\".equals(args[i]))     isAlphaAtlas=isPackETC1=true;\n    if (\"-mipmaps\".equals(args[i]))     isGenMipMaps=true;\n  }\n  File output=new File(args[isCubemap ? 6 : 1]);\n  int ktxDispose=DISPOSE_DONT;\n  KTXTextureData ktx=null;\n  FileHandle file=new FileHandle(args[0]);\n  if (file.name().toLowerCase().endsWith(\".ktx\") || file.name().toLowerCase().endsWith(\".zktx\")) {\n    ktx=new KTXTextureData(file,false);\n    if (ktx.getNumberOfFaces() == 6)     isCubemap=true;\n    ktxDispose=DISPOSE_PACK;\n  }\n  int nFaces=isCubemap ? 6 : 1;\n  Image[][] images=new Image[nFaces][];\n  int texWidth=-1, texHeight=-1, texFormat=-1, nLevels=0;\n  for (int face=0; face < nFaces; face++) {\n    ETC1Data etc1=null;\n    Pixmap facePixmap=null;\n    int ktxFace=0;\n    if (ktx != null && ktx.getNumberOfFaces() == 6) {\n      nLevels=ktx.getNumberOfMipMapLevels();\n      ktxFace=face;\n    }\n else {\n      file=new FileHandle(args[face]);\n      System.out.println(\"Processing : \" + file + \" for face #\"+ face);\n      if (file.name().toLowerCase().endsWith(\".ktx\") || file.name().toLowerCase().endsWith(\".zktx\")) {\n        if (ktx == null || ktx.getNumberOfFaces() != 6) {\n          ktxDispose=DISPOSE_FACE;\n          ktx=new KTXTextureData(file,false);\n          ktx.prepare();\n        }\n        nLevels=ktx.getNumberOfMipMapLevels();\n        texWidth=ktx.getWidth();\n        texHeight=ktx.getHeight();\n      }\n else       if (file.name().toLowerCase().endsWith(\".etc1\")) {\n        etc1=new ETC1Data(file);\n        nLevels=1;\n        texWidth=etc1.width;\n        texHeight=etc1.height;\n      }\n else {\n        facePixmap=new Pixmap(file);\n        facePixmap.setBlending(Blending.None);\n        facePixmap.setFilter(Filter.BiLinear);\n        nLevels=1;\n        texWidth=facePixmap.getWidth();\n        texHeight=facePixmap.getHeight();\n      }\n      if (isGenMipMaps) {\n        if (!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight))         throw new GdxRuntimeException(\"Invalid input : mipmap generation is only available for power of two textures : \" + file);\n        nLevels=Math.max(Integer.SIZE - Integer.numberOfLeadingZeros(texWidth),Integer.SIZE - Integer.numberOfLeadingZeros(texHeight));\n      }\n    }\n    images[face]=new Image[nLevels];\n    for (int level=0; level < nLevels; level++) {\n      int levelWidth=Math.max(1,texWidth >> level);\n      int levelHeight=Math.max(1,texHeight >> level);\n      Pixmap levelPixmap=null;\n      ETC1Data levelETCData=null;\n      if (ktx != null) {\n        ByteBuffer ktxData=ktx.getData(level,ktxFace);\n        if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)         levelETCData=new ETC1Data(levelWidth,levelHeight,ktxData,0);\n      }\n      if (ktx != null && levelETCData == null && facePixmap == null) {\n        ByteBuffer ktxData=ktx.getData(0,ktxFace);\n        if (ktxData != null && ktx.getGlInternalFormat() == ETC1.ETC1_RGB8_OES)         facePixmap=ETC1.decodeImage(new ETC1Data(levelWidth,levelHeight,ktxData,0),Format.RGB888);\n      }\n      if (level == 0 && etc1 != null) {\n        levelETCData=etc1;\n      }\n      if (levelETCData == null && etc1 != null && facePixmap == null) {\n        facePixmap=ETC1.decodeImage(etc1,Format.RGB888);\n      }\n      if (levelETCData == null) {\n        levelPixmap=new Pixmap(levelWidth,levelHeight,facePixmap.getFormat());\n        levelPixmap.setBlending(Blending.None);\n        levelPixmap.setFilter(Filter.BiLinear);\n        levelPixmap.drawPixmap(facePixmap,0,0,facePixmap.getWidth(),facePixmap.getHeight(),0,0,levelPixmap.getWidth(),levelPixmap.getHeight());\n      }\n      if (levelETCData == null && levelPixmap == null)       throw new GdxRuntimeException(\"Failed to load data for face \" + face + \" / mipmap level \"+ level);\n      if (isAlphaAtlas) {\n        if (levelPixmap == null)         levelPixmap=ETC1.decodeImage(levelETCData,Format.RGB888);\n        int w=levelPixmap.getWidth(), h=levelPixmap.getHeight();\n        Pixmap pm=new Pixmap(w,h * 2,levelPixmap.getFormat());\n        pm.setBlending(Blending.None);\n        pm.setFilter(Filter.BiLinear);\n        pm.drawPixmap(levelPixmap,0,0);\n        for (int y=0; y < h; y++) {\n          for (int x=0; x < w; x++) {\n            int alpha=(levelPixmap.getPixel(x,y)) & 0x0FF;\n            pm.drawPixel(x,y + h,(alpha << 24) | (alpha << 16) | (alpha << 8)| 0x0FF);\n          }\n        }\n        levelPixmap.dispose();\n        levelPixmap=pm;\n        levelETCData=null;\n      }\n      if (levelETCData == null && isPackETC1) {\n        if (levelPixmap.getFormat() != Format.RGB888 && levelPixmap.getFormat() != Format.RGB565) {\n          if (!isAlphaAtlas)           System.out.println(\"Converting from \" + levelPixmap.getFormat() + \" to RGB888 for ETC1 compression\");\n          Pixmap tmp=new Pixmap(levelPixmap.getWidth(),levelPixmap.getHeight(),Format.RGB888);\n          tmp.setBlending(Blending.None);\n          tmp.setFilter(Filter.BiLinear);\n          tmp.drawPixmap(levelPixmap,0,0,0,0,levelPixmap.getWidth(),levelPixmap.getHeight());\n          levelPixmap.dispose();\n          levelPixmap=tmp;\n        }\n        levelETCData=ETC1.encodeImagePKM(levelPixmap);\n        levelPixmap.dispose();\n        levelPixmap=null;\n      }\n      images[face][level]=new Image();\n      images[face][level].etcData=levelETCData;\n      images[face][level].pixmap=levelPixmap;\n      if (levelPixmap != null) {\n        levelPixmap.dispose();\n        facePixmap=null;\n      }\n    }\n    if (facePixmap != null) {\n      facePixmap.dispose();\n      facePixmap=null;\n    }\n    if (etc1 != null) {\n      etc1.dispose();\n      etc1=null;\n    }\n    if (ktx != null && ktxDispose == DISPOSE_FACE) {\n      ktx.disposePreparedData();\n      ktx=null;\n    }\n  }\n  if (ktx != null) {\n    ktx.disposePreparedData();\n    ktx=null;\n  }\n  int glType, glTypeSize, glFormat, glInternalFormat, glBaseInternalFormat;\n  if (isPackETC1) {\n    glType=glFormat=0;\n    glTypeSize=1;\n    glInternalFormat=ETC1.ETC1_RGB8_OES;\n    glBaseInternalFormat=GL20.GL_RGB;\n  }\n else   if (images[0][0].pixmap != null) {\n    glType=images[0][0].pixmap.getGLType();\n    glTypeSize=1;\n    glFormat=images[0][0].pixmap.getGLFormat();\n    glInternalFormat=images[0][0].pixmap.getGLInternalFormat();\n    glBaseInternalFormat=glFormat;\n  }\n else   throw new GdxRuntimeException(\"Unsupported output format\");\n  int totalSize=12 + 13 * 4;\n  for (int level=0; level < nLevels; level++) {\n    System.out.println(\"Level: \" + level);\n    int faceLodSize=images[0][level].getSize();\n    int faceLodSizeRounded=(faceLodSize + 3) & ~3;\n    totalSize+=4;\n    totalSize+=nFaces * faceLodSizeRounded;\n  }\n  try {\n    DataOutputStream out;\n    if (output.getName().toLowerCase().endsWith(\".zktx\")) {\n      out=new DataOutputStream(new GZIPOutputStream(new FileOutputStream(output)));\n      out.writeInt(totalSize);\n    }\n else     out=new DataOutputStream(new FileOutputStream(output));\n    out.write(HEADER_MAGIC);\n    out.writeInt(0x04030201);\n    out.writeInt(glType);\n    out.writeInt(glTypeSize);\n    out.writeInt(glFormat);\n    out.writeInt(glInternalFormat);\n    out.writeInt(glBaseInternalFormat);\n    out.writeInt(texWidth);\n    out.writeInt(isAlphaAtlas ? (2 * texHeight) : texHeight);\n    out.writeInt(0);\n    out.writeInt(0);\n    out.writeInt(nFaces);\n    out.writeInt(nLevels);\n    out.writeInt(0);\n    for (int level=0; level < nLevels; level++) {\n      int faceLodSize=images[0][level].getSize();\n      int faceLodSizeRounded=(faceLodSize + 3) & ~3;\n      out.writeInt(faceLodSize);\n      for (int face=0; face < nFaces; face++) {\n        byte[] bytes=images[face][level].getBytes();\n        out.write(bytes);\n        for (int j=bytes.length; j < faceLodSizeRounded; j++)         out.write((byte)0x00);\n      }\n    }\n    out.close();\n    System.out.println(\"Finished\");\n  }\n catch (  Exception e) {\n    Gdx.app.error(\"KTXProcessor\",\"Error writing to file: \" + output.getName(),e);\n  }\n  Gdx.app.exit();\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 1625,
      "astHeight" : 18
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.IfStatement,expression]",
      "nodePosition" : {
        "charLength" : 71,
        "startLineNumber" : 172,
        "startColumnNumber" : 10,
        "endLineNumber" : 172,
        "endColumnNumber" : 81
      },
      "nodeContext" : "!MathUtils.isPowerOfTwo(texWidth) || !MathUtils.isPowerOfTwo(texHeight)",
      "nodeType" : "InfixExpression",
      "astNodeNumber" : 11,
      "astHeight" : 4
    },
    "tokenLength" : 3,
    "type" : "boolean"
  } ],
  "positionList" : [ {
    "charLength" : 32,
    "startLineNumber" : 172,
    "startColumnNumber" : 11,
    "endLineNumber" : 172,
    "endColumnNumber" : 43
  } ],
  "layoutRelationDataList" : [ ]
}