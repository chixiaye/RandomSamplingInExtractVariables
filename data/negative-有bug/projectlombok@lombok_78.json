{
  "id" : 78,
  "expression" : "annotation.get()",
  "projectName" : "projectlombok@lombok",
  "commitID" : "25def866b50860715ee7c315c678b8c3d1ba9b56",
  "filePath" : "/src/core/lombok/javac/handlers/HandleDelegate.java",
  "occurrences" : 1,
  "isArithmeticExpression" : 0,
  "isGetTypeMethod" : 0,
  "expressionList" : [ {
    "nodeContext" : "annotation.get()",
    "nodeType" : "MethodInvocation",
    "nodePosition" : {
      "charLength" : 16,
      "startLineNumber" : 317,
      "startColumnNumber" : 147,
      "endLineNumber" : 317,
      "endColumnNumber" : 163
    },
    "astNodeNumber" : 3,
    "astHeight" : 2,
    "parentDataList" : [ {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.ReturnStatement,expression]",
      "nodePosition" : {
        "charLength" : 155,
        "startLineNumber" : 317,
        "startColumnNumber" : 9,
        "endLineNumber" : 317,
        "endColumnNumber" : 164
      },
      "nodeContext" : "recursiveSetGeneratedBy(maker.MethodDef(mods,sig.name,returnType,toList(typeParams),toList(params),toList(thrown),bodyBlock,null),annotation.get())",
      "nodeType" : "MethodInvocation",
      "astNodeNumber" : 24,
      "astHeight" : 4
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 163,
        "startLineNumber" : 317,
        "startColumnNumber" : 2,
        "endLineNumber" : 317,
        "endColumnNumber" : 165
      },
      "nodeContext" : "return recursiveSetGeneratedBy(maker.MethodDef(mods,sig.name,returnType,toList(typeParams),toList(params),toList(thrown),bodyBlock,null),annotation.get());\n",
      "nodeType" : "ReturnStatement",
      "astNodeNumber" : 25,
      "astHeight" : 5
    }, {
      "locationInParent" : "ChildProperty[org.eclipse.jdt.core.dom.MethodDeclaration,body]",
      "nodePosition" : {
        "charLength" : 3051,
        "startLineNumber" : 259,
        "startColumnNumber" : 188,
        "endLineNumber" : 318,
        "endColumnNumber" : 2
      },
      "nodeContext" : "{\n  checkConflictOfTypeVarNames(sig,annotation);\n  TreeMaker maker=annotation.getTreeMaker();\n  com.sun.tools.javac.util.List<JCAnnotation> annotations;\n  if (sig.isDeprecated) {\n    annotations=com.sun.tools.javac.util.List.of(maker.Annotation(chainDots(annotation,\"java\",\"lang\",\"Deprecated\"),com.sun.tools.javac.util.List.<JCExpression>nil()));\n  }\n else {\n    annotations=com.sun.tools.javac.util.List.nil();\n  }\n  JCModifiers mods=maker.Modifiers(Flags.PUBLIC,annotations);\n  JCExpression returnType=JavacResolution.typeToJCTree((Type)sig.type.getReturnType(),annotation.getAst(),true);\n  boolean useReturn=sig.type.getReturnType().getKind() != TypeKind.VOID;\n  ListBuffer<JCVariableDecl> params=sig.type.getParameterTypes().isEmpty() ? null : new ListBuffer<JCVariableDecl>();\n  ListBuffer<JCExpression> args=sig.type.getParameterTypes().isEmpty() ? null : new ListBuffer<JCExpression>();\n  ListBuffer<JCExpression> thrown=sig.type.getThrownTypes().isEmpty() ? null : new ListBuffer<JCExpression>();\n  ListBuffer<JCTypeParameter> typeParams=sig.type.getTypeVariables().isEmpty() ? null : new ListBuffer<JCTypeParameter>();\n  ListBuffer<JCExpression> typeArgs=sig.type.getTypeVariables().isEmpty() ? null : new ListBuffer<JCExpression>();\n  Types types=Types.instance(annotation.getContext());\n  for (  TypeMirror param : sig.type.getTypeVariables()) {\n    Name name=((TypeVar)param).tsym.name;\n    ListBuffer<JCExpression> bounds=types.getBounds((TypeVar)param).isEmpty() ? null : new ListBuffer<JCExpression>();\n    for (    Type type : types.getBounds((TypeVar)param)) {\n      bounds.append(JavacResolution.typeToJCTree(type,annotation.getAst(),true));\n    }\n    typeParams.append(maker.TypeParameter(name,bounds.toList()));\n    typeArgs.append(maker.Ident(name));\n  }\n  for (  TypeMirror ex : sig.type.getThrownTypes()) {\n    thrown.append(JavacResolution.typeToJCTree((Type)ex,annotation.getAst(),true));\n  }\n  int idx=0;\n  for (  TypeMirror param : sig.type.getParameterTypes()) {\n    JCModifiers paramMods=maker.Modifiers(Flags.FINAL);\n    String[] paramNames=sig.getParameterNames();\n    Name name=annotation.toName(paramNames[idx++]);\n    params.append(maker.VarDef(paramMods,name,JavacResolution.typeToJCTree((Type)param,annotation.getAst(),true),null));\n    args.append(maker.Ident(name));\n  }\n  JCExpression delegateCall=maker.Apply(toList(typeArgs),maker.Select(delegateReceiver.get(annotation,delegateName),sig.name),toList(args));\n  JCStatement body=useReturn ? maker.Return(delegateCall) : maker.Exec(delegateCall);\n  JCBlock bodyBlock=maker.Block(0,com.sun.tools.javac.util.List.of(body));\n  return recursiveSetGeneratedBy(maker.MethodDef(mods,sig.name,returnType,toList(typeParams),toList(params),toList(thrown),bodyBlock,null),annotation.get());\n}\n",
      "nodeType" : "Block",
      "astNodeNumber" : 553,
      "astHeight" : 14
    }, {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.TypeDeclaration,bodyDeclarations]",
      "nodePosition" : {
        "charLength" : 3238,
        "startLineNumber" : 259,
        "startColumnNumber" : 1,
        "endLineNumber" : 318,
        "endColumnNumber" : 2
      },
      "nodeContext" : "private JCMethodDecl createDelegateMethod(MethodSig sig,JavacNode annotation,Name delegateName,DelegateReceiver delegateReceiver) throws TypeNotConvertibleException, CantMakeDelegates {\n  checkConflictOfTypeVarNames(sig,annotation);\n  TreeMaker maker=annotation.getTreeMaker();\n  com.sun.tools.javac.util.List<JCAnnotation> annotations;\n  if (sig.isDeprecated) {\n    annotations=com.sun.tools.javac.util.List.of(maker.Annotation(chainDots(annotation,\"java\",\"lang\",\"Deprecated\"),com.sun.tools.javac.util.List.<JCExpression>nil()));\n  }\n else {\n    annotations=com.sun.tools.javac.util.List.nil();\n  }\n  JCModifiers mods=maker.Modifiers(Flags.PUBLIC,annotations);\n  JCExpression returnType=JavacResolution.typeToJCTree((Type)sig.type.getReturnType(),annotation.getAst(),true);\n  boolean useReturn=sig.type.getReturnType().getKind() != TypeKind.VOID;\n  ListBuffer<JCVariableDecl> params=sig.type.getParameterTypes().isEmpty() ? null : new ListBuffer<JCVariableDecl>();\n  ListBuffer<JCExpression> args=sig.type.getParameterTypes().isEmpty() ? null : new ListBuffer<JCExpression>();\n  ListBuffer<JCExpression> thrown=sig.type.getThrownTypes().isEmpty() ? null : new ListBuffer<JCExpression>();\n  ListBuffer<JCTypeParameter> typeParams=sig.type.getTypeVariables().isEmpty() ? null : new ListBuffer<JCTypeParameter>();\n  ListBuffer<JCExpression> typeArgs=sig.type.getTypeVariables().isEmpty() ? null : new ListBuffer<JCExpression>();\n  Types types=Types.instance(annotation.getContext());\n  for (  TypeMirror param : sig.type.getTypeVariables()) {\n    Name name=((TypeVar)param).tsym.name;\n    ListBuffer<JCExpression> bounds=types.getBounds((TypeVar)param).isEmpty() ? null : new ListBuffer<JCExpression>();\n    for (    Type type : types.getBounds((TypeVar)param)) {\n      bounds.append(JavacResolution.typeToJCTree(type,annotation.getAst(),true));\n    }\n    typeParams.append(maker.TypeParameter(name,bounds.toList()));\n    typeArgs.append(maker.Ident(name));\n  }\n  for (  TypeMirror ex : sig.type.getThrownTypes()) {\n    thrown.append(JavacResolution.typeToJCTree((Type)ex,annotation.getAst(),true));\n  }\n  int idx=0;\n  for (  TypeMirror param : sig.type.getParameterTypes()) {\n    JCModifiers paramMods=maker.Modifiers(Flags.FINAL);\n    String[] paramNames=sig.getParameterNames();\n    Name name=annotation.toName(paramNames[idx++]);\n    params.append(maker.VarDef(paramMods,name,JavacResolution.typeToJCTree((Type)param,annotation.getAst(),true),null));\n    args.append(maker.Ident(name));\n  }\n  JCExpression delegateCall=maker.Apply(toList(typeArgs),maker.Select(delegateReceiver.get(annotation,delegateName),sig.name),toList(args));\n  JCStatement body=useReturn ? maker.Return(delegateCall) : maker.Exec(delegateCall);\n  JCBlock bodyBlock=maker.Block(0,com.sun.tools.javac.util.List.of(body));\n  return recursiveSetGeneratedBy(maker.MethodDef(mods,sig.name,returnType,toList(typeParams),toList(params),toList(thrown),bodyBlock,null),annotation.get());\n}\n",
      "nodeType" : "MethodDeclaration",
      "astNodeNumber" : 578,
      "astHeight" : 15
    } ],
    "currentLineData" : {
      "locationInParent" : "ChildListProperty[org.eclipse.jdt.core.dom.Block,statements]",
      "nodePosition" : {
        "charLength" : 163,
        "startLineNumber" : 317,
        "startColumnNumber" : 2,
        "endLineNumber" : 317,
        "endColumnNumber" : 165
      },
      "nodeContext" : "return recursiveSetGeneratedBy(maker.MethodDef(mods,sig.name,returnType,toList(typeParams),toList(params),toList(thrown),bodyBlock,null),annotation.get());\n",
      "nodeType" : "ReturnStatement",
      "astNodeNumber" : 25,
      "astHeight" : 5
    },
    "tokenLength" : 2,
    "type" : "lombok.javac.JCTree"
  } ],
  "positionList" : [ {
    "charLength" : 16,
    "startLineNumber" : 317,
    "startColumnNumber" : 147,
    "endLineNumber" : 317,
    "endColumnNumber" : 163
  } ],
  "layoutRelationDataList" : [ ]
}